<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="1.什么是预编译？何时需要预编译？什么是预编译：1）预编译又称为预处理，是做些代码文本的替换工作；2）处理以 # 开头的指令，比如拷贝 #include 包含的文件代码， #define 宏定义的替换， 条件编译等， 就是为编译做的预备工作的阶段。3）主要处理 # 开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。4）C编译系统在对程序进行通常的编译">
<meta property="og:type" content="article">
<meta property="og:title" content="软件研发面试题汇总">
<meta property="og:url" content="https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="不想当咸鱼的盐蛋">
<meta property="og:description" content="1.什么是预编译？何时需要预编译？什么是预编译：1）预编译又称为预处理，是做些代码文本的替换工作；2）处理以 # 开头的指令，比如拷贝 #include 包含的文件代码， #define 宏定义的替换， 条件编译等， 就是为编译做的预备工作的阶段。3）主要处理 # 开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。4）C编译系统在对程序进行通常的编译">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-09-21T08:45:51.000Z">
<meta property="article:modified_time" content="2019-12-20T08:21:16.760Z">
<meta property="article:author" content="尹小丹">
<meta property="article:tag" content="interview">
<meta property="article:tag" content="software devolopment">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>软件研发面试题汇总</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="不想当咸鱼的盐蛋" type="application/atom+xml">
</head>
<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="http://dufaxing.com/" target="_blank" rel="noopener">Links</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/12/20/technology/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E8%A3%85CoAP%E8%B0%83%E8%AF%95%E5%AE%A2%E6%88%B7%E7%AB%AFCopper%E6%8F%92%E4%BB%B6/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/09/19/interview/Test%20position%20%EF%BC%88interview%20question%EF%BC%89/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&text=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&title=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&is_video=false&description=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=软件研发面试题汇总&body=Check out this article: https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&title=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&title=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&title=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&title=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&name=软件研发面试题汇总&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&t=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是预编译？何时需要预编译？"><span class="toc-number">1.</span> <span class="toc-text">1.什么是预编译？何时需要预编译？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-char-const-p-char-const-p-const-char-p-这三者有什么区别？"><span class="toc-number">2.</span> <span class="toc-text">2.char * const p ; char const * p ; const char * p  这三者有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-求输出结果"><span class="toc-number">3.</span> <span class="toc-text">3. 求输出结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-请问下面的代码有什么问题"><span class="toc-number">4.</span> <span class="toc-text">4.请问下面的代码有什么问题?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-代码有何问题？"><span class="toc-number">5.</span> <span class="toc-text">5.代码有何问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-如何用C语言编写死循环？"><span class="toc-number">6.</span> <span class="toc-text">6.如何用C语言编写死循环？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-new-和-malloc-的区别？"><span class="toc-number">7.</span> <span class="toc-text">7.new 和 malloc 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-堆和栈的区别"><span class="toc-number">8.</span> <span class="toc-text">8.堆和栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-指针与引用的区别"><span class="toc-number">9.</span> <span class="toc-text">9.指针与引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-C-的内存管理"><span class="toc-number">10.</span> <span class="toc-text">11.C++的内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-什么是内存泄漏"><span class="toc-number">11.</span> <span class="toc-text">12.什么是内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13"><span class="toc-number">12.</span> <span class="toc-text">13.</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        软件研发面试题汇总
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">不想当咸鱼的盐蛋</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-09-21T08:45:51.000Z" itemprop="datePublished">2019-09-21</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/interview/">interview</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/interview/" rel="tag">interview</a>, <a class="tag-link" href="/tags/software-devolopment/" rel="tag">software devolopment</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="1-什么是预编译？何时需要预编译？"><a href="#1-什么是预编译？何时需要预编译？" class="headerlink" title="1.什么是预编译？何时需要预编译？"></a>1.什么是预编译？何时需要预编译？</h2><p><strong>什么是预编译：</strong><br>1）预编译又称为预处理，是做些代码文本的替换工作；<br>2）处理以 # 开头的指令，比如拷贝 #include 包含的文件代码， #define 宏定义的替换， 条件编译等， 就是为编译做的预备工作的阶段。<br>3）主要处理 # 开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。<br>4）C编译系统在对程序进行通常的编译之前，首先进行预处理。</p>
<p><strong>何时需要预编译：</strong><br>1）总是使用不经常改动的大型代码体；<br>2）程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个“预编译头”.</p>
<h2 id="2-char-const-p-char-const-p-const-char-p-这三者有什么区别？"><a href="#2-char-const-p-char-const-p-const-char-p-这三者有什么区别？" class="headerlink" title="2.char * const p ; char const * p ; const char * p  这三者有什么区别？"></a>2.char * const p ; char const * p ; const char * p  这三者有什么区别？</h2><h2 id="3-求输出结果"><a href="#3-求输出结果" class="headerlink" title="3. 求输出结果"></a>3. 求输出结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char str1[] &#x3D; &quot;abc&quot;;</span><br><span class="line">char str2[] &#x3D; &quot;abc&quot;;</span><br><span class="line">const char str3[] &#x3D; &quot;abc&quot;;</span><br><span class="line">const char str4[] &#x3D; &quot;abc&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>上面是数组变量，他们有各自的内存空间</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const char * str5 &#x3D; &quot;abc&quot;;</span><br><span class="line">const char * str6 &#x3D; &quot;abc&quot;;</span><br><span class="line">char * str7 &#x3D; &quot;abc&quot;;</span><br><span class="line">char * str8 &#x3D; &quot;abc&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>上面的指针指向相同的常量地址区域</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (str1 &#x3D;&#x3D; str2) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (str3 &#x3D;&#x3D; str4) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><strong>所以数组变量的地址不一样</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (str5 &#x3D;&#x3D; str6) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (str7 &#x3D;&#x3D; str8) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><strong>所以指针的地址是一样的</strong></p>
<p><strong>结果是： 0 0 1 1</strong></p>
<h2 id="4-请问下面的代码有什么问题"><a href="#4-请问下面的代码有什么问题" class="headerlink" title="4.请问下面的代码有什么问题?"></a>4.请问下面的代码有什么问题?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char a;</span><br><span class="line">	char *str &#x3D; &amp;a;</span><br><span class="line">	strcpy(str,&quot;hello&quot;);</span><br><span class="line">	printf(str);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：没有为str分配内存空间，将会发生异常。<br>问题出在，将一个字符串复制进一个字符变量指针所指地址，虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。<br>就是说，你给了指针一个地址，但是这个地址长度不一定够，所以会越界，越界就会产生segmentation fault。</p>
<h2 id="5-代码有何问题？"><a href="#5-代码有何问题？" class="headerlink" title="5.代码有何问题？"></a>5.代码有何问题？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char * s &#x3D; &quot;AAA&quot;;</span><br><span class="line">printf(&quot;%s&quot;,s);</span><br><span class="line"></span><br><span class="line">s[0] &#x3D; &#39;B&#39;;</span><br><span class="line">printf(&quot;%s&quot;,s);</span><br></pre></td></tr></table></figure>
<p>有什么错？</p>
<p>“AAA”是字符串常量。<br>s是指针，指向这个字符串常量，所以声明s的时候就有问题。<br>应该为：const char * s = “AAA”;</p>
<p>然后又因为是常量，所以对s[0]的赋值操作是不合法的。</p>
<h2 id="6-如何用C语言编写死循环？"><a href="#6-如何用C语言编写死循环？" class="headerlink" title="6.如何用C语言编写死循环？"></a>6.如何用C语言编写死循环？</h2><p>while(1){}<br>或<br>for(;;)</p>
<h2 id="7-new-和-malloc-的区别？"><a href="#7-new-和-malloc-的区别？" class="headerlink" title="7.new 和 malloc 的区别？"></a>7.new 和 malloc 的区别？</h2><p><strong>1） 申请内存所在的位置</strong><br>new 是 C++语言 从 <em>自由存储区</em> 为对象动态分配内存；<br>malloc 是 C语言 从 <em>堆</em> 上动态分配内存。</p>
<p><strong>2）返回类型安全性</strong><br>new操作符内存分配成功时，返回的是<em>对象类型的指针</em>，类型严格与对象匹配，无须进行类型转换，故new是符合<em>类型安全性</em>的操作符。<br>而malloc内存分配成功则是返回<em>void *  ，</em>需要通过强制类型转换将void * 指针转换成我们需要的类型。</p>
<p><strong>3）内存分配失败时的返回值</strong><br>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；<br>malloc分配内存失败时返回NULL。</p>
<p><strong>4)是否需要指定内存大小</strong><br>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算；<br>而malloc则需要显式地指出所需内存的尺寸。</p>
<p><strong>5)是否调用构造函数/析构函数</strong><br>使用new操作符来分配对象内存时会经历三个步骤：</p>
<ul>
<li>第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li>
<li>第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。</li>
<li>第三部：对象构造完成后，返回一个指向该对象的指针。</li>
</ul>
<p>使用delete操作符来释放对象内存时会经历两个步骤：</p>
<ul>
<li>第一步：调用对象的析构函数。</li>
<li>第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。</li>
</ul>
<p>总之来说，<br><strong>new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。</strong><br><strong>而malloc则不会。</strong></p>
<p><strong>6)对数组的处理</strong><br>C++提供了new[]与delete[]来专门处理数组类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A *ptr &#x3D; new A[10];&#x2F;&#x2F;分配10个对象</span><br></pre></td></tr></table></figure>

<p>使用new[]分配的内存必须使用delete[]进行释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete [] ptr;</span><br></pre></td></tr></table></figure>

<p>malloc，它并不知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。<br>所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * ptr &#x3D; (int *) malloc ( sizeof(int) * 10);&#x2F;&#x2F;分配一个10个int元素的数组</span><br></pre></td></tr></table></figure>

<p><strong>7)new 和 malloc 是否可以相互调用</strong><br>operator new /operator delete的实现可以基于malloc，<br>而malloc的实现不可以去调用new。</p>
<p><strong>8)是否可以被重载</strong><br><strong>opeartor new /operator delete可以被重载。</strong><br>标准库是定义了operator new函数和operator delete函数的8个重载版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这些版本可能抛出异常</span><br><span class="line">void * operator new(size_t);</span><br><span class="line">void * operator new[](size_t);</span><br><span class="line">void * operator delete (void * )noexcept;</span><br><span class="line">void * operator delete[](void *0）noexcept;</span><br><span class="line">&#x2F;&#x2F;这些版本承诺不抛出异常</span><br><span class="line">void * operator new(size_t ,nothrow_t&amp;) noexcept;</span><br><span class="line">void * operator new[](size_t, nothrow_t&amp; );</span><br><span class="line">void * operator delete (void *,nothrow_t&amp; )noexcept;</span><br><span class="line">void * operator delete[](void *0,nothrow_t&amp; ）noexcept;</span><br></pre></td></tr></table></figure>

<p><strong>malloc/free 并不允许重载。</strong></p>
<p><strong>9)能够直观地重新分配内存</strong><br>使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。<br>realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</p>
<p>new没有这样直观的配套设施来扩充内存</p>
<p><strong>10)客户处理内存分配不足</strong><br>在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace std</span><br><span class="line">&#123;</span><br><span class="line">    typedef void (*new_handler)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace std</span><br><span class="line">&#123;</span><br><span class="line">    new_handler set_new_handler(new_handler p ) throw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。</p>
<p>对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。</p>
<p><strong>11)属性不同</strong><br>new/delete是C++关键字，需要编译器支持。<br>malloc/free是库函数，需要头文件支持。</p>
<h2 id="8-堆和栈的区别"><a href="#8-堆和栈的区别" class="headerlink" title="8.堆和栈的区别"></a>8.堆和栈的区别</h2><p><strong>1）程序的内存分配方式不同</strong><br>堆（heap）:需要<strong>程序员自己申请</strong>，<strong>自己释放</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;C中使用malloc函数申请</span><br><span class="line">	char * p1 &#x3D; (char *)malloc(10);</span><br><span class="line">	cout &lt;&lt; (int *)p &lt;&lt; endl;	&#x2F;&#x2F;输出：00000000003BA0C0</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;使用free()释放</span><br><span class="line">	free(p1);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;C++中用new运算符申请</span><br><span class="line">	char p2 &#x3D; new char[10];</span><br><span class="line">	cout &lt;&lt; (int *)p2 &lt;&lt; endl;	&#x2F;&#x2F;输出：00000000003BA0C0</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;使用delete运算符释放</span><br><span class="line">	delete[] p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中p1所指的10字节的内存空间与p2所指的10字节内存空间都是存在于堆的。堆的内存地址生长方向与栈相反，<strong>由低到高</strong>，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，即p2指向的地址并不一定大于p1所指向的内存地址，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。堆中存储的数据的若未释放，则其生命周期等同于程序的生命周期。</p>
<p>栈（stack）：<strong>编译器自动分配释放</strong>。<br>用来存放函数的参数值，局部变量的值等，其操作方式类似于数据结构的栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int b;	&#x2F;&#x2F;栈</span><br><span class="line">	char s[] &#x3D; &quot;abc&quot;;	&#x2F;&#x2F;栈</span><br><span class="line">	char *p2;	&#x2F;&#x2F;栈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。栈的内存地址生长方向与堆相反，<strong>由高到底</strong>，所以<strong>后定义的变量地址低于先定义的变量</strong>，比如上面代码中变量s的地址小于变量b的地址，p2地址小于s的地址。栈中存储的数据的生命周期随着函数的执行完成而结束。</p>
<p><strong>2）申请后的响应时间不同</strong><br>堆：首先应该知道操作系统有一个记录内存地址的链表，当系统收到程序的申请时，遍历该链表，寻找第一个空间大于所申请的空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的 delete 或 free 语句就能够正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会将多余的那部分重新放入空闲链表中。</p>
<p>栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p><strong>3）申请的大小限制不同</strong><br>堆：堆是<strong>向高地址扩展</strong>的数据结构，是<strong>不连续的内存区域</strong>，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有<strong>效虚拟内存空间</strong>，由此空间，<strong>堆获得的空间比较灵活，也比较大</strong>。</p>
<p>栈：在 windows 下，栈是<strong>向低地址扩展</strong>的数据结构，是一块<strong>连续的内存区域</strong>，栈顶的地址和栈的最大容量是系统预先规定好的，能从<strong>栈获得的空间较小</strong>。<br>栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量。</p>
<p><strong>4）申请的效率不同</strong><br>堆：堆是有程序员自己分配，<strong>速度较慢</strong>，<strong>容易产生碎片</strong>，<strong>不过用起来方便</strong>。</p>
<p>栈：栈由系统自动分配，<strong>速度快</strong>，但是<strong>程序员无法控制</strong>。</p>
<p><strong>5）堆和栈的存储内容不同</strong><br>堆：<strong>一般是在堆的头部用一个字节存放堆的大小</strong>，而堆中具体存放内容是由程序员来填充的。</p>
<p>栈：栈存放的内容，<strong>函数返回地址</strong>、<strong>相关参数</strong>、<strong>局部变量</strong>和<strong>寄存器内容</strong>等。</p>
<h2 id="9-指针与引用的区别"><a href="#9-指针与引用的区别" class="headerlink" title="9.指针与引用的区别"></a>9.指针与引用的区别</h2><p>1）指针是一个<strong>实体</strong>，<br>   引用只是一个<strong>别名</strong>；<br>2）指针<strong>需要解引用</strong>，<br>   引用<strong>无需解引用</strong>；<br>3）引用只能在定义时被初始化一次，之后<strong>不可变</strong>，<br>   指针<strong>可变</strong>；<br>4）指针<strong>有const</strong>，const的指针不可变，<br>   引用<strong>没有const</strong>；<br>5）指针<strong>可以为空</strong>，<br>   引用<strong>不能为空</strong>；<br>6）“sizeof(引用)” 得到的是 <strong>所指向的变量（对象）的大小</strong>，<br>   而“sizeof(指针)”得到的是指针本身（所指向的变量或对象的地址）的大小；<br>7）指针和引用的自增（++）运算意义不一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用是C++中的概念，初学者容易把引用和指针混淆在一起。以下程序中，n是m的一个引用（reference），m是被引用物（referent）。</span><br></pre></td></tr></table></figure>
<p>int m;<br>int &amp;n = m;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n 相当于 m 的别名(绰号)，对 n 的任何操作就是对 m 的操作。例如，有个人叫尹小丹，他的绰号是“仙女”。说“仙女”怎么怎么样，其实就是对尹小丹说三道四。所以，n 既不是 m 的拷贝，也不是指向 m 的指针，其实 n 就是 m 他自己。</span><br></pre></td></tr></table></figure>
<p>int i = 5;<br>int j = 6;<br>int &amp;k = i;<br>k = j;    //k和i的值都变成了6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以上示例中，k 被初始化为 i 的引用。 语句 k &#x3D; j并不能将 k 修改成为 j 的引用， 只是把 k 的值改变成为 6 。由于 k 是 i 的引用，所以 i 的值也变成了 6。</span><br><span class="line"></span><br><span class="line">C++语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。</span><br><span class="line">**a)以下是“值传递”的示例程序。**</span><br></pre></td></tr></table></figure>
<p>void func1(int x)<br>{<br>    x = x + 10;<br>}<br>int n = 0;<br>func1(n);<br>cout &lt;&lt; “n = “ &lt;&lt; n &lt;&lt; endl;    //输出：n = 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于func1()函数体内的x是外部变量n的一份拷贝，改变x的值不会影响n，所以n的值仍然是0。</span><br><span class="line"></span><br><span class="line">**b)以下是“指针传递”的示例程序。**</span><br></pre></td></tr></table></figure>
<p>void func2(int <em>x)<br>{<br>    (</em>x) = (*x) + 10;<br>}<br>int n = 0;<br>func2(&amp;n);<br>cout &lt;&lt; “n = “ &lt;&lt; n &lt;&lt; endl;    //输出：n = 10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于func2()函数体内的x是指向外部变量n的指针，改变该指针的内容将导致n的值改变，所以n的值成为10.</span><br><span class="line"></span><br><span class="line">**c)以下是“引用传递”的示例程序。**</span><br></pre></td></tr></table></figure>
<p>void func3(int &amp;x)<br>{<br>    x = x + 10;<br>}<br>int n = 0;<br>func3(n);<br>cout &lt;&lt; “n = “ &lt;&lt; n &lt;&lt; endl;    //输出：n = 10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于func3()函数体内的x是外部变量n的引用，x和n是同一个东西，改变x等于改变n，所以n的值成为10.</span><br><span class="line"></span><br><span class="line">## 10.以下四行代码的区别是什么？</span><br></pre></td></tr></table></figure>
<p>const char * arr = “123”;<br>char * brr = “123”;<br>const char crr[] = “123”<br>char drr[] = “123”;</p>
<p><del>~</del><br>参考回答：<br><strong>const char * arr = “123”；</strong><br>字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果不一样。</p>
<p><strong>char * brr = “123”</strong><br>字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改“123”的值。</p>
<p><strong>const char crr[] = “123”;</strong><br>这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区。</p>
<p><strong>char drr[] = “123”；</strong><br>字符串123保存在栈区，可以通过drr去修改。</p>
<h2 id="11-C-的内存管理"><a href="#11-C-的内存管理" class="headerlink" title="11.C++的内存管理"></a>11.C++的内存管理</h2><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。<br><strong>代码段(text segment)：</strong>包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。<br><strong>数据段(data segment)：</strong>存储程序中已初始化的全局变量和静态变量。<br><strong>BBS段(bss segment)：</strong>存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。<br><strong>堆区(heap)：</strong>调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。<br><strong>映射区(memory mepping segment)：</strong>存储动态链接库以及调用mmap函数进行的文件映射。<br><strong>栈区(stack)：</strong>使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，linux可以通过ulimit命令指定。</p>
<h2 id="12-什么是内存泄漏"><a href="#12-什么是内存泄漏" class="headerlink" title="12.什么是内存泄漏"></a>12.什么是内存泄漏</h2><pre><code>内存泄漏（memory leak）是指由于疏忽或错误造成了程序未能释放掉、不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</code></pre><p><strong>内存泄漏的分类：</strong></p>
<ul>
<li><p>堆内存泄漏（heap leak）。堆内存指的是程序运行中根据需要分配通过malloc,realloc，new等堆中分配的一块内存，再是完成后必须通过调用对应的free或者delete删掉。如果程序的设计的错误导致这部分内存没有被释放掉，那么此后这块内存将不会被使用，就会产生heap leak.</p>
</li>
<li><p>系统资源泄露（resource leak）。主要指程序使用系统分配的资源比如bitmap,handle,socket等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致西戎效能降低，系统运行不稳定。</p>
</li>
<li><p>没有将基类的析构函数定义为虚函数。 当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确被释放，因此造成内存泄漏。</p>
</li>
</ul>
<h2 id="13"><a href="#13" class="headerlink" title="13."></a>13.</h2>
  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="http://dufaxing.com/" target="_blank" rel="noopener">Links</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是预编译？何时需要预编译？"><span class="toc-number">1.</span> <span class="toc-text">1.什么是预编译？何时需要预编译？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-char-const-p-char-const-p-const-char-p-这三者有什么区别？"><span class="toc-number">2.</span> <span class="toc-text">2.char * const p ; char const * p ; const char * p  这三者有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-求输出结果"><span class="toc-number">3.</span> <span class="toc-text">3. 求输出结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-请问下面的代码有什么问题"><span class="toc-number">4.</span> <span class="toc-text">4.请问下面的代码有什么问题?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-代码有何问题？"><span class="toc-number">5.</span> <span class="toc-text">5.代码有何问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-如何用C语言编写死循环？"><span class="toc-number">6.</span> <span class="toc-text">6.如何用C语言编写死循环？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-new-和-malloc-的区别？"><span class="toc-number">7.</span> <span class="toc-text">7.new 和 malloc 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-堆和栈的区别"><span class="toc-number">8.</span> <span class="toc-text">8.堆和栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-指针与引用的区别"><span class="toc-number">9.</span> <span class="toc-text">9.指针与引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-C-的内存管理"><span class="toc-number">10.</span> <span class="toc-text">11.C++的内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-什么是内存泄漏"><span class="toc-number">11.</span> <span class="toc-text">12.什么是内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13"><span class="toc-number">12.</span> <span class="toc-text">13.</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&text=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&title=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&is_video=false&description=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=软件研发面试题汇总&body=Check out this article: https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&title=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&title=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&title=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&title=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&name=软件研发面试题汇总&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://adamyandan.github.io/2019/09/21/interview/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/&t=软件研发面试题汇总" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2024 尹小丹
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="http://dufaxing.com/" target="_blank" rel="noopener">Links</a></li>
        
      </ul>
    </nav>
  </div>
</footer>
    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?2e6da3c375c8a87f5b664cea6d4cb29c";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'https-adamyandan-github-io';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/unitychan.model.json"},"display":{"position":"right","width":180,"height":360},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
