<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>补充医疗保险</title>
      <link href="/2023/08/15/%E8%A1%A5%E5%85%85%E5%8C%BB%E7%96%97%E4%BF%9D%E9%99%A9/"/>
      <url>/2023/08/15/%E8%A1%A5%E5%85%85%E5%8C%BB%E7%96%97%E4%BF%9D%E9%99%A9/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="一、药房发票要求"><a href="#一、药房发票要求" class="headerlink" title="一、药房发票要求"></a>一、药房发票要求</h2><ol><li>不能为单张发票（仅用1张发票金额为报销全额的药房发票。如1张6100/5700/5400元的药房发票）；</li><li>不能为同一药房、同一天的连号发票；</li><li>单张发票金额原则上不超过3000元、药品种类不超过8种、每种药品数量不超过10；</li><li>药品种类不能为熊胆粉、三七邓单味名贵中药材、营养保健食品、口罩、棉签类医疗器材等；</li><li>成年人不可报销小儿用药，男性不可报销女性用药，女性不可报销男性用药；</li><li>网上购药后开出的异地电子发票，需附上订单金额截图</li></ol><h2 id="二、报销流程"><a href="#二、报销流程" class="headerlink" title="二、报销流程"></a>二、报销流程</h2><ol><li>证件资料：</li></ol><ul><li>员工本人报销：员工本人身份证正反面、银行卡复印件；</li><li>员工直系亲属报销：① 成年人：员工本人身份证正反面、亲属身份证正反面、亲属银行卡复印件<br>② 未成年人（18周岁以下）：员工本人身份证正反面、员工银行卡复印件、亲属身份证正反面或户口页复印件，关系证明（户口、出生证、独子证、单位盖章的情况说明）复印件</li></ul><p><strong>银行卡：借记卡</strong>：工行、农行、中行、建行、招行、邮储、交行、民生、光大、中信、兴业、浦发、华夏、广发、平安、农村信用联合银行</p><hr>]]></content>
      
      
      <categories>
          
          <category> welfare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 补充医疗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多协议网关软件性能测试详细步骤</title>
      <link href="/2020/05/28/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/"/>
      <url>/2020/05/28/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="一、串口波特率测试"><a href="#一、串口波特率测试" class="headerlink" title="一、串口波特率测试"></a>一、串口波特率测试</h2><p><strong>测试目的：</strong>要求多协议网关能正常支持9600-115200bps串口波特率<br><strong>期望结果：</strong>多协议网关能够通过串口正常获取数据<br><strong>软件：</strong>串口调试助手sscom3.2、putty或者securecrt<br><strong>步骤：</strong></p><ol><li>sscom3.2调到9600波特率</li><li>在securecrt或者putty中输入命令：piccom –b 9600 /dev/ttyS1</li><li>在sscom3.2中的字符串输入框中输入一些内容，putty上也能显示出来<br><strong>结果：</strong><ol><li>波特率为9600：<br><img src="https://s1.ax1x.com/2020/05/28/teTRgA.png" alt="teTRgA.png"></li><li>波特率为19200：<br><img src="https://s1.ax1x.com/2020/05/28/teTOvn.png" alt="teTOvn.png"></li><li>波特率为38400：<br><img src="https://s1.ax1x.com/2020/05/28/teTxbV.png" alt="teTxbV.png"></li><li>波特率为57600：<br><img src="https://s1.ax1x.com/2020/05/28/te795F.png" alt="te795F.png"></li><li>波特率为57600：<br><img src="https://s1.ax1x.com/2020/05/28/te7PC4.png" alt="te7PC4.png"></li></ol></li></ol><h2 id="二、以太网速率测试"><a href="#二、以太网速率测试" class="headerlink" title="二、以太网速率测试"></a>二、以太网速率测试</h2><p><strong>测试目的：</strong>要求多协议网关以太网支持速率10Mbps-100Mbps<br><strong>期望结果：</strong>通过修改不同电脑网卡的属性值，测试能否ping通测试电脑；若10Mbps与100Mbps都能ping通，则以太网支持速率10Mbps-100Mbps<br><strong>软件：</strong>securecrt<br><strong>步骤：</strong></p><ol><li>以太网-&gt;属性-&gt;配置-&gt;高级-&gt;speed &amp; duplex-&gt;分别选择10 Mbps全双工和100Mbps全双工</li><li>用securecrt进入网关 ping 主机IP<br><strong>结果：</strong><ol><li>10M以太网速率：<br><img src="https://s1.ax1x.com/2020/05/28/te7wGQ.png" alt="te7wGQ.png"></li><li>100M以太网速率：<br><img src="https://s1.ax1x.com/2020/05/28/te7srq.png" alt="te7srq.png"></li></ol></li></ol><h2 id="三、支持协议类型测试"><a href="#三、支持协议类型测试" class="headerlink" title="三、支持协议类型测试"></a>三、支持协议类型测试</h2><p><strong>测试目的：</strong>要求多协议网关能正确解析IEEE802.3协议<br><strong>期望结果：</strong>测试电脑能够正常收到ping命令<br><strong>软件：</strong>securecrt、wireshark<br><strong>步骤：</strong></p><ol><li>用网关ping电脑</li><li>用wireshark抓包，可以抓到ICMP格式的报文<br><strong>结果：</strong><ol><li>执行ping命令<br><img src="https://s1.ax1x.com/2020/05/28/te7vzd.png" alt="te7vzd.png">  </li><li>Wireshark抓包图<br><img src="https://s1.ax1x.com/2020/05/28/teHCeP.png" alt="teHCeP.png"></li></ol></li></ol><h2 id="四、-支持IPv4-IPv6协议测试"><a href="#四、-支持IPv4-IPv6协议测试" class="headerlink" title="四、  支持IPv4/IPv6协议测试"></a>四、  支持IPv4/IPv6协议测试</h2><p><strong>测试目的：</strong>要求多协议网关能正确解析IPv4/IPv6协议<br><strong>期望结果：</strong>测试电脑能够正常收到ping命令和ping6命令<br><strong>步骤：</strong></p><ol><li>分别ping 电脑的IPv4和IPv6地址</li><li>通过抓包或者securecrt界面的显示均可证明。<br><strong>结果：</strong><ol><li>IPv4通信<br><img src="https://s1.ax1x.com/2020/05/28/teLtyj.png" alt="teLtyj.png"></li><li>IPv6通信<br><img src="https://s1.ax1x.com/2020/05/28/teLNOs.png" alt="teLNOs.png"></li></ol></li></ol><h2 id="五、支持SMTP协议测试"><a href="#五、支持SMTP协议测试" class="headerlink" title="五、支持SMTP协议测试"></a>五、支持SMTP协议测试</h2><p><strong>测试目的：</strong>要求被测网关能够支持SMTP协议<br><strong>期望结果：</strong>通过指定邮箱获取SMTP软件发送的邮件，指定邮箱能够获取到网关发送的邮件<br><strong>步骤：</strong></p><ol><li>配置ssmtp.conf文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; XXXXXXXX@163.com</span><br><span class="line">mailhub &#x3D; smtp.163.com</span><br><span class="line">rewriteDomain &#x3D; 163.com</span><br><span class="line">hostname &#x3D; 163.com</span><br><span class="line">FromLineOverride &#x3D; YES</span><br><span class="line">AuthUser &#x3D; XXXXXXXXXX@163.com(这两个邮箱号是一样的)</span><br><span class="line">AuthPass &#x3D; 密码</span><br></pre></td></tr></table></figure></li><li>编写 vim sendmail文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#！&#x2F;bin&#x2F;sh</span><br><span class="line">(echo &quot;From:&lt;XXX@163.com&gt;&quot;;</span><br><span class="line"> echo &quot;To:&lt;XXX@qq.com&gt;&quot;;</span><br><span class="line"> echo &quot;&quot;;</span><br><span class="line"> echo &quot;Subject:I am openwrt.com!&quot;</span><br><span class="line"> echo &quot;$1&quot;</span><br><span class="line"> echo &quot;&quot;</span><br><span class="line">  )|ssmtp -v -f &quot;openwrt.com&quot; -F &quot;www.openwrt.com&quot; XXX@qq.com</span><br></pre></td></tr></table></figure></li><li>执行<code>./sendmail</code>命令</li></ol><h2 id="六、支持HTTP协议测试"><a href="#六、支持HTTP协议测试" class="headerlink" title="六、支持HTTP协议测试"></a>六、支持HTTP协议测试</h2><p><strong>测试目的：</strong>要求被测网关能够支持HTTP协议<br><strong>期望结果：</strong>通过Wireshark软件对被测网关与测试电脑进行交互的数据包进行分析，数据包符合HTTP标准<br><strong>步骤：</strong></p><ol><li>电脑登陆luci，访问网关web界面</li><li>用wireshark软件进行抓包，可抓到HTTP格式的报文<br><strong>结果：</strong><ol><li>测试电脑访问网关web界面<br><img src="https://s1.ax1x.com/2020/05/28/teLc6J.png" alt="teLc6J.png">  </li><li>Wireshark抓包图<br><img src="https://s1.ax1x.com/2020/05/28/teLgX9.png" alt="teLgX9.png"></li></ol></li></ol><h2 id="七、支持POP3协议测试"><a href="#七、支持POP3协议测试" class="headerlink" title="七、支持POP3协议测试"></a>七、支持POP3协议测试</h2><p><strong>测试目的：</strong>要求被测网关能够支持POP3协议<br><strong>期望结果：</strong>通过POP3软件获取指定邮箱的邮件，被测网关能够获取到指定邮箱的邮件<br><strong>步骤：</strong></p><ol><li>配置fdm.conf文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">##Accounts and rules for:</span><br><span class="line">#&gt;foo@example.com</span><br><span class="line">#&gt;bar@gmail.com</span><br><span class="line">## Last edit 21-dec-09</span><br><span class="line"></span><br><span class="line">#Catch-all action(mbox):</span><br><span class="line">action “inbox” mbox “%h&#x2F;mail&#x2F;INBOX”</span><br><span class="line">#catch-all action (maildir):</span><br><span class="line">Account “XXXX”</span><br><span class="line">Pop3 server “pop.163.com”</span><br><span class="line">User XXXXX@163.com pass “XXXX”</span><br><span class="line">match all action “inbox”</span><br></pre></td></tr></table></figure></li><li>在/etc目录下，输入命令：<code>fdm –kv fetch</code><br><strong>结果：</strong><ol><li>网关接收邮件<br><img src="https://s1.ax1x.com/2020/05/28/teLH6H.png" alt="teLH6H.png"></li></ol></li></ol><h2 id="八、支持FTP协议测试"><a href="#八、支持FTP协议测试" class="headerlink" title="八、支持FTP协议测试"></a>八、支持FTP协议测试</h2><p><strong>测试目的：</strong>要求被测网关能够支持FTP协议<br><strong>期望结果：</strong>通过FTP软件测试电脑上传文件到被测网关，被测网关能够接收上传文件<br><strong>软件：</strong>WINSCP、WIRESHARK<br><strong>步骤：</strong></p><ol><li>在winscp软件中与网关连接，并上传文件</li><li>同时打开wireshark软件进行抓包</li><li>会抓取到FTP格式的报文<br><strong>结果：</strong><ol><li>FTP软件配置<br><img src="https://s1.ax1x.com/2020/05/28/teLO0I.png" alt="teLO0I.png"></li><li>Wireshark抓取FTP数据包<br><img src="https://s1.ax1x.com/2020/05/28/teLvAP.png" alt="teLvAP.png"></li></ol></li></ol><h2 id="九、WIFI标准测试"><a href="#九、WIFI标准测试" class="headerlink" title="九、WIFI标准测试"></a>九、WIFI标准测试</h2><p><strong>测试目的：</strong>要求多协议网关支持802.11标准<br><strong>期望结果：</strong>ping命令能够被正确发送并收到回复<br><strong>步骤：</strong></p><ol><li>网关开启wifi功能，电脑连接wifi</li><li>通过wireshark抓取无线网络连接数据包ICMP报文</li></ol><h2 id="十、建立连接功能测试"><a href="#十、建立连接功能测试" class="headerlink" title="十、建立连接功能测试"></a>十、建立连接功能测试</h2><p><strong>测试目的：</strong>要求测试网关支持OPC UA客户端连接<br><strong>期望结果：</strong>通过Wireshark网络封包分析到OPC UA客户端软件发出连接请求报文后，网关能够将连接请求响应报文返回给OPC UA客户端软件，并且OPC UA客户端显示与网关成功建立连接<br><strong>步骤：</strong></p><ol><li>在opc ua客户端试图连接网关时，同时打开wireshark进行抓包</li><li>可以抓到opc ua格式的报文（需筛选报文格式）（OpenSecureChannel message: OpenSecureChannelRequest）<br><strong>结果：</strong><br><img src="https://s1.ax1x.com/2020/05/28/teOyUP.png" alt="teOyUP.png"></li></ol><h2 id="十一、读功能测试"><a href="#十一、读功能测试" class="headerlink" title="十一、读功能测试"></a>十一、读功能测试</h2><p><strong>测试目的：</strong>要求测试网关支持OPC UA客户端读操作<br><strong>期望结果：</strong>通过OPC UA客户端软件向网关发起读请求，通过Wireshark网络封包分析到OPC UA客户端软件发出读请求报文后，网关能够将需要读取的信息返回给OPC UA客户端软件，并且OPC UA客户端显示读成功<br><strong>步骤：</strong></p><ol><li>UA Secure Conversation Message: ReadRequest<br><strong>结果：</strong><br><img src="https://s1.ax1x.com/2020/05/28/teOoEq.png" alt="teOoEq.png"></li></ol><h2 id="十二、写功能测试"><a href="#十二、写功能测试" class="headerlink" title="十二、写功能测试"></a>十二、写功能测试</h2><p><strong>测试目的：</strong>要求测试多协议网关支持OPC UA客户端写操作<br><strong>期望结果:</strong>通过OPC UA客户端软件向多协议网关发起写请求，通过Wireshark网络封包分析到OPC UA客户端软件发出写请求报文后，多协议网关中的值正确变化，并且OPC UA客户端显示写成功<br><strong>步骤：</strong></p><ol><li>UA Secure Conversation Message: WriteRequest<br><strong>结果：</strong><br><img src="https://s1.ax1x.com/2020/05/28/teOL2F.png" alt="teOL2F.png"></li></ol><h2 id="十三、发布-订阅功能测试"><a href="#十三、发布-订阅功能测试" class="headerlink" title="十三、发布/订阅功能测试"></a>十三、发布/订阅功能测试</h2><p><strong>测试目的：</strong>要求多协议网关支持OPC UA发布/订阅功能<br><strong>期望结果：</strong>通过OPC UA客户端软件向多协议网关发起连接请求，通过Wireshark网络封包分析到OPC UA客户端软件发出发布/订阅请求报文后，多协议网关的OPC UA服务器能够回复发布/订阅响应报文，并且OPC UA客户端显示发布/订阅关系建立成功，并且数据能够周期性更新<br><strong>步骤：</strong></p><ol><li>UA Secure Conversation Message: PublishRequest<br><strong>结果：</strong><br><img src="https://s1.ax1x.com/2020/05/28/teXkxe.png" alt="teXkxe.png"><br><img src="https://s1.ax1x.com/2020/05/28/teXnat.png" alt="teXnat.png"></li></ol><h2 id="十四、断开连接功能测试"><a href="#十四、断开连接功能测试" class="headerlink" title="十四、断开连接功能测试"></a>十四、断开连接功能测试</h2><p><strong>测试目的：</strong>要求多协议网关支持与OPC UA客户端断开连接<br><strong>期望结果:</strong>通过OPC UA客户端软件向多协议网关发起断开连接请求，通过Wireshark网络封包分析到OPC UA客户端软件发出断开请求报文后，多协议网关能够将断开连接成功结果返回给OPC UA客户端软件，并且OPC UA客户端显示与多协议网关成功断开连接<br><strong>步骤：</strong></p><ol><li>CloseSecureChannel message: CloseSecureChannelRequest<br><strong>结果：</strong><br><img src="https://s1.ax1x.com/2020/05/28/teXGrj.png" alt="teXGrj.png"></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多协议网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>展厅设备手册</title>
      <link href="/2020/05/28/%E5%B1%95%E5%8E%85%E8%AE%BE%E5%A4%87%E5%BC%80%E5%90%AF%E6%89%8B%E5%86%8C/"/>
      <url>/2020/05/28/%E5%B1%95%E5%8E%85%E8%AE%BE%E5%A4%87%E5%BC%80%E5%90%AF%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="一、OPC-UA信息共享平台"><a href="#一、OPC-UA信息共享平台" class="headerlink" title="一、OPC UA信息共享平台"></a>一、OPC UA信息共享平台</h2><ol><li>跑一个程序</li><li>跑一个客户端</li></ol><p>打开终端，依次输入如下指令：</p><ol><li>先跑一个程序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd Desktop</span><br><span class="line">$ cd New</span><br><span class="line">$ cd 3_iot</span><br><span class="line">$ cd CS</span><br><span class="line">$ .&#x2F;csadapter</span><br></pre></td></tr></table></figure></li><li>再跑一个OPC UA客户端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd Desktop</span><br><span class="line">$ cd New</span><br><span class="line">$ cd Script</span><br><span class="line">$ cd copy</span><br><span class="line">$ .&#x2F;OPC UA</span><br></pre></td></tr></table></figure></li></ol><p>地址：<code>127.0.0.1</code><br>端口号：<code>5222</code></p><h2 id="二、863节点运行系统"><a href="#二、863节点运行系统" class="headerlink" title="二、863节点运行系统"></a>二、863节点运行系统</h2><ol><li>先打开UA Export看所有网络的数据有没有上来，没有上来的话，就要一一进入各网络的网关去跑代码</li><li>“工程管理器” -&gt; database -&gt; 启动应用</li><li>左下角 “命令符”，（运行代码，将组态与个网关连接）</li><li>打开 “运行系统” 可视化界面。</li></ol><h2 id="三、各网络网关地址与端口号统计"><a href="#三、各网络网关地址与端口号统计" class="headerlink" title="三、各网络网关地址与端口号统计"></a>三、各网络网关地址与端口号统计</h2><ol><li>WIAPA:    192.168.2.99  15000</li><li>Modbus:   192.168.2.100 15000</li><li>Profibus: 192.168.2.101 16664</li><li>6tisch:   192.168.2.102 15000</li><li>6lowpan:  192.168.2.103 15000</li><li>control:                16664</li><li>meter:                  8667 </li></ol><h2 id="四、IOT实验箱展示"><a href="#四、IOT实验箱展示" class="headerlink" title="四、IOT实验箱展示"></a>四、IOT实验箱展示</h2><ol><li>连 wifi （opent-wrt）</li><li>打开文件“iot-tianzhanbei-big-141008”</li><li><code>./CISCO</code></li><li>server ip: 192.168.1.1</li><li>port: 5222</li></ol><h2 id="五、如何在linux下设置单网卡多个IP"><a href="#五、如何在linux下设置单网卡多个IP" class="headerlink" title="五、如何在linux下设置单网卡多个IP"></a>五、如何在linux下设置单网卡多个IP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig br-lan:0 XX:XX:XX:XX netmask 255.255.255.0 up</span><br><span class="line">ifconfig br-lan:1 XX:XX:XX:XX netmask 255.255.255.0 up</span><br></pre></td></tr></table></figure><p>但是后面reboot后ip地址又变回去了，必须设置启动时自动激活IP设置。<br>于是将上面的代码放入自启动文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;rc.local</span><br></pre></td></tr></table></figure><p>查路由表会发现只有br-lan口才是最后的出口。</p><h2 id="六、863组态历史数据开启"><a href="#六、863组态历史数据开启" class="headerlink" title="六、863组态历史数据开启"></a>六、863组态历史数据开启</h2><ol><li>画面管理 -&gt; 工程 -&gt; 模板 </li><li>变量 -&gt; 新建变量</li><li>实例 -&gt; 新建实例 、 实例属性，找到对应的映射关系</li><li>选中里面的图表，左边的属性下 -&gt; 曲线属性，选择线条颜色</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 展厅设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机房服务器问题手册</title>
      <link href="/2020/05/28/%E6%9C%BA%E6%88%BF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2020/05/28/%E6%9C%BA%E6%88%BF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h1 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h1><p>  机房里的服务器，在进行“思科-时天河-重邮工业互联网研究院”的项目，网线连通局域网，开4G路由器，让机房服务器连wifi进行上网。<br>  机房电脑开机密码：Cqupt123</p><h2 id="一、机房服务器连上WIFI后依旧无法上网的问题"><a href="#一、机房服务器连上WIFI后依旧无法上网的问题" class="headerlink" title="一、机房服务器连上WIFI后依旧无法上网的问题"></a>一、机房服务器连上WIFI后依旧无法上网的问题</h2><ol><li>先用4G路由器有线连接服务器</li><li>修改正确的时间，看能否上网，能，进行下一步</li><li>修改到2018年8月1日，看能否上网，能，进行下一步</li><li>能否进入 DATAFLOW ，能，进入下一步</li><li>用有线连接服务器，无线连接设备网关，进行展示。</li></ol><h2 id="二、机房EFM服务器开启命令"><a href="#二、机房EFM服务器开启命令" class="headerlink" title="二、机房EFM服务器开启命令"></a>二、机房EFM服务器开启命令</h2><p>打开终端界面，依次按如下命令开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo su</span><br><span class="line">$ source &#x2F;etc&#x2F;profile</span><br><span class="line">$ cd &#x2F;opt&#x2F;cisco&#x2F;kinetic&#x2F;efm-server&#x2F;bin</span><br><span class="line">$ .&#x2F;daemon.sh start</span><br></pre></td></tr></table></figure><h2 id="三、若机房的电脑重启了，怎么办？"><a href="#三、若机房的电脑重启了，怎么办？" class="headerlink" title="三、若机房的电脑重启了，怎么办？"></a>三、若机房的电脑重启了，怎么办？</h2><ol><li>打开ubuntu 64虚拟机<br>路径： D盘/虚拟机（英文）/ubuntu 64<br>有 cisco 这个用户名</li><li>切换到root用户（sudo su）<br>若网站 2.5：8443/dataflow.html 左边的选项是灰色的，则输入命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>然后执行EFM服务器执行命令，参照二</li><li>开启天河的端口映射（online那个）<br>若主机地址改了，则也需要相应的更改NATAPP中的IPv4地址<br>网站地址：<br>NATAPP.cn</li><li>打开  天河界面（T5制造平台）<br>账号：efmAdmin<br>密码：123456</li><li>若需要联网远程接入天河数据库界面，则需要开启NATAPP的.exe文件</li></ol><h2 id="四、相关配置"><a href="#四、相关配置" class="headerlink" title="四、相关配置"></a>四、相关配置</h2><ol><li>虚拟网络编辑器 -&gt; NAT setting -&gt; 此虚拟机IP地址：8443 -&gt; 主机端口号8443 -&gt; 确认</li><li><a href="https://192.168.2.XX/dataflow.html" target="_blank" rel="noopener">https://192.168.2.XX/dataflow.html</a> 思科kinetic平台</li></ol><h2 id="五、若想在dataflow中的DS-Link中添加OPC-UA网络"><a href="#五、若想在dataflow中的DS-Link中添加OPC-UA网络" class="headerlink" title="五、若想在dataflow中的DS Link中添加OPC UA网络"></a>五、若想在dataflow中的DS Link中添加OPC UA网络</h2><p>Alias (在upstream底下的OPC UA中）</p><ol><li>Discover tags , Add Endpoints(输入名称+URL)</li><li>在（发现中）里发现节点 <strong>[勿需手动添加]</strong></li><li>订阅 describe</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机房服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多协议网关设计方案</title>
      <link href="/2020/05/25/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/"/>
      <url>/2020/05/25/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>  在工业互联网的信息时代，现场设备需要实现互联互通，消除信息孤岛。然而，工业控制网络本身就存在通讯协议异构、接口不统一的问题，这不利于现场设备底层数据的采集和信息共享，同时对工业控制系统的网络安全提出更高的要求。因此，开发一个工业多协议安全网关已成为必然趋势。</p><p>  本工业多协议安全网关负责对不同的通信协议进行翻译，实现不同协议网络间信息包转发，简化网络管理，将有不同通信接口的传感器都连接到同一个网关上，进行分布式数据传输和控制，大大降低了设计成本，便于后期的维护。本工业多协议安全网关主要是由主控模块MT7620、协议转换模块、组态模块、WIA-PA模块和数据汇聚模块组成，可以支持FF、PROFIBUS、HART三种工业现场总线协议以及WIA-PA工业无线网络的接入，利用NCS4000组态系统、Linux平台进行开发，并且可通过OPC UA统一接口实现对数据的共享，支持读、取、写、发布/订阅功能。</p><p>  该工业多协议安全网关满足以下指标：</p><p>  (1)    网关正常支持9600-115200bps串口波特率；<br>  (2)    网关支持以太网速率10Mbps-100Mbps自适应；<br>  (3)    网关能正确解析IEEE802.3协议、IPv4/IPv6协议、SMTP、HTTP、POP3、FTP协议；<br>  (4)    网关支持报文过滤、权限管理等安全功能；<br>  (5)    网关支持802.11标准，无线传输速率达到11Mbps，发射功率在12-15 dBm范围内；<br>  (6)    网关的吞吐量可达到100Mbps；<br>  (7)    网关的包转发速率可达到250 Kbps；<br>  (8)    网关的传输时延小于50ms；<br>  (9)    网关可以并行传输处理控制和服务信息；<br>  (10)    网关的工作环境温度范围为-40℃~70℃(在电源模块70%负载时)、-40～55 ℃（在电源模块100%负载时）；<br>  (11)    网关兼容现场总线FF、PROFIBUS、HART通信协议和无线工业通信协议WIA-PA；<br>  (12)    网关支持OPC UA、Modbus统一接口，满足连接、读写、发布/订阅的功能；<br>  (13)    网关具有不同仪表接口和业务要素的统一转换接口，上行接口速率大于等于100Mbps，下行可接入点规模大于16个点。</p><h2 id="2-总体设计方案"><a href="#2-总体设计方案" class="headerlink" title="2.总体设计方案"></a>2.总体设计方案</h2><p>  本项目所研发的工业多协议安全网关包括主控模块MT7620、协议转换模块、组态模块、WIA-PA模块和数据汇聚模块。主控模块用于承载OpenWRT系统，对网关基本路由功能提供支持，协议转换模块用于将底层采集到的不同协议数据进行统一的XML描述；组态模块用于工业现场有线/无线网络子网的组网以及入网；WIA-PA模块通过无线的方式采集底层的WIA-PA网络中的数据；数据汇聚模块拥有FF网络接口、PROFIBUS网络接口和HART网络接口，用于采集底层PROFIBUS、Fieldbus和HART现场总线网络数据；工业多协议安全网关通过协议转换模块将不同协议的数据转换为统一的XML格式，再使用有线网络或者无线网络将统一后的数据通过统一的网络接口（OPC UA或者Modbus TCP）传输至局域网或广域网。该工业多协议安全网关集无线/有线数据采集、网络组态、协议转换等功能为一体，支持底层有线/无线网络、局域网或广域网网络之间的互联互通，并通过OPC UA技术和Modbus TCP数据通信协议实现设备管理与数据传输的无缝衔接。工业多协议安全网关的总体设计如下图所示。<br><a href="https://imgchr.com/i/t9728S" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9728S.png" alt="t9728S.png"></a></p><h2 id="3-主要模块设计"><a href="#3-主要模块设计" class="headerlink" title="3.主要模块设计"></a>3.主要模块设计</h2><h3 id="3-1-主控模块"><a href="#3-1-主控模块" class="headerlink" title="3.1 主控模块"></a>3.1 主控模块</h3><p>  工业多协议安全网关的主控模块包括MT7620主控制单元、无线模块单元、电源管理单元、以太网控制单元、串口转USB调试单元等。网关设计了三个UART接口、一个网口、一个GPIO口；其中UART0作为普通串口与无线模块交互数据，UART1作为调试串口。工业现场总线模块则通过UART2串口与主控模块进行数据交互。工业多协议安全网关的主控模块结构图如下图所示。<br><a href="https://imgchr.com/i/t97jKJ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t97jKJ.png" alt="t97jKJ.png"></a><br>  工业多协议安全网关主控模块使用OpenWRT系统。该系统针对网络路由功能的需要，在嵌入式Linux系统的基础上进行优化，不仅能够很好地支持各种处理器架构，还能够支持IPv4/IPv6网络的路由转发功能。同时，该系统作为开源嵌入式Linux系统，能够对STMP、POP3、HTTP、FTP等协议提供支持。主控模块能够读取现场总线设备、WIA-PA设备的数据，并提供OPC UA、Modbus统一接口。</p><h3 id="3-2-数据汇聚模块"><a href="#3-2-数据汇聚模块" class="headerlink" title="3.2 数据汇聚模块"></a>3.2 数据汇聚模块</h3><p>  现场总线控制系统是一种开放式、安全性好、成本低、新型的分布控制系统，以控制、计算机、数字通讯等技术为主要内容的综合技术，成为自动化技术发展热点，并将导致自动化系统结构与设备的深刻变革。工业多协议安全网关现场总线模块包括FF数据汇聚模块、HART数据汇聚模块、PROFIBUS数据汇聚模块，能够读取现场总线的各种信息和实时数据，同时提供了8个FF端子、4个PROFIBUS接口和8个HART通道，能够连接大量的现场总线设备。</p><p>  3.2.1 FF数据汇聚模块<br>  NCS40000控制系统可以访问FF数据汇聚模块，该模块可以与符合FF H1标准的各种仪表和设备连接，控制站可以通过 NCS4000-FFH1-0201 模块对 H1 仪表和设备进行组态、监视、诊断、维护等功能。具有热插拔、故障和状态指示等功能。</p><p>  该模块的主要特点如下：</p><ul><li><p>通道至系统隔离 </p></li><li><p>总线供电 </p></li><li><p>电流调制方式 </p></li><li><p>通过 FF 协议物理层一致性测试</p><p>目前该模块支持两个H1接口，可以连接两个H1网段，在网段上作为LAS运行。FF数据汇聚模块端子接线如下图所示，其中CH1和CH2表示不同的H1网段，每个网段可以接入四个设备。底层FF设备通过工业多协议安全网关的FF模块接入网络，同时将数据通过该模块传输至主控模块进行下一步传输与处理。<br><a href="https://imgchr.com/i/t9HEKH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9HEKH.png" alt="t9HEKH.png"></a></p></li></ul><p>  3.2.2 HART数据汇聚模块<br>  HART数据汇聚模块是一个具有8个通道的HART通讯模块，可以检测来自HART现场设备的电流输入和HART信号，具有热插拔、故障和状态指示等功能。通过组态软件对该模块进行通道配置，模块能够读取现场设备的实时数据。</p><p>  该模块的主要特点如下：</p><ul><li><p>通道至系统隔离</p></li><li><p>支持0～20mA，4～20mA量程的电流输入信号，每通道支持一个HART变送器</p></li><li><p>支持2、4线制变送器</p></li><li><p>2线制接线方式具有输入开路、短路检测功能</p></li><li><p>支持HART变送器的多变量读取</p><p>HART数据汇聚模块端子接线如下图所示，其中CH1-CH8分别表示8个不同的HART通道，可接入8个设备，用户可通过NCS4000组态控制系统对每个通道进行配置以及开启与关闭。<br><a href="https://imgchr.com/i/t9HJqs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9HJqs.png" alt="t9HJqs.png"></a></p></li></ul><p>  3.2.3 PROFIBUS数据汇聚模块<br>  符合PROFIBUS协议标准的设备通过工业多协议安全网关的PROFIBUS数据汇聚模块接入网络，同时将数据通过该模块传输至主控模块进行下一步传输与处理。该模块提供4个接口端子，可一次接入4个PROFIBUS-DP/PROFIBUS-PA设备，底层设备通过组态模块（NCS-4000）获得唯一的地址，PROFIBUS数据汇聚模块通过每个设备的唯一地址对底层设备管理、读取/发送数据，以此保证数据的准确性，该模块还具有热插拔、故障和状态指示等功能。</p><p>  该模块的主要特点如下：</p><ul><li><p>通道至系统隔离</p></li><li><p>支持PROFIBUS 协议中的DP-V1 协议</p></li><li><p>每个PROFIBUS主站可连接125 个从站</p></li><li><p>一个控制器最多可带2 个PROFIBUS 主站模块<br><a href="https://imgchr.com/i/t9HdiV" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9HdiV.png" alt="t9HdiV.png"></a></p><p>PROFIBUS主站模块端子接线如上图所示，该模块拥有4个PROFIBUS-DP设备接口（A-, B+和G），接入DP分线器后可同时管理多个PROFIBUS-DP设备。接入DP/PA耦合器后，该模块则可以管理PROFIBUS-PA设备。CNTR端子代表着一个可逆计数器，VP端子表示正向电极，PE则是保护导体端子，为该模块提供安全保证。</p></li></ul><h3 id="3-3-NCS4000组态模块"><a href="#3-3-NCS4000组态模块" class="headerlink" title="3.3 NCS4000组态模块"></a>3.3 NCS4000组态模块</h3><p>  工业多协议安全网关提供NCS4000组态功能，NCS4000控制系统是全分布式的现场总线控制系统，适用于中、大规模工业控制环境，提供过程控制、逻辑控制功能，可以广泛应用于冶金、水泥焦化污处理、石油、化工等行业。通过NCS4000组态模块能够对FF、HART、PROFIBUS等现场总线设备进行参数配置和数据读取。</p><p>  NCS4000控制系统具有如下特点： </p><ul><li>支持 FF、HART、MODBUS、PROFIBUS多种现场总线标准；</li><li>支持设备管理、诊断与维护功能； </li><li>支持分布式组态、离线仿真等多种功能；</li><li>支持 IEC61131-3编程标准； </li><li>开放的数据访问接口。</li></ul><h3 id="3-4-WIA-PA数据前端模块"><a href="#3-4-WIA-PA数据前端模块" class="headerlink" title="3.4 WIA-PA数据前端模块"></a>3.4 WIA-PA数据前端模块</h3><p>  WIA-PA数据前端模块在WIA-PA网络中以WIA-PA网关的角色出现，完成整个网络的组网与管理以及数据传输功能。转换模块实现WIA-PA网络及其设备接入以IPv6协议为寻址方法和以OPC UA协议为传输方法的网络转换。具体方法是在模块中将WIA-PA的用户应用对象转换为遵循XML描述格式；在应用子层，将WIA-PA的Client-Server、Publisher-Subscriber和Report-Sink通信模式转换为OPC UA协议中对应的传输方式；在网络层，将WIA-PA的网内地址映射为标准的IPv6地址，使WIA-PA网络的每个设备都有一个虚拟的IPv6地址，外部网络可通过IPv6地址对WIA-PA设备进行寻址。<br><a href="https://imgchr.com/i/t9b3Y6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9b3Y6.png" alt="t9b3Y6.png"></a></p><h3 id="3-5-协议转换模块"><a href="#3-5-协议转换模块" class="headerlink" title="3.5 协议转换模块"></a>3.5 协议转换模块</h3><p>  工业多协议安全网关提供了协议转换功能，将设备地址转换为标准的IPv6地址，将网络内部的信息数据转换为XML格式。同时，网关利用XML对网络内的设备进行描述，并使用统一的IP协议经过边界网关，将设备描述信息、数据信息、管理信息等XML 信息传输至上层应用。在这种架构下，虽然现场网络的设备并不能直接支持XML和IP，但借助于多协议网关的转换功能，每个现场设备仍具有单独的IP 地址，并通过XML与后台进行数据信息和管理信息交互。通过该模块，能够将工业现场总线及工业无线网络的数据转换成XML格式，建立以XML为核心的信息描述与数据交换机制，最后将工业网络数据通过OPC UA统一转换接口对外提供服务。</p><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多协议网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多协议网关外部接线端口说明</title>
      <link href="/2020/05/25/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3%E5%A4%96%E9%83%A8%E6%8E%A5%E7%BA%BF%E7%AB%AF%E5%8F%A3%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/05/25/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3%E5%A4%96%E9%83%A8%E6%8E%A5%E7%BA%BF%E7%AB%AF%E5%8F%A3%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>多协议边界网关包含FF、HART、DP共3种现场总线模块，通过以太网连接电脑上位机，可以对FF、HART、DP设备进行配置、组态等操作。<br>多协议边界网关整体如下图所示。</p><p><a href="https://imgchr.com/i/t94u5D" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t94u5D.png" alt="t94u5D.png"></a></p><h2 id="二、接口描述"><a href="#二、接口描述" class="headerlink" title="二、接口描述"></a>二、接口描述</h2><ol><li><p>下侧接口<br><a href="https://imgchr.com/i/t94Tqx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t94Tqx.png" alt="t94Tqx.png"></a></p></li><li><p>上侧接口<br><a href="https://imgchr.com/i/t94HZ6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t94HZ6.png" alt="t94HZ6.png"></a></p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多协议网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NCS400展厅组态安装软件（路径需要用英文）</title>
      <link href="/2020/05/25/NCS400%E5%B1%95%E5%8E%85%E7%BB%84%E6%80%81%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%EF%BC%88%E8%B7%AF%E5%BE%84%E9%9C%80%E8%A6%81%E7%94%A8%E8%8B%B1%E6%96%87%EF%BC%89/"/>
      <url>/2020/05/25/NCS400%E5%B1%95%E5%8E%85%E7%BB%84%E6%80%81%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%EF%BC%88%E8%B7%AF%E5%BE%84%E9%9C%80%E8%A6%81%E7%94%A8%E8%8B%B1%E6%96%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="一、安装环境及注意事项"><a href="#一、安装环境及注意事项" class="headerlink" title="一、安装环境及注意事项"></a>一、安装环境及注意事项</h2><ol><li><p>（ win 7 旗舰版 + office 2007 ） 或 （ win 10 专业版 + office 2007 ）</p></li><li><p>安装路径都要为<strong>英文</strong></p></li><li><p>所有的软件都要<strong>以管理员身份运行</strong></p></li></ol><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li><p>先安装 “SQLServer 2008 R2 Express” 里的文件 “SQLEXPR_x86_CHS”<br>其中，将  “账户设置” 改为 <strong>“SYSTEM”</strong></p></li><li><p>执行 “MCView_2.3.0.exe”<br>在执行过程中如果遇到问题， 先执行 “vcredistx64.exe” , win 7系统可能没有一个插件，需要手动安装 “dotNetFx40_Full_x86_x64.exe” </p></li><li><p>执行 “NCSView_v2.4.4_For_UA.exe”<br>到 “工程管理器” 工程中 打开 “test_863.mvsp”（或其他工程项目）</p></li></ol><h2 id="安装完后，退出。并按照实验室祖传的打开方式，进行测试验证。"><a href="#安装完后，退出。并按照实验室祖传的打开方式，进行测试验证。" class="headerlink" title="安装完后，退出。并按照实验室祖传的打开方式，进行测试验证。"></a>安装完后，退出。并按照实验室祖传的打开方式，进行测试验证。</h2><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NCS4000组态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020重邮研究生经费报销流程</title>
      <link href="/2020/05/25/2020%E9%87%8D%E9%82%AE%E7%A0%94%E7%A9%B6%E7%94%9F%E7%BB%8F%E8%B4%B9%E6%8A%A5%E9%94%80%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/05/25/2020%E9%87%8D%E9%82%AE%E7%A0%94%E7%A9%B6%E7%94%9F%E7%BB%8F%E8%B4%B9%E6%8A%A5%E9%94%80%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="一、纸张按以下顺序排列："><a href="#一、纸张按以下顺序排列：" class="headerlink" title="一、纸张按以下顺序排列："></a>一、纸张按以下顺序排列：</h2><ol><li>投递式报销专用封面</li><li>投递式报账票据汇总表</li><li>票据报销审批单</li><li>打印的发票（发票如果直接用A4纸打印出来的话，就不需要粘贴到“票据粘贴单”中）</li><li>票据粘贴单（如果有发票的话，需要粘到这张纸上面）（话费、图书、论文查重费都可以）</li></ol><h2 id="二、需要准备的材料，以及填写的内容、步骤"><a href="#二、需要准备的材料，以及填写的内容、步骤" class="headerlink" title="二、需要准备的材料，以及填写的内容、步骤"></a>二、需要准备的材料，以及填写的内容、步骤</h2><ol><li><p>投递式报销封面<br><a href="https://imgchr.com/i/t9G6Mt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9G6Mt.jpg" alt="t9G6Mt.jpg"></a></p></li><li><p>票据汇总表<br><a href="https://imgchr.com/i/t9JeWd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9JeWd.jpg" alt="t9JeWd.jpg"></a></p></li><li><p>报销审批单<br><a href="https://imgchr.com/i/t9JJYQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9JJYQ.jpg" alt="t9JJYQ.jpg"></a></p></li><li><p>在每一张发票上写上：</p></li></ol><p> <strong>本人承诺此发票为重复报销，真实有效（姓名，日期）</strong></p><ol start="5"><li><p>导师签字</p></li><li><p>辅导员签字、备案</p></li><li><p>院长签字</p></li><li><p>学院盖章</p></li><li><p>去财务处投递</p></li></ol><h2 id="三、凑发票小技巧"><a href="#三、凑发票小技巧" class="headerlink" title="三、凑发票小技巧"></a>三、凑发票小技巧</h2><ol><li><p>联通的话费电子发票可以改抬头，使用联通的<strong>手机营业厅</strong>APP，可以推送电子发票<strong>（但有限额）</strong></p></li><li><p>话费、书籍发票上的姓名需要写自己的名字</p></li><li><p><strong>发票不要超过200元</strong>，若超过一定的面额，需要附上以下说明：<br><a href="https://imgchr.com/i/t9Yw3d" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9Yw3d.jpg" alt="t9Yw3d.jpg"></a></p></li><li><p>发票一定要贴好，全方位无死角贴满！</p></li></ol><h2 id="其余形式的报销，在下就没有总结了，抱歉。"><a href="#其余形式的报销，在下就没有总结了，抱歉。" class="headerlink" title="其余形式的报销，在下就没有总结了，抱歉。"></a>其余形式的报销，在下就没有总结了，抱歉。</h2><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经费报销 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多协议网关NCS4000控制器操作指南</title>
      <link href="/2020/01/14/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3NCS4000%E6%8E%A7%E5%88%B6%E5%99%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
      <url>/2020/01/14/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3NCS4000%E6%8E%A7%E5%88%B6%E5%99%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,laboratory --><h2 id="安装NCS4000Setup-exe"><a href="#安装NCS4000Setup-exe" class="headerlink" title="安装NCS4000Setup.exe"></a>安装NCS4000Setup.exe</h2><pre><code>把“NCS4000Setup.exe”软件装在C盘里一直按“下一步”即可。一般存储路径：C：/Program Files(x86)/CQUPT/NCS4000/</code></pre><h2 id="1-建立数据库与设备连接"><a href="#1-建立数据库与设备连接" class="headerlink" title="1.建立数据库与设备连接"></a>1.建立数据库与设备连接</h2><p>1）打开“系统信息数据库管理”<br><img src="https://s2.ax1x.com/2020/01/14/lbv2G9.png" alt="lbv2G9.png"><br>新建数据库，设置名字和保存路径<br>创建新数据库成功后，管理工具会询问是否将新建数据库设为激活，点击“是”。</p><p>然后可以点那个<br><img src="https://s2.ax1x.com/2020/01/14/lbv4r6.png" alt="lbv4r6.png"><br>之后就会启动了</p><p>2）打开“系统诊断工具”<br><img src="https://s2.ax1x.com/2020/01/14/lbv5qK.png" alt="lbv5qK.png"></p><p>3）打开 “资源管理器”<br>若这里初始化失败<br><img src="https://s2.ax1x.com/2020/01/14/lbvjMt.png" alt="lbvjMt.png"><br>安装的位置，删掉原来的ios_ip_setting.ini 文件<br>将ios_ip_setting.ini.tmpl 文件改为ios_ip_setting.ini<br>用记事本打开这个刚改完名字的文件，在这里：<br><img src="https://s2.ax1x.com/2020/01/14/lbxkzn.png" alt="lbxkzn.png"><br>将这里的IP Address改为 本计算机的IP地址。在192.168.2.XXX网段。</p><p>4）又打开“系统诊断工具”<br><img src="https://s2.ax1x.com/2020/01/14/lbxZLV.png" alt="lbxZLV.png"><br>先按“停止”，后按“启动”<br>点“更新”<br><strong>需要等待一段时间</strong>，才能显示黄色里的设备信息<br>关掉这个“系统诊断工具”。</p><p>5） “资源管理器”里的东西，一切正常了<br><img src="https://s2.ax1x.com/2020/01/14/lbxndU.png" alt="lbxndU.png"></p><h2 id="2-使用已有得数据库"><a href="#2-使用已有得数据库" class="headerlink" title="2.使用已有得数据库"></a>2.使用已有得数据库</h2><p>1）启动“系统信息数据库管理”（一般会保留上次用过的数据库）<br><img src="https://s2.ax1x.com/2020/01/14/lbx1zR.png" alt="lbx1zR.png"></p><p>2）双击“设置激活数据库”</p><p>3）选择你的数据库（可以为中文名字）<br><img src="https://s2.ax1x.com/2020/01/14/lbxJL6.png" alt="lbxJL6.png"></p><p>4）选中后，按“确定，然后点击绿色的那个按钮。运行数据库就行了</p><p>5）之后就是“资源管理器”中的配置了</p><h2 id="3-资源管理器的使用"><a href="#3-资源管理器的使用" class="headerlink" title="3.资源管理器的使用"></a>3.资源管理器的使用</h2><p>1）运行“资源管理器”</p><p>2）选择“物理网络”，在右侧窗口可以看到在线物理控制器信息<br><img src="https://s2.ax1x.com/2020/01/14/lbxNdO.png" alt="lbxNdO.png"></p><p>3）设计控制策略结构<br>    1.右键选择“系统组态配置信息-&gt;控制策略”节点<br>        选择“新建区域”命令<br>        <img src="https://s2.ax1x.com/2020/01/14/lbxrQI.png" alt="lbxrQI.png"><br>        在“控制策略”节点下会自动添加一个区域对象子节点“区域1”<br>        <img src="https://s2.ax1x.com/2020/01/14/lbx5Ss.png" alt="lbx5Ss.png"><br>    2.右键选择刚刚创建的“区域1”节点<br>        选择“新建模块”命令，添加一个“功能块图”<br>        <img src="https://s2.ax1x.com/2020/01/14/lbxzlR.png" alt="lbxzlR.png"><br>    3.同样地方法，添加一个“梯形图”<br>        <img src="https://s2.ax1x.com/2020/01/14/lbzM0f.png" alt="lbzM0f.png"><br>        <img src="https://s2.ax1x.com/2020/01/14/lbz3tg.png" alt="lbz3tg.png"></p><p>4） 编辑功能块图模块<br>右键选择“系统组态配置信息-&gt;控制策略-&gt;区域1-&gt;Fbd1”<br>选择“编辑-&gt;使用组态软件离线编辑”</p><p>5）添加功能块对象<br>    1. 在控制策略开发环境的模板视图中，选中“功能块库-&gt;输入/输出-&gt;DI”节点<br>    2. “拖拽”至左边的编辑视图中<br>    3. 放“DO”节点<br><img src="https://s2.ax1x.com/2020/01/14/lqSPvn.png" alt="lqSPvn.png"><br>    4. 在模块视图中，右键选择“Fbd1”节点。<br>        选择“添加参数”命令<br>        <img src="https://s2.ax1x.com/2020/01/14/lqS3b6.png" alt="lqS3b6.png"><br>    5. 在属性视图中，将参数对象“Param_1”的对象名称修改为“In1”、参数类型修改为“输入”<br>        <img src="https://s2.ax1x.com/2020/01/14/lqSdxA.png" alt="lqSdxA.png"><br>    6. 使用同样方法，再添加一个对象名称为“Out1”、参数类型修改为“输出”<br>    7. 在“模块视图”和“编辑窗口”都删掉“DI_1”<br>    8. 左边的参数都拖出去，确定连接关系<br>    <img src="https://s2.ax1x.com/2020/01/14/lqSTaT.png" alt="lqSTaT.png"><br>    在模块视图中，右键选择“Fbd1”节点，在弹出的快捷菜单中，选择“有效性检查”命令；<br>    在输出视图中，应显示相关的成功信息。<br>    <img src="https://s2.ax1x.com/2020/01/14/lqSqG4.png" alt="lqSqG4.png"><br>    9.保存，退出。</p><p>6）编辑梯形图模块<br>    1.使用工具条的“添加网络”命令，添加两个网络对象，网络标识分别为“000001”和“000002”<br>    <img src="https://s2.ax1x.com/2020/01/14/lqppdK.png" alt="lqppdK.png"><br>    <img src="https://s2.ax1x.com/2020/01/14/lqpPiD.png" alt="lqpPiD.png"><br>    2. 哎呀，具体的看操作手册 P40页，别人讲很详细了，不想写了。。。。</p><h2 id="4-中途添加设备（在已有的数据库基础上）"><a href="#4-中途添加设备（在已有的数据库基础上）" class="headerlink" title="4.中途添加设备（在已有的数据库基础上）"></a>4.中途添加设备（在已有的数据库基础上）</h2><p>增加 “Modbus从站设置”，对应网络的 “数据项个数”、修改“起始地址”和“读写数量”；<br>去相应的网络下，增加“IO节点”；</p><ul><li><p><strong>增加FF设备</strong></p><p>  1）打开“资源管理器”<br>  2）右键“FF设备库”、“导入FF设备”；<br>  3）在“H1网段”下，“新建H1设备”；<br>  4）选择“物理设备”，将显示的设备拖到新建的设备下，进行映射（模块会自动识别所连接的FF设备）<br>  5）在“FF控制策略”模块下，右键“组态离线编辑”，点击空白地方，左边的“属性”选择“H1网段”；<br>  6）在右边出现的“17-AI7001”拖到空白处即出现“AI_2.”选择参数并拖出，连线；<br>  7）将参数加入Modbus。</p></li><li><p><strong>增添HART设备</strong></p><p>  1）在“控制网络”、“I/O模块列表”、“IO模块4”、“HART”中添加“IO节点”<br>  <img src="https://s2.ax1x.com/2020/01/14/lqpWFO.png" alt="lqpWFO.png"> </p><p>  <img src="https://s2.ax1x.com/2020/01/14/lqpo6A.png" alt="lqpo6A.png"><br>  2）使用“组态软件离线编辑”，增加<br>  <img src="https://s2.ax1x.com/2020/01/14/lqpOk8.png" alt="lqpOk8.png"></p></li><li><p><strong>增添PROFIBUS设备</strong></p><p>  我忘记啦==5555555</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多协议网关 </tag>
            
            <tag> NCS4000 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cheat software安装方法和注意事项</title>
      <link href="/2020/01/14/809%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%85%B6%E4%BB%96%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/01/14/809%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%85%B6%E4%BB%96%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="准备工具："><a href="#准备工具：" class="headerlink" title="准备工具："></a>准备工具：</h2><ul><li>Everything（搜索软件）</li><li>Greenshot （截屏软件）<br><img src="https://s2.ax1x.com/2020/01/14/lb6xHO.png" alt="lb6xHO.png"><br>(前提是必须有公网！！才能远程！！！)<br>（或者是在同一个局域网下）</li></ul><p><strong>总而言之，别人ping得通你的电脑！</strong></p><h2 id="安装注意事项"><a href="#安装注意事项" class="headerlink" title="安装注意事项"></a>安装注意事项</h2><p><strong>1、Everything搜索软件</strong><br><img src="https://s2.ax1x.com/2020/01/14/lbcFgI.jpg" alt="lbcFgI.jpg"><br>搜索软件安装时在该页面选择“简体中文”，其他操作只需下一步即可，安装位置可自定义。</p><p><strong>2、截图软件</strong><br><img src="https://s2.ax1x.com/2020/01/14/lbcnUg.png" alt="lbcnUg.png"><br>截屏软件安装过程中当遇到该页面时，将滚动条下滑选择“简体中文”，其他操作只需下一步即可，安装位置可自定义。</p><h2 id="设置注意事项"><a href="#设置注意事项" class="headerlink" title="设置注意事项"></a>设置注意事项</h2><p><strong>1、搜索软件</strong><br>打开Everything——&gt;工具——&gt;选项——&gt;HTTP（左边选项栏中的最后一个）——&gt;启用HTTP服务器前打钩——&gt;HTTP服务器端口设置<strong>（该数值一定要大于1024）</strong>——&gt;应用——&gt;确定<br>（操作完成）</p><p><strong>2、截屏软件</strong></p><p>找到截屏软件图标（一般都在电脑右下方处），鼠标放在该图标上右键对其进行基本设置</p><p><em>常规</em></p><p>鼠标右键——&gt;设置（可能有人会遇到打开是英文，别慌，进行设置即可为中文，）——&gt;<br>    常规——&gt;语言部分选择“简体中文”<br>    常规——&gt;热键（可以设置快捷键，方便自己后期操作，我用的是默认设置值F1）<br><img src="https://s2.ax1x.com/2020/01/14/lbgAJJ.png" alt="lbgAJJ.png"></p><p><em>抓图</em><br><img src="https://s2.ax1x.com/2020/01/14/lbgeQ1.png" alt="lbgeQ1.png"><br>检查一下“显示通知”选项前是否有勾勾，如果没有就跳过这页，如果有就取消该勾勾。</p><p><em>输出</em><br>对“保存路径”处进行设置，设置自己后面想保存截图的位置。（最好找个显眼的地方，好方便别人找到）<br><img src="https://s2.ax1x.com/2020/01/14/lbgNOP.png" alt="lbgNOP.png"></p><p><em>抓图后的动作</em><br>选择“直接保存”即可。<br><img src="https://s2.ax1x.com/2020/01/14/lbgDYQ.png" alt="lbgDYQ.png"></p><h2 id="最后将你的地址发给别人"><a href="#最后将你的地址发给别人" class="headerlink" title="最后将你的地址发给别人"></a>最后将你的地址发给别人</h2><p>地址书写形式=<strong>外网IP地址:端口号</strong><br>（这里的端口号就是搜索软件中设置的HTTP端口号，这里的冒号必须是英文的哦，否则就是错误地址。）</p><p><em>外网IP在这里获取</em><br><img src="https://s2.ax1x.com/2020/01/14/lbgTp9.png" alt="lbgTp9.png"><br>点击进入后——“详细信息”</p><p><img src="https://s2.ax1x.com/2020/01/14/lbgbOx.png" alt="lbgbOx.png"><br>获取该IP地址即可<br><img src="https://s2.ax1x.com/2020/01/14/lbv1Df.png" alt="lbv1Df.png"></p><p>!!!!如果你怕别人访问你的电脑，你可以在使用外之后将HTTP端口关闭，或者每次填写不同的端口。</p><hr>]]></content>
      
      
      <categories>
          
          <category> acrobatics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cheat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天河可视化应用程序在应用层部署操作说明</title>
      <link href="/2020/01/14/%E5%A4%A9%E6%B2%B3%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%BA%94%E7%94%A8%E5%B1%82%E9%83%A8%E7%BD%B2%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/01/14/%E5%A4%A9%E6%B2%B3%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%BA%94%E7%94%A8%E5%B1%82%E9%83%A8%E7%BD%B2%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="1-部署方式"><a href="#1-部署方式" class="headerlink" title="1.部署方式"></a>1.部署方式</h2><p>1）应用程序采用Tomcat方式进行部署，目前配置的端口号为8080，可修改。<br>修改的方式为：在tomcat 文件中找conf文件夹中的server.xml，修改 &lt;Connector port=”8080”中port值。<br><img src="https://s2.ax1x.com/2020/01/14/lbyzfs.png" alt="lbyzfs.png"></p><p>例如：<Connector port="8080" protocol="HTTP/1.1"               connectionTimeout="20000"               redirectPort="8443" /></p><p>2）服务器重启或配置信息更改之后，需手动重启一下服务startup.bat，关闭服务为shutdown.bat。<br><img src="https://s2.ax1x.com/2020/01/14/lb6C60.png" alt="lb6C60.png"></p><p>3）应用程序文件存放于服务器D：/thsoft 下。</p><h2 id="2-登陆访问"><a href="#2-登陆访问" class="headerlink" title="2.登陆访问"></a>2.登陆访问</h2><p>1）目前局域网访问的地址链接为：<a href="http://192.168.2.3:8080/thsoft-website" target="_blank" rel="noopener">http://192.168.2.3:8080/thsoft-website</a><br>用户名：admin<br>密码：admin</p><p>2）如需外网访问需将服务器IP地址进行映射。</p><h2 id="3-程序内容"><a href="#3-程序内容" class="headerlink" title="3.程序内容"></a>3.程序内容</h2><p>应用程序主要包含的内容有三部分：中央监控大厅、现场状态监控和现场看板。</p><p>1）中央监控大厅<br>通过车间产线模拟每个设备的运行场景，根据采集的数据动态判断每个设备当前的状态和采集值。每两秒刷新一次数据。<br><img src="https://s2.ax1x.com/2020/01/14/lb6A7F.png" alt="lb6A7F.png"></p><p>2）现场状态监控<br>根据采集的数据实时监控设备的运行状态，灰色图标表示“停机”，绿色图标表示“正常”，红色图标表示“报修”。<br><img src="https://s2.ax1x.com/2020/01/14/lb6Vk4.png" alt="lb6Vk4.png"></p><p>3）现场看板<br>系统将采集的数据分类汇总以统计图的形式展示出来，供决策分析。<br><img src="https://s2.ax1x.com/2020/01/14/lb6eh9.png" alt="lb6eh9.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> T5制造平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>S323实验室IoT防BUG反玄学手册</title>
      <link href="/2020/01/14/%E5%AE%9E%E9%AA%8C%E5%AE%A4IOT%E7%A0%94%E5%8F%91%E5%B9%B3%E5%8F%B0%E9%98%B2BUG%E6%89%8B%E5%86%8C/"/>
      <url>/2020/01/14/%E5%AE%9E%E9%AA%8C%E5%AE%A4IOT%E7%A0%94%E5%8F%91%E5%B9%B3%E5%8F%B0%E9%98%B2BUG%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h2><p>iot系统一共两套，中央馆为iot-1系统，经开区为iot-2系统。</p><p>电脑：iot-1使用一体机，iot-2需要自带笔记本。<br>虚拟机：“ubuntu 12.04 copy”，自带笔记本需要拷贝过去。<br>芯片：iot-1芯片完全正常，iot-2有一定概率出现无法识别bug。<br>节点：节点数量较多时，可能不会全部上线。开个四五个就可以了，不能上的就关掉。<br>激活芯片1个：可以被系统稳定识别出ttyACM0。</p><h2 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h2><ol><li>将芯片插在路由器usb口中，启动路由器。</li><li>启动主机，连接wifi。Iot-1 wifi名称为openwrt，iot-2wifi名称为openwrt111。</li><li>打开虚拟机“ubuntu 12.04 copy”，进入桌面。</li><li>使用一体机的话，进入IoT-tiaozhanbei-big-140008，使用笔记本的话，进入IoT-tiaozhanbei-140008，两者区别在于界面的显示大小。</li><li>打开CISCO图标，连接192.168.1.1，端口号5222，点击连接。</li></ol><h2 id="3-BUG解决方案"><a href="#3-BUG解决方案" class="headerlink" title="3.BUG解决方案"></a>3.BUG解决方案</h2><p>Q1：界面连接不上。</p><p>A: 最大的可能是系统没有识别ttyACM0。解决方法是：使用一个有ttyACM0的协调器芯片插入路由器，重启路由器，等到路由完全启动后，拔出协调器芯片，换上iot-1或iot-2芯片，重启路由器，这时候一般都可以正常连接了。</p><p>如上述操作反复试验无效，则可能是路由器无法有效识别ttyACM0的原因。此时将芯片直插电脑，进入linux shell，输入以下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;Desktop&#x2F;src</span><br><span class="line">sudo .&#x2F;iot-deamon –s &#x2F;dev&#x2F;ttyACM0 aaaa::1&#x2F;64</span><br></pre></td></tr></table></figure><p>如果守护程序启动正常，则可以再连接界面。</p><p>Q2: 界面能连接上，但是topology一片空白。</p><p>A: 你一定没有使用ubuntu 12.04 copy虚拟机。</p><p>最后如果还不行，<strong>玄学。</strong></p><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H3C路由器配置方法</title>
      <link href="/2020/01/14/H3C%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
      <url>/2020/01/14/H3C%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="1-1-NAT-PT简介"><a href="#1-1-NAT-PT简介" class="headerlink" title="1.1 NAT-PT简介"></a>1.1 NAT-PT简介</h2><h3 id="1-1-1-NAT-PT应用场景"><a href="#1-1-1-NAT-PT应用场景" class="headerlink" title="1.1.1 NAT-PT应用场景"></a>1.1.1 NAT-PT应用场景</h3><p>IPv6的应用是个循序渐进的过程，在很长时间内，IPv4网络和IPv6网络会同时存在且需要相互通信。在IPv4网络完全过渡到IPv6网络之前，两个网络之间直接的通信可以通过NAT-PT（Network Address Translation-Protocol Translation，附带协议转换的网络地址转换）来实现。NAT-PT提供了IPv4和IPv6地址之间的相互转换功能，例如，使用此技术可以使IPv6网络中的主机直接访问IPv4网络中的FTP服务器。<br>如图1-1所示，NAT-PT作用于IPv4和IPv6网络边缘设备上，所有的地址转换过程都在该设备上实现，对IPv4和IPv6网络来说是透明的，即用户不必改变目前的IPv4网络中主机的配置就可实现IPv6网络与IPv4网络的通信。</p><p>图1-1 NAT-PT示意图：<br><img src="https://s2.ax1x.com/2020/01/14/lbBIKO.png" alt="lbBIKO.png"></p><h3 id="1-1-2-NAT-PT基本概念"><a href="#1-1-2-NAT-PT基本概念" class="headerlink" title="1.1.2 NAT-PT基本概念"></a>1.1.2 NAT-PT基本概念</h3><p>1）NAT-PT机制</p><p>有三种NAT-PT机制可实现IPv4和IPv6地址之间的相互转换：<br>    (1) 静态映射<br>    静态映射是指采用手工配置的IPv6地址与IPv4地址的一一对应关系来实现IPv6地址与IPv4地址的转换。<br>    (2) 动态映射<br>    动态映射是指动态地创建IPv6地址与IPv4地址的对应关系来实现IPv6地址与IPv4地址的转换。和静态映射不同，动态映射中IPv6和IPv4地址之间不存在固定的一一对应关系。<br>    (3) NAPT-PT机制<br>    NAPT-PT（Network Address Port Translation-Protocol Translation，附带协议转换的网络地址端口转换）是指在IP地址静态或动态转换的基础上对TCP、UDP的端口号也进行转换。采用这种“IP地址＋端口号”的映射方式，不同的IPv6地址转换时，可以对应同一个IPv4地址，通过不同的端口号来区分不同的IPv6主机，从而节省IPv4地址资源。</p><p>2）NAT-PT前缀</p><p>NAT-PT前缀是长度为96位的IPv6地址前缀，它具有以下两个作用：</p><ul><li>从IPv6网络发送到IPv4网络的报文到达NAT-PT设备后，设备会检测报文目的IPv6地址的前缀，只有与所配置的NAT-PT前缀相同的报文才允许进行IPv6到IPv4的转换。</li><li>从IPv4网络发送到IPv6网络的报文，经过NAT-PT转换后，源IPv6地址的前缀为配置的NAT-PT前缀。</li></ul><h3 id="1-1-3-NAT-PT实现过程"><a href="#1-1-3-NAT-PT实现过程" class="headerlink" title="1.1.3 NAT-PT实现过程"></a>1.1.3 NAT-PT实现过程</h3><p>1）IPv6侧发起会话<br>图1-2 NAT-PT的实现过程（IPv6侧发起会话）：<br><img src="https://s2.ax1x.com/2020/01/14/lbDddH.png" alt="lbDddH.png"></p><pre><code>(1) 判断是否进行NAT-PT转换：NAT-PT设备接收到IPv6网络主机（IPv6 host）发送给IPv4网络主机（IPv4 host）的报文后，判断该报文是否要转发到IPv4网络。如果报文目的IPv6地址前缀与设备上预先配置的NAT-PT前缀相同，则该报文需要转发到IPv4网络，需要进行NAT-PT转换。(2) 转换源IP地址：设备根据IPv6侧配置的静态或者动态映射，进行IPv6地址到IPv4地址的转换，将报文的源IPv6地址转换为IPv4地址。(3) 转换目的IP地址：设备根据IPv4侧配置的静态映射将目的IPv6地址转换为IPv4地址。如果没有配置静态映射，那么，如果报文中的目的IPv6地址的低32位可以直接转换为合法的IPv4地址，则直接转换为目的IPv4地址；否则，转换不成功。(4) 转发报文并记录映射关系：报文的源IPv6地址和目的IPv6地址都转换为IPv4地址后，设备按照正常的转发流程将报文转发到IPv4网络中的主机。同时，将IPv6地址与IPv4地址的映射关系保存在设备中。(5) 根据记录的映射关系转发应答报文：IPv4网络主机发送给IPv6网络主机的报文到达NAT-PT设备后，设备将根据已保存的映射关系进行相反的转换，从而将报文发送给IPv6网络主机。</code></pre><p>2）IPv4侧发起会话<br>    (1) 判断是否需要进行NAT-PT转换：NAT-PT设备接收到IPv4网络主机发送给IPv6网络主机的报文后，判断该报文是否要转发到IPv6网络。如果报文目的IPv4地址与IPv6侧配置的静态映射IPv4地址相同，则该报文需要转发到IPv6网络，需要进行NAT-PT转换。<br>    (2) 转换源IP地址：设备根据IPv4侧配置的静态或者动态映射，进行IPv4地址到IPv6地址的转换，将报文的源IPv4地址转换为IPv6地址。如果未配置IPv4侧报文的映射，则在源IPv4地址前添加配置的第一个NAT-PT前缀，作为转换后的源IPv6地址。<br>    (3) 转换目的IP地址：设备根据IPv6侧配置的静态映射将目的IPv4地址转换为IPv6地址。<br>    (4) 转发报文并记录映射关系：报文的源IPv4地址和目的IPv4地址都转换为IPv6地址后，设备按照正常的转发流程将报文转发到IPv6网络中的主机。同时，将IPv4地址与IPv6地址的映射关系保存在设备中。<br>    (5) 根据记录的映射关系转发应答报文：IPv6网络主机发送给IPv4网络主机的报文到达NAT-PT设备后，设备将根据已保存的映射关系进行相反的转换，从而将报文发送给IPv4网络主机。</p><h3 id="1-1-4-NAT-PT的局限性"><a href="#1-1-4-NAT-PT的局限性" class="headerlink" title="1.1.4 NAT-PT的局限性"></a>1.1.4 NAT-PT的局限性</h3><p>NAT-PT具有下列一些局限性：</p><ul><li>属于同一会话的请求和响应都必须通过同一台NAT-PT设备，才能进行NAT-PT转换。</li><li>不能转换IPv4报文头的可选项部分。</li><li>缺少端到端的安全性。</li></ul><p>因此，在一些场合不推荐使用NAT-PT，例如，IPv6网络中主机跨越IPv4网络与另一IPv6网络中主机通信时，推荐使用隧道技术。<br>目前，设备支持NAT-PT转换的协议包括ICMP、DNS、FTP以及与网络层协议相关但协议字段不涉及IP地址信息的协议。隧道技术的详细介绍，请参见“三层技术-IP业务配置指导”中的“隧道”。</p><h3 id="1-1-5-协议规范"><a href="#1-1-5-协议规范" class="headerlink" title="1.1.5 协议规范"></a>1.1.5 协议规范</h3><p>与NAT-PT相关的协议规范有：</p><ul><li>RFC 2765：Stateless IP/ICMP Translation Algorithm</li><li>RFC 2766：Network Address Translation - Protocol Translation (NAT-PT)</li></ul><h2 id="2-配置NAT-PT"><a href="#2-配置NAT-PT" class="headerlink" title="2.配置NAT-PT"></a>2.配置NAT-PT</h2><p>在配置NAT_PT之前，首先要让路由器与电脑连接，配置命令的输入需要使用命令窗口输入，msr900路由器可以通过console线连接console口和电脑开启命令窗口，也通过网线使用telnet连接，但是目前没有console线，所以使用telnet连接路由器，这里只介绍我们使用的连接方式，方法如下：</p><ol><li><p>连接网线<br>将网线连接到GE1-GE4口和电脑网口，由于路由器初始地址是192.168.1.1，因此将电脑IPv4地址改到192.168.1.0/255.255.255.0网段，比如192.168.1.2，才能和路由器通信， </p></li><li><p>连接路由器：<br>要使用telnet功能需要在路由器中开启telnet功能，开启方法如下：<br>将网线插到电脑和路由器GE1-GE4端口，在web端登陆192.168.1.1，进入web配置界面。<br><img src="https://s2.ax1x.com/2020/01/14/lbr10g.png" alt="lbr10g.png"><br><img src="https://s2.ax1x.com/2020/01/14/lbr37Q.png" alt="lbr37Q.png"><br>初始用户名和密码都是admin，登陆管理界面（有些浏览器登陆可能有问题，不能登陆就换个其它浏览器试试，谷歌浏览器是可以登陆的）</p></li></ol><p>登陆成功之后会显示如下界面：<br><img src="https://s2.ax1x.com/2020/01/14/lbrYhn.png" alt="lbrYhn.png"></p><p>登陆过后选择系统管理→服务管理→勾选启用Telnet服务<br><img src="https://s2.ax1x.com/2020/01/14/lbr0nU.png" alt="lbr0nU.png"></p><p>然后在系统管理→用户管理→修改用户→选中admin→勾选Telnet服务<br><img src="https://s2.ax1x.com/2020/01/14/lbrWjK.png" alt="lbrWjK.png"></p><p>最后点击保存，以保存当前设置<br><img src="https://s2.ax1x.com/2020/01/14/lbrhnO.png" alt="lbrhnO.png"></p><p>之后在电脑上打开控制面板选择程序→打开启用或关闭Windows功能→勾选telnet客户端<br><img src="https://s2.ax1x.com/2020/01/14/lbr5He.png" alt="lbr5He.png"><br><img src="https://s2.ax1x.com/2020/01/14/lbroAH.png" alt="lbroAH.png"></p><p>完成设置之后就可以使用telnet登陆路由器：<br>在cmd中输入命令telnet [路由器地址]，就可以使用telnet连接到路由器<br><img src="https://s2.ax1x.com/2020/01/14/lbrTNd.png" alt="lbrTNd.png"></p><p>连接之后输入之前web端的用户名和密码就可以登陆到路由器了<br><img src="https://s2.ax1x.com/2020/01/14/lbrOjf.png" alt="lbrOjf.png"><br><img src="https://s2.ax1x.com/2020/01/14/lbsFg0.png" alt="lbsFg0.png"></p><p>telnet登陆成功之后就可以输入命令了（注：命令可以按tap键补全）</p><h2 id="3-配置示例"><a href="#3-配置示例" class="headerlink" title="3.配置示例"></a>3.配置示例</h2><p><img src="https://s2.ax1x.com/2020/01/14/lbsEuT.png" alt="lbsEuT.png"><br>依照上图为例进行配置<br>配置NAT-PT示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">system-view</span><br><span class="line">ipv6</span><br><span class="line">interface GigabitEthernet0&#x2F;1  &#x2F;&#x2F; 0&#x2F;1代表选择GE1口</span><br><span class="line">display this   &#x2F;&#x2F;如查看到打印信息“port link-mode bridge”说明此时这个GE口是bridge模式，需要改变成route模式，初始状态下GE口都是bridge模式</span><br><span class="line"></span><br><span class="line">port link-mode route   &#x2F;&#x2F;改变GE口为route模式</span><br><span class="line">ip address 8.0.0.1 255.255.255.0   &#x2F;&#x2F;将此GE口IPv4地址设置为8.0.0.1（注：每个route模式的GE口与其它所有端口都不能在同一网段）</span><br><span class="line"></span><br><span class="line">natpt enable   &#x2F;&#x2F;启动NAT-PT功能</span><br><span class="line">display this   &#x2F;&#x2F;可以再查看一次端口状态，确认配置无误</span><br><span class="line">quit</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0&#x2F;2   &#x2F;&#x2F;选择GE2口</span><br><span class="line">display this    &#x2F;&#x2F;检查GE口模式</span><br><span class="line">port link-mode route   &#x2F;&#x2F;改变GE口为route模式</span><br><span class="line">ipv6 address 2001::1&#x2F;64   &#x2F;&#x2F;将此GE口IPv6地址设置为2001::1</span><br><span class="line">natpt enable </span><br><span class="line">display this   &#x2F;&#x2F;确定配置无误</span><br><span class="line">quit</span><br><span class="line"></span><br><span class="line">natpt prefix 3001::  &#x2F;&#x2F;配置NAT-PT前缀</span><br><span class="line">natpt v4bound static 8.0.0.2 3001::5   &#x2F;&#x2F;配置IPv4侧报文的静态映射</span><br><span class="line">natpt v6bound static 2001::2 9.0.0.5   &#x2F;&#x2F;配置IPv6侧报文的静态映射</span><br></pre></td></tr></table></figure><p>此时路由器已经设置完毕，可以输入命令<code>display cu</code>并不断按<code>enter</code>键打印所有配置信息检查配置是否正确。</p><p>由于IPv4侧和IPv6侧不在同一网段，要相互通信必须经过一个网关，此时路由器就充当了网关的功能，因此需要将IPv4侧主机IPv4地址设置到8.0.0.0/24网段，比如8.0.0.2。网关设置为8.0.0.1。最后连上GE1口。同理将IPv6侧主机IPv6地址设置到2001::/64网段，比如2001::2。并且将网关设置为2001::1。</p><p>配置完成之后，将IPv4端插在GE1口，将IPv6端插在GE2口，在IPv4端ping 9.0.0.5能收到从IPv6端发回来的相应报文，同样在IPv6端ping 3001::5能收到从IPv4端发回的响应报文</p><p>确定配置成功后，在路由器输入quit退出到用户界面，就是显示<H3C>，而不是[H3C]的界面，输入save，根据提示，将此时的设置保存为文件natpt.cfg。（注：名称可以任取，但必须加.cfg）</p><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> H3C路由器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>S323实验室打印机脱机了怎么办？（HP LaserJet MFP M227fdw 型号）</title>
      <link href="/2020/01/14/S323%E6%89%93%E5%8D%B0%E6%9C%BA%E8%84%B1%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2020/01/14/S323%E6%89%93%E5%8D%B0%E6%9C%BA%E8%84%B1%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="先执行最简单的方案：执行-步骤1-gt-步骤2-gt-步骤4-。"><a href="#先执行最简单的方案：执行-步骤1-gt-步骤2-gt-步骤4-。" class="headerlink" title="先执行最简单的方案：执行 步骤1 -&gt; 步骤2 -&gt; 步骤4 。"></a>先执行最简单的方案：执行 步骤1 -&gt; 步骤2 -&gt; 步骤4 。</h2><h2 id="1-win10下，用cortana搜索“打印机和扫描仪”；"><a href="#1-win10下，用cortana搜索“打印机和扫描仪”；" class="headerlink" title="1.win10下，用cortana搜索“打印机和扫描仪”；"></a>1.win10下，用cortana搜索“打印机和扫描仪”；</h2><p><img src="https://s2.ax1x.com/2020/01/14/lb0hng.png" alt="lb0hng.png"></p><h2 id="2-在已知的设备栏中，找到我们的打印机（现在改名字了，叫S323）"><a href="#2-在已知的设备栏中，找到我们的打印机（现在改名字了，叫S323）" class="headerlink" title="2.在已知的设备栏中，找到我们的打印机（现在改名字了，叫S323）"></a>2.在已知的设备栏中，找到我们的打印机（现在改名字了，叫S323）</h2><p><img src="https://s2.ax1x.com/2020/01/14/lbBSE9.png" alt="lbBSE9.png"><br>点击“删除设备”；</p><h2 id="3-然后去“设备管理器”，在“图像设备”栏下，右键“卸载设备”。"><a href="#3-然后去“设备管理器”，在“图像设备”栏下，右键“卸载设备”。" class="headerlink" title="3.然后去“设备管理器”，在“图像设备”栏下，右键“卸载设备”。"></a>3.然后去“设备管理器”，在“图像设备”栏下，右键“卸载设备”。</h2><h2 id="4-回到“打印机与扫描仪”界面，点击“添加打印机和扫描仪”，下面就可以扫描到我们的打印机了；"><a href="#4-回到“打印机与扫描仪”界面，点击“添加打印机和扫描仪”，下面就可以扫描到我们的打印机了；" class="headerlink" title="4.回到“打印机与扫描仪”界面，点击“添加打印机和扫描仪”，下面就可以扫描到我们的打印机了；"></a>4.回到“打印机与扫描仪”界面，点击“添加打印机和扫描仪”，下面就可以扫描到我们的打印机了；</h2><h2 id="5-之后打开之前在光盘中早就装好的驱动，打开那个软件，添加新设备，找到172-16-34-200的地址，按指示行动！"><a href="#5-之后打开之前在光盘中早就装好的驱动，打开那个软件，添加新设备，找到172-16-34-200的地址，按指示行动！" class="headerlink" title="5.之后打开之前在光盘中早就装好的驱动，打开那个软件，添加新设备，找到172.16.34.200的地址，按指示行动！"></a>5.之后打开之前在光盘中早就装好的驱动，打开那个软件，添加新设备，找到172.16.34.200的地址，按指示行动！</h2><p><strong>如果还是不行的话，建议多试几遍？或者自求多福？==</strong><br>我尽力了/。</p><hr><p>2020.05.26更新</p><h2 id="以下是一些可尝试步骤："><a href="#以下是一些可尝试步骤：" class="headerlink" title="以下是一些可尝试步骤："></a>以下是一些可尝试步骤：</h2><ol><li><p>若 “网络连接” 中有很多 “本地连接XX”，如下图所示。则先 <strong>禁用</strong>不必要的本地连接；<br><a href="https://imgchr.com/i/tF0pIs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/26/tF0pIs.png" alt="tF0pIs.png"></a></p></li><li><p>在 “以太网” 的 “属性” 下，设置静态IPv4地址；<br><a href="https://imgchr.com/i/tF0KiR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/26/tF0KiR.png" alt="tF0KiR.png"></a></p></li></ol><p>注意事项：</p><ul><li>子网掩码为<code>255.255.0.0</code></li><li>默认网关为<code>172.16.34.1</code></li></ul><ol start="3"><li><p>用<code>ipconfig</code>命令查看自己的电脑是否将静态IPv4地址分配成功；</p></li><li><p>用<code>ping 172.16.34.200</code>命令检查，自己的电脑是否ping得通打印机；</p></li><li><p>执行 步骤4  </p></li></ol><p>应该后面没问题了~</p><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打印机 </tag>
            
            <tag> 脱机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天河数据库.DBF文件占用内存大的解决方法</title>
      <link href="/2020/01/14/%E5%A4%A9%E6%B2%B3%E6%95%B0%E6%8D%AE%E5%BA%93DBF%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E5%A4%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/01/14/%E5%A4%A9%E6%B2%B3%E6%95%B0%E6%8D%AE%E5%BA%93DBF%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E5%A4%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="简单问题介绍"><a href="#简单问题介绍" class="headerlink" title="简单问题介绍"></a>简单问题介绍</h2><p>UNDOTBS01.DBF，是表空间文件，主要就是为了undo，即撤销、回滚，只要有DML操作等，就会产生undo数据，久而久之会变得非常大，占用大量磁盘空间。<br><img src="https://s2.ax1x.com/2020/01/14/lbdw8K.jpg" alt="lbdw8K.jpg"></p><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><ol><li>进入机房的服务器，先用管理员身份登录 plsqidev.exe 。</li></ol><p><img src="https://s2.ax1x.com/2020/01/14/lbdvxU.png" alt="lbdvxU.png"></p><ol start="2"><li><p>输入用户名，选择对应的选项。</p><p>用户名：sys/change_on_install（管理员身份）<br>密码：oracle  或者密码：123456<br>数据库orcl<br>连接名用sysdba </p></li><li><p>按下面步骤操作一番。</p><p>New -&gt; SQL Window (新建一个.sql脚本文件)<br>1）create undo tablespace undotBS2 datafile ‘C:\Oracle\oradata\thapp\UNDOTBS2.DBF’ size 100m;<br>//在这个路径是大文件所在路径，新创建这个UNDOTBS2.DBF文件，先不执行<br>2）注释掉上面那一条<br>select * from dba_tablespaces；<br>执行这个<br>3）只执行1）中的命令<br>4）alter system set undo_tablespace=undotBS2;<br>依旧只执行这一条<br>5）drop tablespace undotbs1 including contents;<br>6）执行2）中的命令<br>7）alter database datafile ‘C:\Oracle\oradata\thapp\undotbs2.dbf’ autoextend off;<br>//跟之前创建的文件名保持一致<br>8）重启oracle服务<br>右击计算机-&gt;管理-&gt;服务-&gt;<br><img src="https://s2.ax1x.com/2020/01/14/lbweMD.png" alt="lbweMD.png"><br>-&gt;右击重新启动</p></li><li><p>登陆 plsqidev.exe 。</p><p> Username:THAPP_ENTITY<br> Passwd:thsoft<br> Database:THAPP<br> Connect as:Normal</p></li><li><p>查看三张表。</p><p> Myproject -&gt; Tables -&gt; DEMO_xxx<br> 右击Query Data即可</p></li></ol><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>按照以上步骤，就可以删除原来占用内存比较大的.DBF文件啦~<br>不然的话，天河数据库会跑崩，或者思科的dataflow界面数据上不去！</p><p>本方法参考的网址：<a href="https://blog.csdn.net/sinat_27933301/article/details/80932226" target="_blank" rel="noopener">https://blog.csdn.net/sinat_27933301/article/details/80932226</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> laboratory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .DBF文件 </tag>
            
            <tag> 占内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些让你怦然心动的英语</title>
      <link href="/2020/01/11/The%20English%20that%20makes%20your%20heart%20skip%20a%20beat/"/>
      <url>/2020/01/11/The%20English%20that%20makes%20your%20heart%20skip%20a%20beat/</url>
      
        <content type="html"><![CDATA[<h2 id="1-dust"><a href="#1-dust" class="headerlink" title="1. dust"></a>1. dust</h2><p>dust同时又是自己的反义词哦。<br>dust the bookshelves，将灰尘从书架上扫落<br>dust the cake with icing sugar，在蛋糕上撒糖粉</p><p>dust既可以表示从物体表面上扫落粉尘，又能表示在物体表面上撒上粉尘。</p><p>这类词叫<code>auto-antonym</code>，特性就是自身有两个正好相反的含义。<br><a href="http://www.fun-with-words.com/nym_autoantonyms.html" target="_blank" rel="noopener">fun-with-words</a>和<a href="https://www.mentalfloss.com/article/57032/25-words-are-their-own-opposites" target="_blank" rel="noopener">25 Words That Are Their Own Opposites</a>收集了一些相同特性的单词,有兴趣的可以了解一下。</p><h2 id="2-serendipity"><a href="#2-serendipity" class="headerlink" title="2.serendipity"></a>2.serendipity</h2><p>即，与美好的事物不期而遇，意外发现美好事物的能力。<br><img src="https://s2.ax1x.com/2020/01/11/lIBmss.png" alt="lIBmss.png"></p><p>serendipity可以是你匆忙赶到考场后发现自己忘了带笔，却意外地在桌子地抽屉里发现了一只笔；可以是你在漫无目的地闲逛时，无意中却遇到了最美的风景；可以是“与君初相识，犹如故人归”；可以是觅得知己时地相见恨晚；可以是短暂相交后地性情相投；可以是《罗马假日》里公主与平民间只有一天却足以铭记终生地爱情；可以是《泰坦尼克号》里Jack和Rose的船上的相遇。</p><p><strong>总之，serendipity代表着一切与美好的不期而遇。</strong></p><p>由serendipity这个词引出了serendipper，指有感知力和洞察力，能够发现生活中美好垫底的人。</p><p>Be a serendipper, and find your own serendipity!</p><h2 id="3-redamancy"><a href="#3-redamancy" class="headerlink" title="3.redamancy"></a>3.redamancy</h2><p>是一个单词，也是一个故事。</p><p>释义：你爱着某人时，某人也在爱你。</p><h2 id="4-iridescent"><a href="#4-iridescent" class="headerlink" title="4. iridescent"></a>4. iridescent</h2><p>释义：彩虹色的、彩虹般绚丽的</p><p>这是《怦然心动》这部电影中，男主的爷爷说出的一句经典台词。<br><img src="https://s2.ax1x.com/2020/01/11/lIBbOs.jpg" alt="lIBbOs.jpg"></p><p>Some of us get dipped in flat, some in satin, some in gloss. But every once in a while you find someone who’s iridescent, and when you do, nothing will ever compare.<br>有些人平庸浅薄，金玉其外，败絮其中。可不经意间，有一天你会遇到一个彩虹般绚丽的人，从此以后，其他人就不过是匆匆浮云。（斯人若彩虹，遇上方知有）</p><p>看到这段，不禁让我想起一句诗：曾经沧海难为水，除去巫山不是云。</p><h2 id="5-frenemy"><a href="#5-frenemy" class="headerlink" title="5. frenemy"></a>5. frenemy</h2><p>释义：亦敌亦友</p><p>送给最大的敌人，也是最敬佩的朋友。</p><p>英英释义：”Frenemy” (alternately spelled “frienemy”) is a portmanteau of “friend” and “enemy” that can refer to either an enemy pretending to be a friend or someone who really is a friend but is also a rival.</p><h2 id="6-shmily"><a href="#6-shmily" class="headerlink" title="6.shmily"></a>6.shmily</h2><p>一个缩写词<br>释义：看我是多么的爱你(see how much I love you)</p><hr>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab 2016a破解教程</title>
      <link href="/2020/01/10/matlab%202016a%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/"/>
      <url>/2020/01/10/matlab%202016a%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装教程"><a href="#一、安装教程" class="headerlink" title="一、安装教程"></a>一、安装教程</h2><ol><li>下载的所需准备文件</li></ol><ul><li>Matlab_R2016a_win64.iso(安装文件)</li><li>Matlab_R2016a_破解文档(破解时会用到)</li></ul><p>链接：<a href="https://pan.baidu.com/s/1VnKc7fCHMfR_UFZcGkmMpw" target="_blank" rel="noopener">https://pan.baidu.com/s/1VnKc7fCHMfR_UFZcGkmMpw</a><br>提取码：38n4 </p><ol start="2"><li><p>用解压软件解压安装文件（.iso后缀的）<br><img src="https://s2.ax1x.com/2020/01/10/lhNrN9.png" alt="lhNrN9.png"></p></li><li><p>点击set up进行安装<br><img src="https://s2.ax1x.com/2020/01/10/lhN5AH.png" alt="lhN5AH.png"></p></li><li><p>点击setup.exe，之后稍等一会儿，MathWorks安装程序启动，启动后选择“使用文件安装密钥 不需要Internet连接”<br><img src="https://s2.ax1x.com/2020/01/10/lhUuCR.png" alt="lhUuCR.png"></p></li><li><p>点击下一步，是否接受许可协议的条款哪儿选择“是”<br><img src="https://s2.ax1x.com/2020/01/10/lhUd2t.png" alt="lhUd2t.png"></p></li><li><p>点击下一步，选择“我已有我的许可证的文件安装密钥”。</p></li></ol><p>在下面输入秘钥：“09806-07443-53955-64350-21751-41297”<br><img src="https://s2.ax1x.com/2020/01/10/lhU2Ps.png" alt="lhU2Ps.png"></p><ol start="7"><li><p>选择要安装的目录，我安装在“D:\Program Files\matlab”<br><img src="https://s2.ax1x.com/2020/01/10/lhUHIJ.png" alt="lhUHIJ.png"></p></li><li><p>选择需要安装的产品，建议全选，也可根据自己需要选择要安装的产品，我是全选的，选择之后点击“下一步”。<br><img src="https://s2.ax1x.com/2020/01/10/lhaiid.png" alt="lhaiid.png"></p></li><li><p>之后进入安装选项，下面的两个选项都选择，之后点击“下一步”<br><img src="https://s2.ax1x.com/2020/01/10/lhaVQP.png" alt="lhaVQP.png"></p></li><li><p>进入“确认”页面，点击“安装”</p></li><li><p>进入安装界面，有进度条显示安装进度，安装过程需要较长时间<br><img src="https://s2.ax1x.com/2020/01/10/lhalJs.png" alt="lhalJs.png"></p></li><li><p>安装完成之后，进入“产品配置说明”界面，点击“下一步”继续<br><img src="https://s2.ax1x.com/2020/01/10/lhaNeU.png" alt="lhaNeU.png"></p></li><li><p>之后进入“安装完毕”界面，点击“完成”按钮，完成安装.<br><img src="https://s2.ax1x.com/2020/01/10/lhaBWR.png" alt="lhaBWR.png"><br>安装完成后不要急着打开，接下来是破解教程。</p></li></ol><h2 id="二、破解教程"><a href="#二、破解教程" class="headerlink" title="二、破解教程"></a>二、破解教程</h2><ol><li><p>将下载的Matlab 2016a 破解文件解压，解压后文件如图所示。<br>文件夹中的“license_standalone.lic”就是许可文件<br><img src="https://s2.ax1x.com/2020/01/10/lhdm11.png" alt="lhdm11.png"></p></li><li><p>之后打开MATLAB的安装目录D:\Program Files\matlab\bin\win64点击“activate_matlab.exe”进行激活，选择“在不选择Internet情况下手动激活”，点击“下一步”继续。<br><img src="https://s2.ax1x.com/2020/01/10/lhd0HS.png" alt="lhd0HS.png"></p></li><li><p>选择“输入许可证文件的完成路径（包括文件名）”,在“浏览中”选择刚才解压的“Matlab_R2016a_破解文档”文件夹中的许可文件<br><img src="https://s2.ax1x.com/2020/01/10/lhdqjx.png" alt="lhdqjx.png"><br><img src="https://s2.ax1x.com/2020/01/10/lhdxED.png" alt="lhdxED.png"></p></li><li><p>之后进入“离线激活”界面，现在的许可证文件的路径已经填写完整，点击“下一步”<br><img src="https://s2.ax1x.com/2020/01/10/lhwZVS.png" alt="lhwZVS.png"></p></li><li><p>之后提示“激活完成”，如图所示。此时不要打开软件。<br><img src="https://s2.ax1x.com/2020/01/10/lhw3rV.png" alt="lhw3rV.png"></p></li><li><p>打开解压的“Matlab_R2016a_破解文档”文件夹中的MATLAB Production Server\R2016a\bin\win64，复制其中的三个dll文件<br><img src="https://s2.ax1x.com/2020/01/10/lhwwx1.png" alt="lhwwx1.png"></p></li><li><p>之后打开D:\Program Files\matlab\R2016a\bin\win64文件，<br>将复制的dll文件粘贴在这个文件夹中，系统会提示“复制文件”选项，所有文件都选择“复制和替换”即可。</p></li><li><p>之后打开软件，就拥有一个完全免费的matlab 2016a中文破解版本了。<br><img src="https://s2.ax1x.com/2020/01/10/lhwRGd.png" alt="lhwRGd.png"><br><img src="https://s2.ax1x.com/2020/01/10/lhwIqf.png" alt="lhwIqf.png"></p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在cooja中运行collect view实验例子出现问题时</title>
      <link href="/2020/01/09/%E5%9C%A8cooja%E4%B8%AD%E4%BD%BF%E7%94%A8example%E4%B8%8B%E7%9A%84collect%20view%E5%AE%9E%E4%BE%8B%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%97%B6/"/>
      <url>/2020/01/09/%E5%9C%A8cooja%E4%B8%AD%E4%BD%BF%E7%94%A8example%E4%B8%8B%E7%9A%84collect%20view%E5%AE%9E%E4%BE%8B%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<p>Cooja是Contiki无线嵌入式系统自带的网络模拟器，Cooja的功能十分强大，开发者通过使用Cooja可以建立基于软件的开发工程，对各种所支持的板进行模拟，而不需要硬件资源。</p><p>collectview是cooja中自带的工具，可以对WSN中的节点进行详细的分析，如占空比、能源消耗、网络结构图等。</p><p>下面说一下如何在cooja中运行collectview的官方例子，系统版本为contiki-3.0，环境为虚拟机上运行InstantContiki3.0。</p><ol><li>运行cooja仿真器，找到collectview的例子</li></ol><p>选择：file-&gt;open simulation-&gt;browse<br>路径：contiki-3.0/examples/collect/example-collect-view.csc。</p><ol start="2"><li><p>打开工程后，会弹出“sensor data collect with contiki”窗口。</p></li><li><p>点击<code>start</code>按钮。<br>启动网络</p></li><li><p>在“sensor data collect with contiki”窗口选择“node control”模块后，并点击<code>start collect</code>按钮</p></li><li><p>你会发现“power”等其他选项卡，里面的内容一片空白，没有显示统计数据。而且如果点击其他选项还可能报错误，如下图所示：<br><img src="https://s2.ax1x.com/2020/01/09/lftsgK.png" alt="lftsgK.png"></p></li><li><p>别慌，按以下步骤操作：</p></li></ol><ul><li>关闭目前开启的“sensor data collect with contiki”窗口；</li><li>在cooja中选择tools-&gt;Collect View-&gt;Sky1；</li><li>之后，就会重新打开了一个“Sensor Data Collect with Contiki”界面；</li><li>在这个界面中再选择”Node Control”，点击“Start Collect”，然后点击“Send command to nodes”；</li><li>再选择”Power”就会显示网络数据的统计信息（可能需要等一会，用于统计）。</li></ul><p>之后就有数据显示出来了，如下图所示：<br><img src="https://s2.ax1x.com/2020/01/09/lftI8P.png" alt="lftI8P.png"><br><img src="https://s2.ax1x.com/2020/01/09/lftTv8.jpg" alt="lftTv8.jpg"></p><p>具体原因我也不清楚，由于刚接触Cooja仿真，所以大家如果有知道原因的，请为我解答一下。<br>例子能够运行之后，下一步就是将collect view功能集成到其他程序中，从而实现在其他contiki程序中对网络数据进行统计。</p><hr>]]></content>
      
      
      <categories>
          
          <category> contiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> contiki </tag>
            
            <tag> cooja </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark在win10下检测不出捕获接口</title>
      <link href="/2020/01/09/wireshark%20%E5%9C%A8win10%E4%B8%8B%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%87%BA%E6%8D%95%E8%8E%B7%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/01/09/wireshark%20%E5%9C%A8win10%E4%B8%8B%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%87%BA%E6%8D%95%E8%8E%B7%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="可能性1：NPF服务没有启动"><a href="#可能性1：NPF服务没有启动" class="headerlink" title="可能性1：NPF服务没有启动"></a>可能性1：NPF服务没有启动</h2><p>安装wireshark后打开提示没有找到捕获接口，可能是NPF（Netgroup Packet Filter 网络数据包过滤器）服务没有启动，解决办法就是启动NPF服务，然后重启wireshark。 </p><p>启动NPF的方法：</p><ol><li>以管理员的身份运行命令行程序cmd.exe;</li><li>输入<code>net start npf</code>命令，确定后就会提示服务启动成功;</li><li>这样的方式只能在这一次启动NPF服务，电脑重启之后又要重新启动，如果希望电脑启动时自动启用NPF服务，则可以在上面第二步将命令行换成<code>sc config npf start=auto</code>。</li></ol><h2 id="可能性2：wireshark自带的wincap不支持win10"><a href="#可能性2：wireshark自带的wincap不支持win10" class="headerlink" title="可能性2：wireshark自带的wincap不支持win10"></a>可能性2：wireshark自带的wincap不支持win10</h2><p>在<a href="http://www.win10pcap.org/download/" target="_blank" rel="noopener">下载安装Win10Pcap</a>网址可解决此问题。</p><hr>]]></content>
      
      
      <categories>
          
          <category> wireshark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wireshark </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>contiki compile error</title>
      <link href="/2020/01/07/contiki%20compile%20error/"/>
      <url>/2020/01/07/contiki%20compile%20error/</url>
      
        <content type="html"><![CDATA[<p>在cooja仿真添加sky mote的时候，选择相对应的<code>.c</code>文件后，编译会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make: msp430-gcc: Command not found</span><br><span class="line">  CC        ..&#x2F;..&#x2F;core&#x2F;net&#x2F;rime&#x2F;rimeaddr.c</span><br><span class="line">make: msp430-gcc: Command not found</span><br><span class="line">make: *** [obj_sky&#x2F;rimeaddr.o] Error 127</span><br></pre></td></tr></table></figure><p>说明没有安装msp430插件，需要执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-msp430</span><br></pre></td></tr></table></figure><p>安装完成后，再次选择文件点击编译，就好啦~</p><hr>]]></content>
      
      
      <categories>
          
          <category> contiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> contiki </tag>
            
            <tag> cooja </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cooja中的RPL目标函数与仿真（DGRM模式下）</title>
      <link href="/2020/01/05/contiki%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RPL%E7%AF%87%EF%BC%881%EF%BC%89/"/>
      <url>/2020/01/05/contiki%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RPL%E7%AF%87%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>低功耗和有损耗网络的路由协议利用目标函数(OF)建立一个面向目标的有向无环图(DODAG)。目标函数根据某种算法或计算公式使用路由度量来形成DODAG。基本上，目标函数优化或约束用于形成路由的路由度量，从而帮助选择最佳路由。在同一个节点和网格网络上可能有许多目标函数在运行，因为不同的部署目标差异很大，单个网格网络可能需要承载具有非常不同的路径质量要求的流量。</p><p>在Contiki中实现RPL，内置有两个目标函数，但是默认情况下它使用的是最小化ETX值的那个。但是，在所有路由场景中，相同的策略不可能是最佳的路由策略。因此，需要相应地修改目标函数，以适应任何额外的约束或实现不同的目标。</p><h2 id="2-这章节将会学到"><a href="#2-这章节将会学到" class="headerlink" title="2.这章节将会学到"></a>2.这章节将会学到</h2><p>本教程的基本假设是您了解用于低功耗和有损网络(RPL)的路由协议的工作原理。<br>这里使用并解释了ContikiOS 3.0 RPL的实现。<br>以下是本教程的解释:</p><ul><li>不同的RPL相关功能及其工作</li><li>示例场景和RPL目标函数的修改</li><li>基于DGRM模型的Cooja仿真</li></ul><h2 id="3-源代码路径"><a href="#3-源代码路径" class="headerlink" title="3.源代码路径"></a>3.源代码路径</h2><p>在contiki-3.0的操作系统下</p><p>~/contiki/core/net/rpl/rpl-conf.h<br>~/contiki/core/net/rpl/rpl-of0.c<br>~/contiki/core/net/rpl/rpl-mrhof.c<br>~/contiki/tools/cooja</p><h2 id="4-相关文件及功能"><a href="#4-相关文件及功能" class="headerlink" title="4. 相关文件及功能"></a>4. 相关文件及功能</h2><p>具有RPL要点的一些重要文件:rpl-config.h, rpl-of0.c, rpl-mhrof.c。但是这里只提到了这些文件中的一些重要函数。</p><h3 id="rpl-conf-h"><a href="#rpl-conf-h" class="headerlink" title="rpl-conf.h"></a>rpl-conf.h</h3><p><strong>RPL_CONF_STATS</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Set to 1 to enable RPL statistics *&#x2F;</span><br><span class="line">#ifndef RPL_CONF_STATS</span><br><span class="line">#define RPL_CONF_STATS 0</span><br><span class="line">#endif &#x2F;* RPL_CONF_STATS *&#x2F;</span><br></pre></td></tr></table></figure><p>这里禁用了RPL配置统计信息。我们需要将它设置为1。</p><p><strong>RPL_DAG_MC</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line"> * Select routing metric supported at runtime. This must be a valid</span><br><span class="line"> * DAG Metric Container Object Type (see below). Currently, we only </span><br><span class="line"> * support RPL_DAG_MC_ETX and RPL_DAG_MC_ENERGY.</span><br><span class="line"> * When MRHOF (RFC6719) is used with ETX, no metric container must</span><br><span class="line"> * be used; instead the rank carries ETX directly.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifdef RPL_CONF_DAG_MC</span><br><span class="line">#define RPL_DAG_MC RPL_CONF_DAG_MC</span><br><span class="line">#else</span><br><span class="line">#define RPL_DAG_MC RPL_DAG_MC_NONE</span><br><span class="line">#endif &#x2F;* RPL_CONF_DAG_MC *&#x2F;</span><br></pre></td></tr></table></figure><p>选择运行时支持的路由度量。<br>这里支持使用ETX和ENERGY类型的RPL度量容器。（RPL_DAG_MC_ETX 和 RPL_DAG_MC_ENERGY）<br>如果您开发了一个目标函数和相关的度量容器，则可以支持它。</p><p><strong>RPL_OF</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * The objective function used by RPL is configurable through the </span><br><span class="line"> * RPL_CONF_OF parameter. This should be defined to be the name of an </span><br><span class="line"> * rpl_of object linked into the system image, e.g., rpl_of0.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifdef RPL_CONF_OF</span><br><span class="line">#define RPL_OF RPL_CONF_OF</span><br><span class="line">#else</span><br><span class="line">&#x2F;* ETX is the default objective function. *&#x2F;</span><br><span class="line">#define RPL_OF rpl_mrhof</span><br><span class="line">#endif &#x2F;* RPL_CONF_OF *&#x2F;</span><br></pre></td></tr></table></figure><p>RPL_OF配置了RPL的目标函数。在这里，ETX是默认的目标函数。这应该定义为链接到系统映像的rpl_of对象的名称，比如rpl_of0。在这里，您还可以将它定义为您自己开发的目标函数。</p><p><strong>RPL_LEAF_ONLY</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * This value decides if this node must stay as a leaf or not</span><br><span class="line"> * as allowed by draft-ietf-roll-rpl-19#section-8.5</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifdef RPL_CONF_LEAF_ONLY</span><br><span class="line">#define RPL_LEAF_ONLY RPL_CONF_LEAF_ONLY</span><br><span class="line">#else</span><br><span class="line">#define RPL_LEAF_ONLY 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>节点是否应该作为叶节点由这个值决定。<br>(如draft-ietf-roll-rpl-19#section-8.5中所述)</p><p><strong>RPL_CONF_DEFAULT_ROUTE_INFINITE_LIFETIME</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * RPL Default route lifetime</span><br><span class="line"> * The RPL route lifetime is used for the downward routes and for the default</span><br><span class="line"> * route. In a high density network with DIO suppression activated it may happen</span><br><span class="line"> * that a node will never send a DIO once the DIO interval becomes high as it</span><br><span class="line"> * has heard DIO from many neighbors already. As the default route to the</span><br><span class="line"> * preferred parent has a lifetime reset by receiving DIO from the parent, it</span><br><span class="line"> * means that the default route can be destroyed after a while. Setting the</span><br><span class="line"> * default route with infinite lifetime secures the upstream route.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifdef RPL_CONF_DEFAULT_ROUTE_INFINITE_LIFETIME</span><br><span class="line">#define RPL_DEFAULT_ROUTE_INFINITE_LIFETIME                    RPL_CONF_DEFAULT_ROUTE_INFINITE_LIFETIME</span><br><span class="line">#else</span><br><span class="line">#define RPL_DEFAULT_ROUTE_INFINITE_LIFETIME                    0</span><br><span class="line">#endif &#x2F;* RPL_CONF_DEFAULT_ROUTE_INFINITE_LIFETIME *&#x2F;</span><br></pre></td></tr></table></figure><p>RPL路由生存期用于向下路由和默认路由的构建。在高密度网络且DIO不活跃时（组网稳定后），可能会发生这种情况：一个节点永远不会发送DIO报文了，一旦发送DIO的时间间隔变得很高则已经收到很多邻居的来信了。默认路径通过接收来自父节点的DIO信号来重置首选父节点的生存期，它表示默认路由可以在一段时间后销毁。<br>设置具有无限生存期的默认路由保护上行路由。</p><p><strong>RPL_DIO_INTERVAL_MIN</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * The DIO interval (n) represents 2^n ms.</span><br><span class="line"> *</span><br><span class="line"> * According to the specification, the default value is 3 which</span><br><span class="line"> * means 8 milliseconds. That is far too low when using duty cycling</span><br><span class="line"> * with wake-up intervals that are typically hundreds of milliseconds.</span><br><span class="line"> * ContikiRPL thus sets the default to 2^12 ms &#x3D; 4.096 s.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifdef RPL_CONF_DIO_INTERVAL_MIN</span><br><span class="line">#define RPL_DIO_INTERVAL_MIN        RPL_CONF_DIO_INTERVAL_MIN</span><br><span class="line">#else</span><br><span class="line">#define RPL_DIO_INTERVAL_MIN        12</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>DIO以2^n ms的时间间隔对外发送。<br>根据说明，默认的值为3（即2^3=8 ms）。当使用任务循环时，这个值太低了唤醒间隔通常为数百毫秒。<br>ContikiRPL因此设置默认值为2^12 ms = 4.096 s.</p><p><strong>RPL_INIT_LINK_METRIC</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Initial metric attributed to a link when the ETX is unknown</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifndef RPL_CONF_INIT_LINK_METRIC</span><br><span class="line">#define RPL_INIT_LINK_METRIC        2</span><br><span class="line">#else</span><br><span class="line">#define RPL_INIT_LINK_METRIC        RPL_CONF_INIT_LINK_METRIC</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>当ETX的值位置是，初始化这个度量值为2</p><h3 id="of0-c"><a href="#of0-c" class="headerlink" title="of0.c"></a>of0.c</h3><p>这个文件中描述了RPL中of0目标函数的定义。</p><p><strong>calculate_rank(rpl_parent_t * p, rpl_rank_t base_rank)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static rpl_rank_t</span><br><span class="line">calculate_rank(rpl_parent_t *p, rpl_rank_t base_rank)</span><br><span class="line">&#123;</span><br><span class="line">  rpl_rank_t increment;</span><br><span class="line">  if(base_rank &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    if(p &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">      return INFINITE_RANK;</span><br><span class="line">    &#125;</span><br><span class="line">    base_rank &#x3D; p-&gt;rank;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment &#x3D; p !&#x3D; NULL ?</span><br><span class="line">                p-&gt;dag-&gt;instance-&gt;min_hoprankinc :</span><br><span class="line">                DEFAULT_RANK_INCREMENT;</span><br><span class="line"></span><br><span class="line">  if((rpl_rank_t)(base_rank + increment) &lt; base_rank) &#123;</span><br><span class="line">    PRINTF(&quot;RPL: OF0 rank %d incremented to infinite rank due to wrapping\n&quot;,</span><br><span class="line">        base_rank);</span><br><span class="line">    return INFINITE_RANK;</span><br><span class="line">  &#125;</span><br><span class="line">  return base_rank + increment;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里计算节点的秩。节点的秩基于它的父级秩(parents rank)和基级秩(base rank)。</p><ul><li>如果基秩为0，而节点没有父结点，则节点的秩为无穷大。</li><li>如果基秩为0并且父秩存在，那么基秩就等于父秩。</li><li>如果基秩不为零，那么根据父级是否存在，增量(increment)将成为DAG instance中父节点的min_hoprankinc或DEFAULT_RANK_INCREMENT。</li></ul><p>简而言之，如果没有父节点，那么base_rank将增加为一个默认的增量，否则它将使用有关父级的信息来增加base_rank。</p><p>在最后一部分中，如果计算出的新秩(new rank)小于基秩(bese rank)，则新秩(new rank)由于环路loop而变得无穷大。</p><p>新计算的秩(the new caculate_rank) = 基秩(base_rank) + 增量(increment)。</p><p><strong>best_dag(rpl_dag_t * d1, rpl_dag_t * d2)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static rpl_dag_t *</span><br><span class="line">best_dag(rpl_dag_t *d1, rpl_dag_t *d2)</span><br><span class="line">&#123;</span><br><span class="line">  if(d1-&gt;grounded) &#123;</span><br><span class="line">    if (!d2-&gt;grounded) &#123;</span><br><span class="line">      return d1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if(d2-&gt;grounded) &#123;</span><br><span class="line">    return d2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(d1-&gt;preference &lt; d2-&gt;preference) &#123;</span><br><span class="line">    return d2;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if(d1-&gt;preference &gt; d2-&gt;preference) &#123;</span><br><span class="line">      return d1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(d2-&gt;rank &lt; d1-&gt;rank) &#123;</span><br><span class="line">    return d2;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return d1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数比较两个dag，并根据目标函数返回两个dag中最好的一个(作为输入d1和d2传递)。<br>这里有3个标准来找到最佳的DAG。</p><ul><li>第一个是检查DAG是否接地(if the DAG is grounded)。</li><li>其次是每个DAG的偏好度量(the preference metric of each DAG)。</li><li>第三个是每个DAG的秩(the rank of each DAG)。</li></ul><p><strong>best_parent(rpl_parent_t * p1, rpl_parent_t * p2)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static rpl_parent_t *</span><br><span class="line">best_parent(rpl_parent_t *p1, rpl_parent_t *p2)</span><br><span class="line">&#123;</span><br><span class="line">  rpl_rank_t r1, r2;</span><br><span class="line">  rpl_dag_t *dag;  </span><br><span class="line">  uip_ds6_nbr_t *nbr1, *nbr2;</span><br><span class="line">  nbr1 &#x3D; rpl_get_nbr(p1);</span><br><span class="line">  nbr2 &#x3D; rpl_get_nbr(p2);</span><br><span class="line"></span><br><span class="line">  dag &#x3D; (rpl_dag_t *)p1-&gt;dag; &#x2F;* Both parents must be in the same DAG. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if(nbr1 &#x3D;&#x3D; NULL || nbr2 &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    return dag-&gt;preferred_parent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PRINTF(&quot;RPL: Comparing parent &quot;);</span><br><span class="line">  PRINT6ADDR(rpl_get_parent_ipaddr(p1));</span><br><span class="line">  PRINTF(&quot; (confidence %d, rank %d) with parent &quot;,</span><br><span class="line">        nbr1-&gt;link_metric, p1-&gt;rank);</span><br><span class="line">  PRINT6ADDR(rpl_get_parent_ipaddr(p2));</span><br><span class="line">  PRINTF(&quot; (confidence %d, rank %d)\n&quot;,</span><br><span class="line">        nbr2-&gt;link_metric, p2-&gt;rank);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  r1 &#x3D; DAG_RANK(p1-&gt;rank, p1-&gt;dag-&gt;instance) * RPL_MIN_HOPRANKINC  +</span><br><span class="line">    nbr1-&gt;link_metric;</span><br><span class="line">  r2 &#x3D; DAG_RANK(p2-&gt;rank, p1-&gt;dag-&gt;instance) * RPL_MIN_HOPRANKINC  +</span><br><span class="line">    nbr2-&gt;link_metric;</span><br><span class="line">  &#x2F;* Compare two parents by looking both and their rank and at the ETX</span><br><span class="line">     for that parent. We choose the parent that has the most</span><br><span class="line">     favourable combination. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if(r1 &lt; r2 + MIN_DIFFERENCE &amp;&amp;</span><br><span class="line">     r1 &gt; r2 - MIN_DIFFERENCE) &#123;</span><br><span class="line">    return dag-&gt;preferred_parent;</span><br><span class="line">  &#125; else if(r1 &lt; r2) &#123;</span><br><span class="line">    return p1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return p2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数比较父节点并根据目标函数返回最佳父节点。<br>这里根据候选父节点的rank值和ETX值对候选父节点进行比较。<br>这是一个重要的功能，因为路线的形成是在此基础上选择最佳的DAG。</p><h3 id="rpl-mhrof-c"><a href="#rpl-mhrof-c" class="headerlink" title="rpl-mhrof.c"></a>rpl-mhrof.c</h3><p>该文件实现了带有滞后目标函数(MRHOF)的最小秩。目标函数使用ETX作为路由度量，它还有能量度量的存根。</p><p><strong>calculate_path_metric(rpl_parent_t * p)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static rpl_path_metric_t</span><br><span class="line">calculate_path_metric(rpl_parent_t *p)</span><br><span class="line">&#123;</span><br><span class="line">  uip_ds6_nbr_t *nbr;</span><br><span class="line">  if(p &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    return MAX_PATH_COST * RPL_DAG_MC_ETX_DIVISOR;</span><br><span class="line">  &#125;</span><br><span class="line">  nbr &#x3D; rpl_get_nbr(p);</span><br><span class="line">  if(nbr &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    return MAX_PATH_COST * RPL_DAG_MC_ETX_DIVISOR;</span><br><span class="line">  &#125;</span><br><span class="line">#if RPL_DAG_MC &#x3D;&#x3D; RPL_DAG_MC_NONE</span><br><span class="line">  &#123;</span><br><span class="line">    return p-&gt;rank + (uint16_t)nbr-&gt;link_metric;</span><br><span class="line">  &#125;</span><br><span class="line">#elif RPL_DAG_MC &#x3D;&#x3D; RPL_DAG_MC_ETX</span><br><span class="line">  return p-&gt;mc.obj.etx + (uint16_t)nbr-&gt;link_metric;</span><br><span class="line">#elif RPL_DAG_MC &#x3D;&#x3D; RPL_DAG_MC_ENERGY</span><br><span class="line">  return p-&gt;mc.obj.energy.energy_est + (uint16_t)nbr-&gt;link_metric;</span><br><span class="line">#else</span><br><span class="line">#error &quot;Unsupported RPL_DAG_MC configured. See rpl.h.&quot;</span><br><span class="line">#endif &#x2F;* RPL_DAG_MC *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里路径度量的计算根据的是OF。<br>如果没有父节点，则使用基于最大路径成本(maximum path cost)计算的默认度量。<br>如果没有提到OF，那么路径度量就是秩的和。<br>（因为OF基于ETX，它是被测量的ETX (p-&gt;mc.obj.etx)和链接度量的总和。）<br>类似地，如果OF基于能量，则将能量值(p-&gt;mc.obj.energy.energy_est)添加到链接度量(link metric)中。<br>此函数由best_parent()调用，用于比较两个父节点的路径度量。</p><p><strong>neighbor_link_callback(rpl_parent_t * p, int status, int numtx)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">neighbor_link_callback(rpl_parent_t *p, int status, int numtx)</span><br><span class="line">&#123;</span><br><span class="line">  uint16_t recorded_etx &#x3D; 0;</span><br><span class="line">  uint16_t packet_etx &#x3D; numtx * RPL_DAG_MC_ETX_DIVISOR;</span><br><span class="line">  uint16_t new_etx;</span><br><span class="line">  uip_ds6_nbr_t *nbr &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">  nbr &#x3D; rpl_get_nbr(p);</span><br><span class="line">  if(nbr &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    &#x2F;* No neighbor for this parent - something bad has occurred *&#x2F;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  recorded_etx &#x3D; nbr-&gt;link_metric;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Do not penalize the ETX when collisions or transmission errors occur. *&#x2F;</span><br><span class="line">  if(status &#x3D;&#x3D; MAC_TX_OK || status &#x3D;&#x3D; MAC_TX_NOACK) &#123;</span><br><span class="line">    if(status &#x3D;&#x3D; MAC_TX_NOACK) &#123;</span><br><span class="line">      packet_etx &#x3D; MAX_LINK_METRIC * RPL_DAG_MC_ETX_DIVISOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(p-&gt;flags &amp; RPL_PARENT_FLAG_LINK_METRIC_VALID) &#123;</span><br><span class="line">      &#x2F;* We already have a valid link metric, use weighted moving average to update it *&#x2F;</span><br><span class="line">      new_etx &#x3D; ((uint32_t)recorded_etx * ETX_ALPHA +</span><br><span class="line">                 (uint32_t)packet_etx * (ETX_SCALE - ETX_ALPHA)) &#x2F; ETX_SCALE;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;* We don&#39;t have a valid link metric, set it to the current packet&#39;s ETX *&#x2F;</span><br><span class="line">      new_etx &#x3D; packet_etx;</span><br><span class="line">      &#x2F;* Set link metric as valid *&#x2F;</span><br><span class="line">      p-&gt;flags |&#x3D; RPL_PARENT_FLAG_LINK_METRIC_VALID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PRINTF(&quot;RPL: ETX changed from %u to %u (packet ETX &#x3D; %u)\n&quot;,</span><br><span class="line">        (unsigned)(recorded_etx &#x2F; RPL_DAG_MC_ETX_DIVISOR),</span><br><span class="line">        (unsigned)(new_etx  &#x2F; RPL_DAG_MC_ETX_DIVISOR),</span><br><span class="line">        (unsigned)(packet_etx &#x2F; RPL_DAG_MC_ETX_DIVISOR));</span><br><span class="line">    &#x2F;* update the link metric for this nbr *&#x2F;</span><br><span class="line">    nbr-&gt;link_metric &#x3D; new_etx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数接收链路层邻居信息。<br>参数状态设置为0或1。<br>numetx参数表示当前邻居节点的ETX(estimated transmission)。<br>recorded_etx 是 link_metric，packet_etx是传递给函数的numetx参数。<br>new_etx是根据公式使用recorded and packet ETX计算的。<br>link_metric用新的ETX值更新。</p><p><strong>calculate_rank(rpl_parent_t * p, rpl_rank_t base_rank)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static rpl_rank_t</span><br><span class="line">calculate_rank(rpl_parent_t *p, rpl_rank_t base_rank)</span><br><span class="line">&#123;</span><br><span class="line">  rpl_rank_t new_rank;</span><br><span class="line">  rpl_rank_t rank_increase;</span><br><span class="line">  uip_ds6_nbr_t *nbr;</span><br><span class="line"></span><br><span class="line">  if(p &#x3D;&#x3D; NULL || (nbr &#x3D; rpl_get_nbr(p)) &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    if(base_rank &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return INFINITE_RANK;</span><br><span class="line">    &#125;</span><br><span class="line">    rank_increase &#x3D; RPL_INIT_LINK_METRIC * RPL_DAG_MC_ETX_DIVISOR;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    rank_increase &#x3D; nbr-&gt;link_metric;</span><br><span class="line">    if(base_rank &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      base_rank &#x3D; p-&gt;rank;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(INFINITE_RANK - base_rank &lt; rank_increase) &#123;</span><br><span class="line">    &#x2F;* Reached the maximum rank. *&#x2F;</span><br><span class="line">    new_rank &#x3D; INFINITE_RANK;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">   &#x2F;* Calculate the rank based on the new rank information from DIO or</span><br><span class="line">      stored otherwise. *&#x2F;</span><br><span class="line">    new_rank &#x3D; base_rank + rank_increase;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new_rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类似于前面介绍的calculate_rank()函数，但有一点不同。<br>在这个函数中，如果parent = NULL，rank_increase是一个等于RPL_INIT_LINK_METRIC的增量。否则它等于link_metric。<br>new_rank = the increment + base rank</p><p><strong>est_parent(rpl_parent_t * p1, rpl_parent_t * p2)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static rpl_parent_t *</span><br><span class="line">best_parent(rpl_parent_t *p1, rpl_parent_t *p2)</span><br><span class="line">&#123;</span><br><span class="line">  rpl_dag_t *dag;</span><br><span class="line">  rpl_path_metric_t min_diff;</span><br><span class="line">  rpl_path_metric_t p1_metric;</span><br><span class="line">  rpl_path_metric_t p2_metric;</span><br><span class="line"></span><br><span class="line">  dag &#x3D; p1-&gt;dag; &#x2F;* Both parents are in the same DAG. *&#x2F;</span><br><span class="line"></span><br><span class="line">  min_diff &#x3D; RPL_DAG_MC_ETX_DIVISOR &#x2F;</span><br><span class="line">             PARENT_SWITCH_THRESHOLD_DIV;</span><br><span class="line"></span><br><span class="line">  p1_metric &#x3D; calculate_path_metric(p1);</span><br><span class="line">  p2_metric &#x3D; calculate_path_metric(p2);</span><br><span class="line"></span><br><span class="line">  &#x2F;* Maintain stability of the preferred parent in case of similar ranks. *&#x2F;</span><br><span class="line">  if(p1 &#x3D;&#x3D; dag-&gt;preferred_parent || p2 &#x3D;&#x3D; dag-&gt;preferred_parent) &#123;</span><br><span class="line">    if(p1_metric &lt; p2_metric + min_diff &amp;&amp;</span><br><span class="line">       p1_metric &gt; p2_metric - min_diff) &#123;</span><br><span class="line">      PRINTF(&quot;RPL: MRHOF hysteresis: %u &lt;&#x3D; %u &lt;&#x3D; %u\n&quot;,</span><br><span class="line">             p2_metric - min_diff,</span><br><span class="line">             p1_metric,</span><br><span class="line">             p2_metric + min_diff);</span><br><span class="line">      return dag-&gt;preferred_parent;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return p1_metric &lt; p2_metric ? p1 : p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类似于前面的best_parent()函数，该函数比较两个父类并返回最佳的一个。<br>这里，为每个父节点计算的路径度量(path metric)是比较的基础。<br>首先检查在DAG中是否有一个父节点被设置为首选父对象，如果是，则选择它作为最佳父对象(基于MRHOF滞后现象 RFC 6719)。<br>否则，将比较计算的两个度量，选择具有较低度量的节点为最好的父节点。<br>在这个函数下，只有当它比当前路径少于一个给定阈值时，才切换到最小秩路径。<br>第二种机制称为“滞后现象”(RFC 6719)。这里，PARENT_SWITCH_THRESHOLD_DIV被定义为2。</p><p>这种父选择发生在以下情况中：</p><ul><li>在网络的初始形成过程中</li><li>当邻近节点的路径代价发生变化时</li><li>一个新节点出现在该节点的邻域中</li></ul><h2 id="5-目标函数的修改"><a href="#5-目标函数的修改" class="headerlink" title="5.目标函数的修改"></a>5.目标函数的修改</h2><p><img src="https://s2.ax1x.com/2020/01/08/l2jDWd.png" alt="l2jDWd.png"><br>上图显示了一个可以使用的拓扑示例。<br>一个目标函数基本上使用一个链路度量(link metric)，并有一个约束的函数试图为路由选择最佳路径。<br>要定义一个全新的目标函数文件(不修改现有文件)，必须在其中定义以下函数。<br>还应该相应地修改makefile，并注意新文件不应出现编译和链接错误。<br>一些RPL OF 的API如下所示：</p><ul><li>reset(dag):重置特定DAG的目标函数状态。在对DAG执行全局修复时调用此函数。</li><li>neighbor_link_callback(parent, status, etx): 接收链路层邻居信息。</li><li>best_parent(parent1, parent2):根据OF，比较两个父节点并返回最好的一个。</li><li>best_dag(dag1, dag2):根据OF，比较两个dag并返回最好的一个。</li><li>calculate_rank(parent, base_rank): 使用父秩和基秩计算秩值。</li><li>update_metric_container(dag): 在某个DAG中更新传出DIOs的度量容器。如果DAG的目标函数不使用度量容器，则该函数应该将对象类型设置为RPL_DAG_MC_NONE。</li></ul><p>修改目标函数的一个例子可以是<strong>Load Balancing application</strong>。<br>新的目标函数应该选择一条最小化ETX的路由，如果有多条路由具有相同的ETX，或者ETX在预定义的范围内，那么它应该减小这些路由中任意一条转发包的最大数量。<br>这意味着任何一个节点都不承担转发包的负载，而其他节点则处于未被利用的状态。</p><p>解决这个问题的一种方法是定义一个如前所述的全新的目标函数。<br>另一种方法是修改现有的rpl-mhrof.c文件。因为它已经使用了问题的最小ETX部分，我们只需要实现负载平衡部分。<br>当一个子节点有多条路由时，负载平衡就出现了，比如父节点们。因此，the best parent function应该做相应的修改。</p><p>另一个例子是选择<strong>shortest path with nodes using minimum energy</strong>。<br>这里的目标函数应该是这样的:<br>    它首先使用最小能量或在一个范围内识别节点；<br>    然后使用最小跳数通过这些节点到达目的地。<br>这可以应用于这样一种情况:一个节点必须快速发送数据，而不会给一个能量不足的节点带来负担。<br>在这个场景中，使用能量度量的目标函数在当前的rpl-mhrof.c中的当前实现中已经存在，并且目标函数可以与附加逻辑一起用于在选择父节点时选择最小跳数。<br>其他需要新的或修改的目标函数的场景可以基于不同的链接度量，如吞吐量(throughput)、链接质量级别(link quelity level)、延迟(latency)等。</p><h2 id="6-Cooja仿真（在DGRM模式下）"><a href="#6-Cooja仿真（在DGRM模式下）" class="headerlink" title="6.Cooja仿真（在DGRM模式下）"></a>6.Cooja仿真（在DGRM模式下）</h2><p>使用DGRM模型是因为它更容易改变链路接收速率。<br>此外，在两个需要的节点之间形成链接也更容易，其他节点除外。以下是形成一个新的模拟的步骤:</p><p>注意:您可以参考<a href="http://anrg.usc.edu/contiki/index.php/Cooja_Simulator" target="_blank" rel="noopener">Cooja Simulater</a>来了解Cooja.</p><ul><li>运行cooja</li></ul><p>打开你的contiki文件夹，在路径“contiki-3.0/tools/cooja”下，进入终端，敲下面命令，打开GUI界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ant run</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/01/08/l2zBYF.png" alt="l2zBYF.png"></p><ul><li>开始一个新的仿真</li></ul><p>从<code>file</code>下拉菜单中选择<code>New Simulation</code><br><img src="https://s2.ax1x.com/2020/01/08/l2zjk8.png" alt="l2zjk8.png"></p><p>会弹出下面的界面：<br><img src="https://s2.ax1x.com/2020/01/08/lRSQn1.png" alt="lRSQn1.png"></p><p>在<code>simulation name</code>栏中，填写你的仿真名称；<br>在<code>radio medium</code>下拉选项中，选择<code>directed graph radio medium(DGRM)</code><br>点击<code>creat</code>按钮，创建仿真工程。<br><img src="https://s2.ax1x.com/2020/01/08/lRpP8e.png" alt="lRpP8e.png"></p><p>创建的new simulation将打开多个窗口，如下所示。<br><img src="https://s2.ax1x.com/2020/01/08/lRpn58.png" alt="lRpn58.png"></p><ul><li>添加sink mote</li></ul><p>添加类型为Sink的mote。<br><img src="https://s2.ax1x.com/2020/01/08/lRp0xJ.png" alt="lRp0xJ.png"></p><p>这里使用了来自rpl-collect示例(/examples/ipv6/rpl-collect/)的udp-sink.c代码。<br>但是，您可以根据应用程序上传任何想要实现的代码。<br>单击<code>Compile</code>按钮。<br><img src="https://s2.ax1x.com/2020/01/08/lRpHdP.png" alt="lRpHdP.png"></p><p>在成功编译时，将出现一个创建按钮，该按钮可根据需要在网络中添加更多的mote。这里只添加1个sink节点。<br><img src="https://s2.ax1x.com/2020/01/08/lR9PoV.png" alt="lR9PoV.png"></p><ul><li>添加其他sender motes<br>添加其他类型的mote。<br>这里使用的是来自rpl-collect示例(/examples/ipv6/rpl-collect/)的udp-sender.c代码。<br>但是，您可以根据应用程序上传任何想要实现的代码。<br><img src="https://s2.ax1x.com/2020/01/08/lR9vtK.png" alt="lR9vtK.png"><br>编译代码并根据拓扑结构创建许多这种类型的motes。<br><img src="https://s2.ax1x.com/2020/01/08/lRiKwn.png" alt="lRiKwn.png"><br><img src="https://s2.ax1x.com/2020/01/08/lRi3WT.png" alt="lRi3WT.png"></li></ul><p><strong>注意</strong>:mote的位置在这里并不重要。你可以把你的motes放在图表的任何地方。由于这与距离模型不同，我们在motes之间建立了明确的通信联系，因此它们之间的距离没有区别。</p><ul><li>添加communication links</li></ul><p>在每组节点之间添加两个通信链路，使通信可以是双向的。</p><p>选择<code>tools-&gt;DGRM Links...</code>这将打开一个DGRM配置器对话框。<br><img src="https://s2.ax1x.com/2020/01/08/lRFm9K.png" alt="lRFm9K.png"></p><p>单击<code>Add</code>.选择<code>source</code>和<code>destination</code>，然后再次单击<code>Add</code>。这将添加一个从源节点到目标节点的单向链接。对于双向链接，您需要添加一个带有交换的源节点和目标节点的链接。您可以通过这种方式添加多个链接。添加链接后关闭对话框。<br><img src="https://s2.ax1x.com/2020/01/08/lRFcCV.png" alt="lRFcCV.png"><br>您可以根据您的应用程序更改链接的其他参数，如RX radio、RSSI、LQI和delay。这些参数会影响单个链接的质量。RX radio影响ETX值。<br>因此，要在各种链接质量条件下测试应用程序时，可以更改这些参数。</p><p>您还可以使用remove选项删除一个现有的。<br>Import选项有助于导入已经在其中指定了这些链接连接和参数的任何数据文件。</p><ul><li>运行仿真</li></ul><p>使用simulation control窗口中的Start选项运行仿真。<br>这将启动mote，并且分配给所有的mote一个新的rime地址和其他初始化过程。<br><img src="https://s2.ax1x.com/2020/01/08/lRkzyF.png" alt="lRkzyF.png"></p><ul><li>Watch Output</li></ul><ol><li>motes输出和调试消息可以在Motes Output窗口中看到。</li><li>可以根据节点ID:node_id对输出进行筛选，以监视特定的节点。</li><li>还可以通过过滤来查看特定的调试消息。</li><li>Motes output中其他有用功能是file,edit和view。<br> File选项有助于将输出保存到文件中。<br> Edit具有复制输出的选项 — 完整的或特定选定的消息。</li><li>您还可以使用Clear all messages选项来清除消息。</li><li>使用这些保存在文件中的信息，根据您的实验目标进行观察并绘制图形。</li></ol><h2 id="7-温馨提醒"><a href="#7-温馨提醒" class="headerlink" title="7.温馨提醒"></a>7.温馨提醒</h2><p>在运行cooja时，一定要以sudo ant的方式运行，因为只运行ant可能会抛出一些错误，因为它可能无法访问某些文件。<br>如果网络很大或ETX值很大，则来自叶节点的数据包可能需要一段时间才能到达根节点。<br>因此，您可能需要长时间地运行模拟。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://tools.ietf.org/html/rfc6550" target="_blank" rel="noopener">RFC 6550</a> RPL: IPv6 Routing Protocol for Low-Power and Lossy Networks</li><li><a href="https://tools.ietf.org/html/rfc6552" target="_blank" rel="noopener">RFC 6552</a> Objective Function Zero for the Routing Protocol for Low-Power and Lossy Networks (RPL)</li><li><a href="https://tools.ietf.org/html/rfc6719" target="_blank" rel="noopener">RFC 6719</a> MRHOF: The Minimum Rank with Hysteresis Objective Function </li><li><a href="http://dunkels.com/adam/ko11contikirpl.pdf" target="_blank" rel="noopener">ContikiRPL and TinyRPL: Happy Together</a></li><li><a href="https://github.com/contiki-ng/contiki-ng/wiki/Documentation:-RPL" target="_blank" rel="noopener">Documentation: RPL</a></li><li><a href="https://github.com/contiki-ng/contiki-ng/wiki/Tutorial:-RPL" target="_blank" rel="noopener">Tutorial: RPL</a></li></ol><hr><p>此文翻译的是链接 <a href="https://blog.csdn.net/frank_jb/article/details/50912306" target="_blank" rel="noopener">https://blog.csdn.net/frank_jb/article/details/50912306</a> 的内容</p><hr>]]></content>
      
      
      <categories>
          
          <category> contiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> contiki </tag>
            
            <tag> cooja </tag>
            
            <tag> RPL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu sublime的安装与卸载教程</title>
      <link href="/2020/01/05/sublime%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/"/>
      <url>/2020/01/05/sublime%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="install"><a href="#install" class="headerlink" title="install"></a>install</h1><ol><li><p>添加sublime text3的仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team&#x2F;sublime-text-3</span><br></pre></td></tr></table></figure><p>中间如需要等待的时候直接按<code>enter</code>就行。（建立信任数据库）</p></li><li><p>更新软件库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>安装sublime text3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install sublime-text-installer</span><br></pre></td></tr></table></figure></li></ol><p>通过以上三步，就可以将sublime text3安装完成~</p><h1 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h1><ol><li><p>查看一下sublime text3在系统中存在的程序名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep sublime</span><br></pre></td></tr></table></figure></li><li><p>按照上述方式安装的程序名为<code>sublime-text-installer</code>,则执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -r sublime-text-installer</span><br></pre></td></tr></table></figure></li><li><p>删除配置文件，其中<code>$username</code>为系统的用户名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf &#x2F;home&#x2F;$username&#x2F;.config&#x2F;sublime-text-3&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>查看系统中与sublime text 3相关的文件，然后再根据路径依次删除即可完全卸载掉sublime text 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find &#x2F; -name sublime*</span><br></pre></td></tr></table></figure></li><li><p>重复在终端输入删除命令，删除其他与Sublime Text3相关的全部文件,文件路径和名称 为上面find命令查找到的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -r &#x2F;home&#x2F;long&#x2F;.local&#x2F;share&#x2F;Trash&#x2F;info&#x2F;sublime-text_build-3083_i386.deb.trashinfo</span><br></pre></td></tr></table></figure><p>…(重复rm  删除所有有关sublime的文件)…<br>…（完全卸载完成）…</p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置windows10上文档的背景底色</title>
      <link href="/2020/01/02/%E8%AE%BE%E7%BD%AEwindows10%E4%B8%8A%E6%96%87%E6%A1%A3%E7%9A%84%E8%83%8C%E6%99%AF%E5%BA%95%E8%89%B2/"/>
      <url>/2020/01/02/%E8%AE%BE%E7%BD%AEwindows10%E4%B8%8A%E6%96%87%E6%A1%A3%E7%9A%84%E8%83%8C%E6%99%AF%E5%BA%95%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-按windows-R打开命令提示符-并输入regedit进入注册表编辑器"><a href="#1-按windows-R打开命令提示符-并输入regedit进入注册表编辑器" class="headerlink" title="1.按windows+R打开命令提示符,并输入regedit进入注册表编辑器"></a>1.按<code>windows</code>+<code>R</code>打开命令提示符,并输入<code>regedit</code>进入注册表编辑器</h2><p><img src="https://s2.ax1x.com/2020/01/02/lYOLSP.png" alt="lYOLSP.png"></p><h2 id="2-根据下面的图片路径，找到window"><a href="#2-根据下面的图片路径，找到window" class="headerlink" title="2.根据下面的图片路径，找到window"></a>2.根据下面的图片路径，找到<code>window</code></h2><p><img src="https://s2.ax1x.com/2020/01/02/lYXB1P.png" alt="lYXB1P.png"></p><h2 id="3-双击两下打开window，并在窗口的数值数据一栏输入204-232-207"><a href="#3-双击两下打开window，并在窗口的数值数据一栏输入204-232-207" class="headerlink" title="3.双击两下打开window，并在窗口的数值数据一栏输入204 232 207"></a>3.双击两下打开<code>window</code>，并在窗口的数值数据一栏输入<code>204 232 207</code></h2><p><img src="https://s2.ax1x.com/2020/01/02/lYjCHe.png" alt="lYjCHe.png"></p><h2 id="4-点击确定"><a href="#4-点击确定" class="headerlink" title="4.点击确定"></a>4.点击确定</h2><h2 id="5-根据下面的路径，找到window"><a href="#5-根据下面的路径，找到window" class="headerlink" title="5.根据下面的路径，找到window"></a>5.根据下面的路径，找到<code>window</code></h2><p><img src="https://s2.ax1x.com/2020/01/02/lYv9x0.png" alt="lYv9x0.png"></p><h2 id="6-双击两下打开window，并在窗口的数值数据一栏输入caeace"><a href="#6-双击两下打开window，并在窗口的数值数据一栏输入caeace" class="headerlink" title="6.双击两下打开window，并在窗口的数值数据一栏输入caeace"></a>6.双击两下打开<code>window</code>，并在窗口的数值数据一栏输入<code>caeace</code></h2><p><img src="https://s2.ax1x.com/2020/01/02/lYvuxx.png" alt="lYvuxx.png"></p><h2 id="7-重启生效。"><a href="#7-重启生效。" class="headerlink" title="7.重启生效。"></a>7.重启生效。</h2><hr>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> color </tag>
            
            <tag> windows </tag>
            
            <tag> background </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下右键进入文件夹terminal</title>
      <link href="/2020/01/02/linux%E4%B8%8B%E5%8F%B3%E9%94%AE%E8%BF%9B%E5%85%A5terminal/"/>
      <url>/2020/01/02/linux%E4%B8%8B%E5%8F%B3%E9%94%AE%E8%BF%9B%E5%85%A5terminal/</url>
      
        <content type="html"><![CDATA[<h2 id="1-按ctrl-alt-T键，进入终端"><a href="#1-按ctrl-alt-T键，进入终端" class="headerlink" title="1. 按ctrl+alt+T键，进入终端"></a>1. 按<code>ctrl</code>+<code>alt</code>+<code>T</code>键，进入终端</h2><h2 id="2-输入如下命令（安装插件）"><a href="#2-输入如下命令（安装插件）" class="headerlink" title="2. 输入如下命令（安装插件）"></a>2. 输入如下命令（安装插件）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nautilus-open-terminal</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnome-terminal</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/lY5Fbt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/01/02/lY5Fbt.png" alt="lY5Fbt.png"></a></p><h2 id="3-安装完毕后，会出现下面的画面"><a href="#3-安装完毕后，会出现下面的画面" class="headerlink" title="3. 安装完毕后，会出现下面的画面"></a>3. 安装完毕后，会出现下面的画面</h2><p><a href="https://imgchr.com/i/lY5YPU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/01/02/lY5YPU.png" alt="lY5YPU.png"></a></p><h2 id="4-退出终端，并打开文件浏览器"><a href="#4-退出终端，并打开文件浏览器" class="headerlink" title="4. 退出终端，并打开文件浏览器"></a>4. 退出终端，并打开文件浏览器</h2><h2 id="5-在你想要的目录下，右键点击open-in-terminal，即在终端打开。"><a href="#5-在你想要的目录下，右键点击open-in-terminal，即在终端打开。" class="headerlink" title="5.在你想要的目录下，右键点击open in terminal，即在终端打开。"></a>5.在你想要的目录下，右键点击open in terminal，即在终端打开。</h2><p><strong>说明</strong>：可能需要重启一下才能右键看到这个。</p><p><img src="https://s2.ax1x.com/2020/01/02/lYoC7t.png" alt="lYoC7t.png"></p><h2 id="6-进入所需文件夹终端界面"><a href="#6-进入所需文件夹终端界面" class="headerlink" title="6.进入所需文件夹终端界面"></a>6.进入所需文件夹终端界面</h2><p><img src="https://s2.ax1x.com/2020/01/02/lYoeXj.png" alt="lYoeXj.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机和主机之间vmware tools的安装</title>
      <link href="/2020/01/02/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4vmware%20tools%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2020/01/02/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4vmware%20tools%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="1-打开终端，找到vmware-tools文件位置。"><a href="#1-打开终端，找到vmware-tools文件位置。" class="headerlink" title="1.打开终端，找到vmware tools文件位置。"></a>1.打开终端，找到<code>vmware tools</code>文件位置。</h2><p><img src="https://s2.ax1x.com/2020/01/02/lYqWfx.png" alt="lYqWfx.png"></p><h2 id="2-找到下面这个文件，并找出此文件的路径"><a href="#2-找到下面这个文件，并找出此文件的路径" class="headerlink" title="2.找到下面这个文件，并找出此文件的路径"></a>2.找到下面这个文件，并找出此文件的路径</h2><p><img src="https://s2.ax1x.com/2020/01/02/lYq36S.png" alt="lYq36S.png"></p><h2 id="3-打开终端，并输入"><a href="#3-打开终端，并输入" class="headerlink" title="3.打开终端，并输入"></a>3.打开终端，并输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp VMwareTools-10.1.6-5214329.tar.gz &#x2F;tmp</span><br><span class="line">cd &#x2F;tmp</span><br><span class="line">tar -xzvf VMwareTools-10.1.6-5214329.tar.gz</span><br><span class="line">cd vmware-tools-distrib&#x2F;</span><br><span class="line">.&#x2F;vmware-install.pl</span><br></pre></td></tr></table></figure><h2 id="4-完成测试。（如果仍然无法复制，重启虚拟机）"><a href="#4-完成测试。（如果仍然无法复制，重启虚拟机）" class="headerlink" title="4.完成测试。（如果仍然无法复制，重启虚拟机）"></a>4.完成测试。（如果仍然无法复制，重启虚拟机）</h2><hr>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建的博客 - 优化篇</title>
      <link href="/2019/12/24/hexo%20%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E7%AF%87/"/>
      <url>/2019/12/24/hexo%20%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="1-搭建基本hexo博客"><a href="#1-搭建基本hexo博客" class="headerlink" title="1. 搭建基本hexo博客"></a>1. 搭建基本hexo博客</h2><p><a href="http://wangwlj.com/2017/09/08/blog_setup/#more" target="_blank" rel="noopener">→点这里←</a>有详细的教程，我就不在重复叙述了。</p><h2 id="2-hexo博客绑定域名"><a href="#2-hexo博客绑定域名" class="headerlink" title="2. hexo博客绑定域名"></a>2. hexo博客绑定域名</h2><p><a href="https://www.jianshu.com/p/cea41e5c9b2a" target="_blank" rel="noopener">→点这里←</a>有详细的教程，我也不再重复说明了。</p><h2 id="3-设置Hexo主题模式"><a href="#3-设置Hexo主题模式" class="headerlink" title="3. 设置Hexo主题模式"></a>3. 设置Hexo主题模式</h2><p>在Hexo主题中，有四种不同的模式，通过切换模式，让你的主题显示不一样的样式。（有些主题没有这种设置）<br>在themes根目录下有一个同样名称为_config.yml，为了区分hexo根目录下的_config.yml，将前者称为主题配置文件 ，在其中找到scheme属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure><p>主题默认使用Muse模式，这里采用的是Pisces模式，读者可根据自己的喜好，选择其中一种模式。</p><h2 id="4-添加评论功能"><a href="#4-添加评论功能" class="headerlink" title="4. 添加评论功能"></a>4. 添加评论功能</h2><p><a href="http://wangwlj.com/2017/12/18/blog_comment/" target="_blank" rel="noopener">→点这里←</a>有详细的教程，我也不再重复说明了。</p><h2 id="5-设置网站图标"><a href="#5-设置网站图标" class="headerlink" title="5. 设置网站图标"></a>5. 设置网站图标</h2><p>打开<strong>主题配置文件</strong> ，找到以下字段，进行相应的修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">favicon: &#x2F;favicon.png</span><br></pre></td></tr></table></figure><p>其中，图片favicon.jpg存放在<code>hexo-site/source/</code>目录下。</p><h2 id="6-友情链接"><a href="#6-友情链接" class="headerlink" title="6. 友情链接"></a>6. 友情链接</h2><p>复制<code>theme/**/_source/</code>目录下<code>links</code>文件夹到站点的<code>/source/</code>目录下</p><p>在<code>hexo</code>目录下的<code>source</code>文件夹内创建一个名为<code>_data</code>（禁止改名）的文件夹。</p><p>然后在文件内创建一个名为<code>links.yml</code>的文件,在其中添加相关数据即可。</p><p>单个友情链接的格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name:&#x2F;&#x2F;将 Name 改为友情链接的名字，例如 Cofess</span><br><span class="line">    link: http:&#x2F;&#x2F;example.com &#x2F;&#x2F;友情链接的地址</span><br><span class="line">    avatar: http:&#x2F;&#x2F;example.com&#x2F;avatar.png &#x2F;&#x2F; 友情链接的头像</span><br><span class="line">    desc: &quot;这是一个描述&quot;&#x2F;&#x2F;友情链接描述</span><br></pre></td></tr></table></figure><h2 id="7-文章启用目录索引"><a href="#7-文章启用目录索引" class="headerlink" title="7. 文章启用目录索引"></a>7. 文章启用目录索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">categories:</span><br><span class="line">  - 文章分类</span><br><span class="line">tags:</span><br><span class="line">  - 文章标签</span><br><span class="line">toc: true  #是否启用内容索引</span><br></pre></td></tr></table></figure><h2 id="8-放一只萌宠到自己的博客吧"><a href="#8-放一只萌宠到自己的博客吧" class="headerlink" title="8.放一只萌宠到自己的博客吧~"></a>8.放一只萌宠到自己的博客吧~</h2><p>（1）获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>（2）选择自己喜欢的萌妹子<br>这里可以查看一些萌宠的预览图，快来选择你喜欢的妹子造型吧~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">live2d-widget-model-chitose</span><br><span class="line">live2d-widget-model-epsilon2_1</span><br><span class="line">live2d-widget-model-gf</span><br><span class="line">live2d-widget-model-haru&#x2F;01 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haru&#x2F;02 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haruto</span><br><span class="line">live2d-widget-model-hibiki</span><br><span class="line">live2d-widget-model-hijiki</span><br><span class="line">live2d-widget-model-izumi</span><br><span class="line">live2d-widget-model-koharu</span><br><span class="line">live2d-widget-model-miku</span><br><span class="line">live2d-widget-model-ni-j</span><br><span class="line">live2d-widget-model-nico</span><br><span class="line">live2d-widget-model-nietzsche</span><br><span class="line">live2d-widget-model-nipsilon</span><br><span class="line">live2d-widget-model-nito</span><br><span class="line">live2d-widget-model-shizuku</span><br><span class="line">live2d-widget-model-tororo</span><br><span class="line">live2d-widget-model-tsumiki</span><br><span class="line">live2d-widget-model-unitychan</span><br><span class="line">live2d-widget-model-wanko</span><br><span class="line">live2d-widget-model-z16</span><br></pre></td></tr></table></figure><p>（3）安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-miku &#x2F;&#x2F;live2d-widget-model-miku 是你喜欢的萌宠的名字</span><br></pre></td></tr></table></figure><p>（4）配置<br>在站点的<code>_config.yml</code>文件中，添加如下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  model:</span><br><span class="line">    use: &lt;你家萌宠的名字&gt;</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></table></figure><p>（5）保存并部署看效果。</p><h2 id="9-页面点击有小桃心技巧"><a href="#9-页面点击有小桃心技巧" class="headerlink" title="9.页面点击有小桃心技巧~"></a>9.页面点击有小桃心技巧~</h2><p>（1）在<code>/themes/**/source/js</code>下新建文件<code>clicklove.js</code>文件</p><p>（2）把下面的代码粘贴到<code>clicklove.js</code>文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e&#x3D;0;e&lt;d.length;e++)d[e].alpha&lt;&#x3D;0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+&#x3D;.004,d[e].alpha-&#x3D;.013,d[e].el.style.cssText&#x3D;&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t&#x3D;&quot;function&quot;&#x3D;&#x3D;typeof e.onclick&amp;&amp;e.onclick;e.onclick&#x3D;function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a&#x3D;t.createElement(&quot;div&quot;);a.className&#x3D;&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a&#x3D;t.createElement(&quot;style&quot;);a.type&#x3D;&quot;text&#x2F;css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText&#x3D;e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d&#x3D;[];e.requestAnimationFrame&#x3D;function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3&#x2F;60)&#125;&#125;(),n()&#125;(window,document);</span><br></pre></td></tr></table></figure><p>（3）在<code>/themes/**/layout/_layout.ejs</code>文件<strong>末尾</strong>添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;clicklove.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>（4）成功，本地调试一下吧~</p><hr>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Copper for Chrome (Cu4Cr) CoAP user-agent</title>
      <link href="/2019/12/20/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E8%A3%85CoAP%E8%B0%83%E8%AF%95%E5%AE%A2%E6%88%B7%E7%AB%AFCopper%E6%8F%92%E4%BB%B6/"/>
      <url>/2019/12/20/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E8%A3%85CoAP%E8%B0%83%E8%AF%95%E5%AE%A2%E6%88%B7%E7%AB%AFCopper%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h1><p>好像火狐浏览器56版本之后不在支持Copper插件，所以本文讲一下在谷歌浏览器中安装Copper插件。<br>本篇也为那本书中“IPv6无线传感器网络：开发与实践”的5.8小节做基础。</p><h1 id="获取Copper4Crr插件"><a href="#获取Copper4Crr插件" class="headerlink" title="获取Copper4Crr插件"></a>获取Copper4Crr插件</h1><ol><li><p>把Copper4Crr工具克隆到本地。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;mkovatsc&#x2F;Copper4Cr.git</span><br></pre></td></tr></table></figure><p>或者点击如下链接：<a href="https://github.com/mkovatsc/Copper4Cr.git" target="_blank" rel="noopener">https://github.com/mkovatsc/Copper4Cr.git</a></p></li><li><p>在windows环境下，运行install.bat文件。<br><img src="https://s2.ax1x.com/2019/12/20/QL7bB6.png" alt="QL7bB6.png"></p></li></ol><h1 id="安装Copper插件"><a href="#安装Copper插件" class="headerlink" title="安装Copper插件"></a>安装Copper插件</h1><ol><li><p>打开谷歌浏览器，输入网址“chrome://extensions/”。</p></li><li><p>打开谷歌浏览器开发者模式。<br><img src="https://s2.ax1x.com/2019/12/20/QLHxaT.png" alt="QLHxaT.png"></p></li><li><p>点击“加载已解压的扩展程序”，选择代码仓库中app文件夹。</p></li><li><p>再点击“加载已解压的扩展程序”，选择代码仓库中extension文件夹。</p></li><li><p>正确安装后，可看到如下的相似界面。<br><img src="https://s2.ax1x.com/2019/12/20/QO9rIs.png" alt="QO9rIs.png"><br><img src="https://s2.ax1x.com/2019/12/20/QO96Gq.png" alt="QO96Gq.png"></p></li><li><p>复制Copper(Cu4Cr) Application 0.1.0中ID编号。<br>找到Copper4Cr代码仓库中的”extension/endpoint/ClientPortChrome.js”文件。</p></li><li><p>把上一步复制的ID编号覆盖ClientPortChrome.js中的appId。<br><img src="https://s2.ax1x.com/2019/12/20/QOC9JI.png" alt="QOC9JI.png"></p></li></ol><p>插件安装完成~</p><h1 id="简单测试一下"><a href="#简单测试一下" class="headerlink" title="简单测试一下"></a>简单测试一下</h1><ol><li><p>点击谷歌右上角的Cu标记，进入Copper插件后，输入CoAP地址资源，例如“coap://wsncoap.org/test”（假的）<br><img src="https://s2.ax1x.com/2019/12/20/QOCNk9.png" alt="QOCNk9.png"></p></li><li><p>点击操作按钮GET可获得以下类似界面。<br><img src="https://s2.ax1x.com/2019/12/20/QOConS.png" alt="QOConS.png"></p></li></ol><h1 id="说明一下"><a href="#说明一下" class="headerlink" title="说明一下"></a>说明一下</h1><p>在Chrome浏览器中使用Copper插件，不能在浏览器地址栏修改CoAP资源地址。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CoAP </tag>
            
            <tag> Copper </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件研发面试题汇总</title>
      <link href="/2019/09/21/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2019/09/21/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是预编译？何时需要预编译？"><a href="#1-什么是预编译？何时需要预编译？" class="headerlink" title="1.什么是预编译？何时需要预编译？"></a>1.什么是预编译？何时需要预编译？</h2><p><strong>什么是预编译：</strong><br>1）预编译又称为预处理，是做些代码文本的替换工作；<br>2）处理以 # 开头的指令，比如拷贝 #include 包含的文件代码， #define 宏定义的替换， 条件编译等， 就是为编译做的预备工作的阶段。<br>3）主要处理 # 开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。<br>4）C编译系统在对程序进行通常的编译之前，首先进行预处理。</p><p><strong>何时需要预编译：</strong><br>1）总是使用不经常改动的大型代码体；<br>2）程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个“预编译头”.</p><h2 id="2-char-const-p-char-const-p-const-char-p-这三者有什么区别？"><a href="#2-char-const-p-char-const-p-const-char-p-这三者有什么区别？" class="headerlink" title="2.char * const p ; char const * p ; const char * p  这三者有什么区别？"></a>2.char * const p ; char const * p ; const char * p  这三者有什么区别？</h2><h2 id="3-求输出结果"><a href="#3-求输出结果" class="headerlink" title="3. 求输出结果"></a>3. 求输出结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char str1[] &#x3D; &quot;abc&quot;;</span><br><span class="line">char str2[] &#x3D; &quot;abc&quot;;</span><br><span class="line">const char str3[] &#x3D; &quot;abc&quot;;</span><br><span class="line">const char str4[] &#x3D; &quot;abc&quot;;</span><br></pre></td></tr></table></figure><p><strong>上面是数组变量，他们有各自的内存空间</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const char * str5 &#x3D; &quot;abc&quot;;</span><br><span class="line">const char * str6 &#x3D; &quot;abc&quot;;</span><br><span class="line">char * str7 &#x3D; &quot;abc&quot;;</span><br><span class="line">char * str8 &#x3D; &quot;abc&quot;;</span><br></pre></td></tr></table></figure><p><strong>上面的指针指向相同的常量地址区域</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (str1 &#x3D;&#x3D; str2) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (str3 &#x3D;&#x3D; str4) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>所以数组变量的地址不一样</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (str5 &#x3D;&#x3D; str6) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (str7 &#x3D;&#x3D; str8) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>所以指针的地址是一样的</strong></p><p><strong>结果是： 0 0 1 1</strong></p><h2 id="4-请问下面的代码有什么问题"><a href="#4-请问下面的代码有什么问题" class="headerlink" title="4.请问下面的代码有什么问题?"></a>4.请问下面的代码有什么问题?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char a;</span><br><span class="line">char *str &#x3D; &amp;a;</span><br><span class="line">strcpy(str,&quot;hello&quot;);</span><br><span class="line">printf(str);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：没有为str分配内存空间，将会发生异常。<br>问题出在，将一个字符串复制进一个字符变量指针所指地址，虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。<br>就是说，你给了指针一个地址，但是这个地址长度不一定够，所以会越界，越界就会产生segmentation fault。</p><h2 id="5-代码有何问题？"><a href="#5-代码有何问题？" class="headerlink" title="5.代码有何问题？"></a>5.代码有何问题？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char * s &#x3D; &quot;AAA&quot;;</span><br><span class="line">printf(&quot;%s&quot;,s);</span><br><span class="line"></span><br><span class="line">s[0] &#x3D; &#39;B&#39;;</span><br><span class="line">printf(&quot;%s&quot;,s);</span><br></pre></td></tr></table></figure><p>有什么错？</p><p>“AAA”是字符串常量。<br>s是指针，指向这个字符串常量，所以声明s的时候就有问题。<br>应该为：const char * s = “AAA”;</p><p>然后又因为是常量，所以对s[0]的赋值操作是不合法的。</p><h2 id="6-如何用C语言编写死循环？"><a href="#6-如何用C语言编写死循环？" class="headerlink" title="6.如何用C语言编写死循环？"></a>6.如何用C语言编写死循环？</h2><p>while(1){}<br>或<br>for(;;)</p><h2 id="7-new-和-malloc-的区别？"><a href="#7-new-和-malloc-的区别？" class="headerlink" title="7.new 和 malloc 的区别？"></a>7.new 和 malloc 的区别？</h2><p><strong>1） 申请内存所在的位置</strong><br>new 是 C++语言 从 <em>自由存储区</em> 为对象动态分配内存；<br>malloc 是 C语言 从 <em>堆</em> 上动态分配内存。</p><p><strong>2）返回类型安全性</strong><br>new操作符内存分配成功时，返回的是<em>对象类型的指针</em>，类型严格与对象匹配，无须进行类型转换，故new是符合<em>类型安全性</em>的操作符。<br>而malloc内存分配成功则是返回<em>void *  ，</em>需要通过强制类型转换将void * 指针转换成我们需要的类型。</p><p><strong>3）内存分配失败时的返回值</strong><br>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；<br>malloc分配内存失败时返回NULL。</p><p><strong>4)是否需要指定内存大小</strong><br>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算；<br>而malloc则需要显式地指出所需内存的尺寸。</p><p><strong>5)是否调用构造函数/析构函数</strong><br>使用new操作符来分配对象内存时会经历三个步骤：</p><ul><li>第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li><li>第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。</li><li>第三部：对象构造完成后，返回一个指向该对象的指针。</li></ul><p>使用delete操作符来释放对象内存时会经历两个步骤：</p><ul><li>第一步：调用对象的析构函数。</li><li>第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。</li></ul><p>总之来说，<br><strong>new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。</strong><br><strong>而malloc则不会。</strong></p><p><strong>6)对数组的处理</strong><br>C++提供了new[]与delete[]来专门处理数组类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A *ptr &#x3D; new A[10];&#x2F;&#x2F;分配10个对象</span><br></pre></td></tr></table></figure><p>使用new[]分配的内存必须使用delete[]进行释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete [] ptr;</span><br></pre></td></tr></table></figure><p>malloc，它并不知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。<br>所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * ptr &#x3D; (int *) malloc ( sizeof(int) * 10);&#x2F;&#x2F;分配一个10个int元素的数组</span><br></pre></td></tr></table></figure><p><strong>7)new 和 malloc 是否可以相互调用</strong><br>operator new /operator delete的实现可以基于malloc，<br>而malloc的实现不可以去调用new。</p><p><strong>8)是否可以被重载</strong><br><strong>opeartor new /operator delete可以被重载。</strong><br>标准库是定义了operator new函数和operator delete函数的8个重载版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这些版本可能抛出异常</span><br><span class="line">void * operator new(size_t);</span><br><span class="line">void * operator new[](size_t);</span><br><span class="line">void * operator delete (void * )noexcept;</span><br><span class="line">void * operator delete[](void *0）noexcept;</span><br><span class="line">&#x2F;&#x2F;这些版本承诺不抛出异常</span><br><span class="line">void * operator new(size_t ,nothrow_t&amp;) noexcept;</span><br><span class="line">void * operator new[](size_t, nothrow_t&amp; );</span><br><span class="line">void * operator delete (void *,nothrow_t&amp; )noexcept;</span><br><span class="line">void * operator delete[](void *0,nothrow_t&amp; ）noexcept;</span><br></pre></td></tr></table></figure><p><strong>malloc/free 并不允许重载。</strong></p><p><strong>9)能够直观地重新分配内存</strong><br>使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。<br>realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</p><p>new没有这样直观的配套设施来扩充内存</p><p><strong>10)客户处理内存分配不足</strong><br>在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace std</span><br><span class="line">&#123;</span><br><span class="line">    typedef void (*new_handler)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace std</span><br><span class="line">&#123;</span><br><span class="line">    new_handler set_new_handler(new_handler p ) throw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。</p><p>对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。</p><p><strong>11)属性不同</strong><br>new/delete是C++关键字，需要编译器支持。<br>malloc/free是库函数，需要头文件支持。</p><h2 id="8-堆和栈的区别"><a href="#8-堆和栈的区别" class="headerlink" title="8.堆和栈的区别"></a>8.堆和栈的区别</h2><p><strong>1）程序的内存分配方式不同</strong><br>堆（heap）:需要<strong>程序员自己申请</strong>，<strong>自己释放</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;C中使用malloc函数申请</span><br><span class="line">char * p1 &#x3D; (char *)malloc(10);</span><br><span class="line">cout &lt;&lt; (int *)p &lt;&lt; endl;&#x2F;&#x2F;输出：00000000003BA0C0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用free()释放</span><br><span class="line">free(p1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++中用new运算符申请</span><br><span class="line">char p2 &#x3D; new char[10];</span><br><span class="line">cout &lt;&lt; (int *)p2 &lt;&lt; endl;&#x2F;&#x2F;输出：00000000003BA0C0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用delete运算符释放</span><br><span class="line">delete[] p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中p1所指的10字节的内存空间与p2所指的10字节内存空间都是存在于堆的。堆的内存地址生长方向与栈相反，<strong>由低到高</strong>，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，即p2指向的地址并不一定大于p1所指向的内存地址，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。堆中存储的数据的若未释放，则其生命周期等同于程序的生命周期。</p><p>栈（stack）：<strong>编译器自动分配释放</strong>。<br>用来存放函数的参数值，局部变量的值等，其操作方式类似于数据结构的栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int b;&#x2F;&#x2F;栈</span><br><span class="line">char s[] &#x3D; &quot;abc&quot;;&#x2F;&#x2F;栈</span><br><span class="line">char *p2;&#x2F;&#x2F;栈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。栈的内存地址生长方向与堆相反，<strong>由高到底</strong>，所以<strong>后定义的变量地址低于先定义的变量</strong>，比如上面代码中变量s的地址小于变量b的地址，p2地址小于s的地址。栈中存储的数据的生命周期随着函数的执行完成而结束。</p><p><strong>2）申请后的响应时间不同</strong><br>堆：首先应该知道操作系统有一个记录内存地址的链表，当系统收到程序的申请时，遍历该链表，寻找第一个空间大于所申请的空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的 delete 或 free 语句就能够正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会将多余的那部分重新放入空闲链表中。</p><p>栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p><p><strong>3）申请的大小限制不同</strong><br>堆：堆是<strong>向高地址扩展</strong>的数据结构，是<strong>不连续的内存区域</strong>，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有<strong>效虚拟内存空间</strong>，由此空间，<strong>堆获得的空间比较灵活，也比较大</strong>。</p><p>栈：在 windows 下，栈是<strong>向低地址扩展</strong>的数据结构，是一块<strong>连续的内存区域</strong>，栈顶的地址和栈的最大容量是系统预先规定好的，能从<strong>栈获得的空间较小</strong>。<br>栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量。</p><p><strong>4）申请的效率不同</strong><br>堆：堆是有程序员自己分配，<strong>速度较慢</strong>，<strong>容易产生碎片</strong>，<strong>不过用起来方便</strong>。</p><p>栈：栈由系统自动分配，<strong>速度快</strong>，但是<strong>程序员无法控制</strong>。</p><p><strong>5）堆和栈的存储内容不同</strong><br>堆：<strong>一般是在堆的头部用一个字节存放堆的大小</strong>，而堆中具体存放内容是由程序员来填充的。</p><p>栈：栈存放的内容，<strong>函数返回地址</strong>、<strong>相关参数</strong>、<strong>局部变量</strong>和<strong>寄存器内容</strong>等。</p><h2 id="9-指针与引用的区别"><a href="#9-指针与引用的区别" class="headerlink" title="9.指针与引用的区别"></a>9.指针与引用的区别</h2><p>1）指针是一个<strong>实体</strong>，<br>   引用只是一个<strong>别名</strong>；<br>2）指针<strong>需要解引用</strong>，<br>   引用<strong>无需解引用</strong>；<br>3）引用只能在定义时被初始化一次，之后<strong>不可变</strong>，<br>   指针<strong>可变</strong>；<br>4）指针<strong>有const</strong>，const的指针不可变，<br>   引用<strong>没有const</strong>；<br>5）指针<strong>可以为空</strong>，<br>   引用<strong>不能为空</strong>；<br>6）“sizeof(引用)” 得到的是 <strong>所指向的变量（对象）的大小</strong>，<br>   而“sizeof(指针)”得到的是指针本身（所指向的变量或对象的地址）的大小；<br>7）指针和引用的自增（++）运算意义不一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用是C++中的概念，初学者容易把引用和指针混淆在一起。以下程序中，n是m的一个引用（reference），m是被引用物（referent）。</span><br></pre></td></tr></table></figure><p>int m;<br>int &amp;n = m;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n 相当于 m 的别名(绰号)，对 n 的任何操作就是对 m 的操作。例如，有个人叫尹小丹，他的绰号是“仙女”。说“仙女”怎么怎么样，其实就是对尹小丹说三道四。所以，n 既不是 m 的拷贝，也不是指向 m 的指针，其实 n 就是 m 他自己。</span><br></pre></td></tr></table></figure><p>int i = 5;<br>int j = 6;<br>int &amp;k = i;<br>k = j;    //k和i的值都变成了6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以上示例中，k 被初始化为 i 的引用。 语句 k &#x3D; j并不能将 k 修改成为 j 的引用， 只是把 k 的值改变成为 6 。由于 k 是 i 的引用，所以 i 的值也变成了 6。</span><br><span class="line"></span><br><span class="line">C++语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。</span><br><span class="line">**a)以下是“值传递”的示例程序。**</span><br></pre></td></tr></table></figure><p>void func1(int x)<br>{<br>    x = x + 10;<br>}<br>int n = 0;<br>func1(n);<br>cout &lt;&lt; “n = “ &lt;&lt; n &lt;&lt; endl;    //输出：n = 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于func1()函数体内的x是外部变量n的一份拷贝，改变x的值不会影响n，所以n的值仍然是0。</span><br><span class="line"></span><br><span class="line">**b)以下是“指针传递”的示例程序。**</span><br></pre></td></tr></table></figure><p>void func2(int <em>x)<br>{<br>    (</em>x) = (*x) + 10;<br>}<br>int n = 0;<br>func2(&amp;n);<br>cout &lt;&lt; “n = “ &lt;&lt; n &lt;&lt; endl;    //输出：n = 10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于func2()函数体内的x是指向外部变量n的指针，改变该指针的内容将导致n的值改变，所以n的值成为10.</span><br><span class="line"></span><br><span class="line">**c)以下是“引用传递”的示例程序。**</span><br></pre></td></tr></table></figure><p>void func3(int &amp;x)<br>{<br>    x = x + 10;<br>}<br>int n = 0;<br>func3(n);<br>cout &lt;&lt; “n = “ &lt;&lt; n &lt;&lt; endl;    //输出：n = 10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于func3()函数体内的x是外部变量n的引用，x和n是同一个东西，改变x等于改变n，所以n的值成为10.</span><br><span class="line"></span><br><span class="line">## 10.以下四行代码的区别是什么？</span><br></pre></td></tr></table></figure><p>const char * arr = “123”;<br>char * brr = “123”;<br>const char crr[] = “123”<br>char drr[] = “123”;</p><p><del>~</del><br>参考回答：<br><strong>const char * arr = “123”；</strong><br>字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果不一样。</p><p><strong>char * brr = “123”</strong><br>字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改“123”的值。</p><p><strong>const char crr[] = “123”;</strong><br>这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区。</p><p><strong>char drr[] = “123”；</strong><br>字符串123保存在栈区，可以通过drr去修改。</p><h2 id="11-C-的内存管理"><a href="#11-C-的内存管理" class="headerlink" title="11.C++的内存管理"></a>11.C++的内存管理</h2><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。<br><strong>代码段(text segment)：</strong>包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。<br><strong>数据段(data segment)：</strong>存储程序中已初始化的全局变量和静态变量。<br><strong>BBS段(bss segment)：</strong>存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。<br><strong>堆区(heap)：</strong>调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。<br><strong>映射区(memory mepping segment)：</strong>存储动态链接库以及调用mmap函数进行的文件映射。<br><strong>栈区(stack)：</strong>使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，linux可以通过ulimit命令指定。</p><h2 id="12-什么是内存泄漏"><a href="#12-什么是内存泄漏" class="headerlink" title="12.什么是内存泄漏"></a>12.什么是内存泄漏</h2><pre><code>内存泄漏（memory leak）是指由于疏忽或错误造成了程序未能释放掉、不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</code></pre><p><strong>内存泄漏的分类：</strong></p><ul><li><p>堆内存泄漏（heap leak）。堆内存指的是程序运行中根据需要分配通过malloc,realloc，new等堆中分配的一块内存，再是完成后必须通过调用对应的free或者delete删掉。如果程序的设计的错误导致这部分内存没有被释放掉，那么此后这块内存将不会被使用，就会产生heap leak.</p></li><li><p>系统资源泄露（resource leak）。主要指程序使用系统分配的资源比如bitmap,handle,socket等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致西戎效能降低，系统运行不稳定。</p></li><li><p>没有将基类的析构函数定义为虚函数。 当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确被释放，因此造成内存泄漏。</p></li></ul><h2 id="13"><a href="#13" class="headerlink" title="13."></a>13.</h2>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> software devolopment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试工程师面试题</title>
      <link href="/2019/09/19/Test%20position%20%EF%BC%88interview%20question%EF%BC%89/"/>
      <url>/2019/09/19/Test%20position%20%EF%BC%88interview%20question%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="测试的基础知识"><a href="#测试的基础知识" class="headerlink" title="测试的基础知识"></a>测试的基础知识</h1><h2 id="1-你在测试中发现了一个bug，但是开发经理认为这不是一个bug，你应该怎样解决？"><a href="#1-你在测试中发现了一个bug，但是开发经理认为这不是一个bug，你应该怎样解决？" class="headerlink" title="1.你在测试中发现了一个bug，但是开发经理认为这不是一个bug，你应该怎样解决？"></a>1.你在测试中发现了一个bug，但是开发经理认为这不是一个bug，你应该怎样解决？</h2><p>首先，将问题提交到缺陷管理库里面进行备案。</p><p>然后，要获取判断的依据和标准：</p><p>根据需求说明书、产品说明、设计文档等，确认实际结果是否与计划有不一致的地方，提供缺陷是否确认的直接依据；<br>如果没有文档依据，可以根据类似软件的一般特性来说明是否存在不一致的地方，来确认是否是缺陷；<br>根据用户的一般使用习惯，来确认是否是缺陷；<br>与设计人员、开发人员和客户代表等相关人员探讨，确认是否是缺陷；<br>合理的论述，向测试经理说明自己的判断的理由，注意客观、严谨，不参杂个人情绪。</p><p>等待测试经理做出最终决定，如果仍然存在争议，可以通过公司政策所提供的渠道，向上级反映，并有上级做出决定。</p><h2 id="2-如何测试网站？"><a href="#2-如何测试网站？" class="headerlink" title="2. 如何测试网站？"></a>2. 如何测试网站？</h2><p>首先，查找需求说明、网站设计等相关文档，分析测试需求。<br>制定测试计划，确定测试范围和测试策略，一般包括以下几个部分：功能性测试；界面测试；性能测试；数据库测试；安全性测试；兼容性测试</p><p><strong>设计测试用例如下：</strong></p><p><strong>（1）功能性测试</strong>可以包括，但不限于以下几个方面：<br><strong>链接测试。</strong><br>链接是否正确跳转，是否存在空页面和无效页面，是否有不正确的出错信息返回。<br>提交功能的测试。<br>多媒体元素是否可以正确加载和显示。<br>多语言支持是否能够正确显示选择的语言等。</p><p><strong>（2）界面测试</strong>可以包括但不限于一下几个方面：<br>页面是否风格统一，美观<br>页面布局是否合理，重点内容和热点内容是否突出<br>控件是否正常使用<br>对于必须但未安装的控件，是否提供自动下载并安装的功能<br>文字检查</p><p><strong>（3）性能测试</strong>一般从以下两个方面考虑：<br><strong>1）压力测试；<br>  2）负载测试；<br>  3）强度测试。</strong></p><p><strong>（4）数据库测试</strong>要具体决定是否需要开展。<br>数据库一般需要考虑连结性，对数据的存取操作，数据内容的验证等方面。</p><p><strong>（5）安全性测试：</strong><br>基本的登录功能的检查<br>是否存在溢出错误，导致系统崩溃或者权限泄露<br>相关开发语言的常见安全性问题检查，例如SQL注入等<br>如果需要高级的安全性测试，确定获得专业安全公司的帮助，外包测试，或者获取支持</p><p><strong>（6）兼容性测试</strong>根据需求说明的内容，确定支持的平台组合：<br>浏览器的兼容性；<br>操作系统的兼容性；<br>软件平台的兼容性；<br>数据库的兼容性。</p><p>开展测试，并记录缺陷。<br>合理的安排调整测试进度，提前获取测试所需的资源，建立管理体系（例如，需求变更、风险、配置、测试文档、缺陷报告、人力资源等内容）。<br>定期评审，对测试进行评估和总结，调整测试的内容。</p><h2 id="3-在搜索引擎中输入汉字就可以解析到对应的域名，请问如何用LoadRunner进行测试。"><a href="#3-在搜索引擎中输入汉字就可以解析到对应的域名，请问如何用LoadRunner进行测试。" class="headerlink" title="3.在搜索引擎中输入汉字就可以解析到对应的域名，请问如何用LoadRunner进行测试。"></a>3.在搜索引擎中输入汉字就可以解析到对应的域名，请问如何用LoadRunner进行测试。</h2><p>1）建立测试计划，确定测试标准和测试范围</p><p>2）设计典型场景的测试用例，覆盖常用业务流程和不常用的业务流程等</p><p>3）根据测试用例，开发自动测试脚本和场景：<br><strong>录制测试脚本：</strong>新建一个脚本（WebHTML协议）；点击录制按钮，在弹出的对话框的URL中输入”about:blank”；在打开的浏览器中进行正常操作流程后，结束录制；调试脚本并保存，可能要注意到字符集的关联。<br><strong>设置测试场景：</strong>针对性能设置测试场景，主要判断在正常情况下，系统的平均事务响应时间是否达标；针对压力负载设置测试场景，主要判断在长时间处于满负荷或者超出系统承载能力的条件下，系统是否会崩溃；执行测试，获取测试结果，分析测试结果。</p><h2 id="4-问：一台客户端有三百个客户与三百个客户端有三百个客户对服务器施压，有什么区别"><a href="#4-问：一台客户端有三百个客户与三百个客户端有三百个客户对服务器施压，有什么区别" class="headerlink" title="4.问：一台客户端有三百个客户与三百个客户端有三百个客户对服务器施压，有什么区别?"></a>4.问：一台客户端有三百个客户与三百个客户端有三百个客户对服务器施压，有什么区别?</h2><ul><li>300个用户在一个客户端上，会占用客户机更多的资源，而影响测试的结果。线程之间可能发生干扰，而产生一些异常。</li><li>300个用户在一个客户端上，需要更大的带宽。</li><li>IP地址的问题，可能需要使用IP Spoof来绕过服务器对于单一IP地址最大连接数的限制。</li><li>所有用户在一个客户端上，不必考虑分布式管理的问题；而用户分布在不同的客户端上，需要考虑使用控制器来整体调配不同客户机上的用户。同时，还需要给予相应的权限配置和防火墙设置。</li></ul><h2 id="5-什么是软件测试？软件测试的目的与原则"><a href="#5-什么是软件测试？软件测试的目的与原则" class="headerlink" title="5.什么是软件测试？软件测试的目的与原则"></a>5.什么是软件测试？软件测试的目的与原则</h2><p>在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。</p><p><strong>软件测试的目的：</strong></p><p>测试是程序的执行过程，目的在于发现错误<br>一个成功的测试用例在于发现至今未发现的错误<br>一个成功的测试是发现了至今未发现的错误的测试<br>确保产品完成了它所承诺或公布的功能，并且用户可以访问到的功能都有明确的书面说明。<br>确保产品满足性能和效率的要求<br>确保产品是健壮的和适应用户环境的</p><p><strong>软件测试的原则：</strong></p><p>测试用例中一个必须部分是对预期输出或接过进行定义<br>程序员应避免测试自己编写的程序<br>编写软件的组织不应当测试自己编写的软件<br>应当彻底检查每个测试的执行结果<br>测试用例的编写不仅应当根据有效和预料到的输入情况，而且也应当根据无效和未预料到的输入情况<br>检擦程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的”<br>应避免测试用例用后即弃，除非软件本身就是个一次性的软件<br>计划测试工作时不应默许假定不会发现错误<br>程序某部分存在更多错误的可能性，与该部分已经发现错误的数量成正比<br>软件测试是一项极富创造性，极具智力的挑战性的工作</p><h2 id="6-目前主要的测试用例设计方法是什么？"><a href="#6-目前主要的测试用例设计方法是什么？" class="headerlink" title="6.目前主要的测试用例设计方法是什么？"></a>6.目前主要的测试用例设计方法是什么？</h2><p>白盒测试：逻辑覆盖、循环覆盖、基本路径覆盖</p><p>黑盒测试：边界值分析法、等价类划分、错误猜测法、因果图法、状态图法、测试大纲法、随机测试、场景法</p><h2 id="7-软件的安全性应从哪几个方面去测试？"><a href="#7-软件的安全性应从哪几个方面去测试？" class="headerlink" title="7.软件的安全性应从哪几个方面去测试？"></a>7.软件的安全性应从哪几个方面去测试？</h2><p><strong>软件安全性测试包括程序、数据库安全性测试。根据系统安全指标不同测试策略也不同。</strong></p><p><strong>用户认证安全</strong>的测试要考虑问题： 明确区分系统中不同用户权限 、系统中会不会出现用户冲突 、系统会不会因用户的权限的改变造成混乱 、用户登陆密码是否是可见、可复制 、是否可以通过绝对途径登陆系统（拷贝用户登陆后的链接直接进入系统）、用户退出系统后是否删除了所有鉴权标记，是否可以使用后退键而不通过输入口令进入系统 、系统网络安全的测试要考虑问题 、测试采取的防护措施是否正确装配好，有关系统的补丁是否打上 、模拟非授权攻击，看防护系统是否坚固 、采用成熟的网络漏洞检查工具检查系统相关漏洞（即用最专业的黑客攻击工具攻击试一下，现在最常用的是 NBSI 系列和 IPhacker IP ） 、采用各种木马检查工具检查系统木马情况 、采用各种防外挂工具检查系统各组程序的外挂漏洞</p><p><strong>数据库安全</strong>考虑问题： 系统数据是否机密（比如对银行系统，这一点就特别重要，一般的网站就没有太高要求）、系统数据的完整性（我刚刚结束的企业实名核查服务系统中就曾存在数据 的不完整，对于这个系统的功能实现有了障碍） 、系统数据可管理性 、系统数据的独立性 、系统数据可备份和恢复能力（数据备份是否完整，可否恢复，恢复是否可以完整）</p><h2 id="8-什么是测试用例？什么是测试脚本？两者的关系是什么？"><a href="#8-什么是测试用例？什么是测试脚本？两者的关系是什么？" class="headerlink" title="8.什么是测试用例？什么是测试脚本？两者的关系是什么？"></a>8.什么是测试用例？什么是测试脚本？两者的关系是什么？</h2><p><strong>测试用例</strong> 是为实施测试而向被测试系统提供的输入数据、操作或各种环境设置以及期望结果的一个特定的集合。</p><p><strong>测试脚本</strong> 是为了进行自动化测试而编写的脚本。</p><p>测试脚本的编写必须对应相应的测试用例</p><h2 id="9-简述什么是静态测试、动态测试、黑盒测试、白盒测试、α测试-β测试"><a href="#9-简述什么是静态测试、动态测试、黑盒测试、白盒测试、α测试-β测试" class="headerlink" title="9.简述什么是静态测试、动态测试、黑盒测试、白盒测试、α测试 β测试"></a>9.简述什么是静态测试、动态测试、黑盒测试、白盒测试、α测试 β测试</h2><ul><li><strong>静态测试</strong>是不运行程序本身而寻找程序代码中可能存在的错误或评估程序代码的过程。  </li><li><strong>动态测试</strong>是实际运行被测程序，输入相应的测试实例，检查运行结果与预期结果的差异，判定执行结果是否符合要求，从而检验程序的正确性、可靠性和有效性，并分析系统运行效率和健壮性等性能。</li><li><strong>黑盒测试</strong>一般用来确认软件功能的正确性和可操作性,目的是检测软件的各个功能是否能得以实现,把被测试的程序当作一个黑盒,不考虑其内部结构,在知道该程序的输入和输出之间的关系或程序功能的情况下,依靠软件规格说明书来确定测试用例和推断测试结果的正确性。</li><li><strong>白盒测试</strong>根据软件内部的逻辑结构分析来进行测试,是基于代码的测试，测试人员通过阅读程序代码或者通过使用开发工具中的单步调试来判断软件的质量，一般黑盒测试由项目经理在程序员开发中来实现。</li><li><strong>α测试</strong>是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员或测试员完成。</li><li><strong>β测试</strong>是软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。</li></ul><h2 id="10-软件产品质量特性是什么"><a href="#10-软件产品质量特性是什么" class="headerlink" title="10.软件产品质量特性是什么?"></a>10.软件产品质量特性是什么?</h2><p><strong>功能性：</strong>适应性、准确性、互操作性、依从性、安全性。<br><strong>可靠性：</strong>成熟性、容错性、易恢复性。<br><strong>可使用性：</strong>易理解性、易学习性、易操作性。<br><strong>效率：</strong>时间特性、资源特性。<br><strong>可维护性：</strong>易分析性、易变更性、稳定性、易测试性。<br><strong>可移植性：</strong> 适应性、易安装性、遵循性、易替换性</p><h2 id="11-软件测试分为几个阶段-各阶段的测试策略和要求是什么"><a href="#11-软件测试分为几个阶段-各阶段的测试策略和要求是什么" class="headerlink" title="11.软件测试分为几个阶段 各阶段的测试策略和要求是什么?"></a>11.软件测试分为几个阶段 各阶段的测试策略和要求是什么?</h2><p>和开发过程相对应，测试过程会依次经历单元测试、集成测试、系统测试、验收测试四个主要阶段：</p><p><strong>1）单元测试：</strong>单元测试是针对软件设计的最小单位––程序模块甚至代码段进行正确性检验的测试工作，通常由开发人员进行。<br><strong>2）集成测试：</strong>集成测试是将模块按照设计要求组装起来进行测试，主要目的是发现与接口有关的问题。由于在产品提交到测试部门前，产品开发小组都要进行联合调试，因此在大部分企业中集成测试是由开发人员来完成的。<br><strong>3）系统测试：</strong>系统测试是在集成测试通过后进行的，目的是充分运行系统，验证各子系统是否都能正常工作并完成设计的要求。它主要由测试部门进行，是测试部门最大最重要的一个测试，对产品的质量有重大的影响。<br><strong>4）验收测试：</strong>验收测试以需求阶段的《需求规格说明书》为验收标准，测试时要求模拟实际用户的运行环境。对于实际项目可以和客户共同进行，对于产品来说就是最后一次的系统测试。测试内容为对功能模块的全面测试，尤其要进行文档测试。</p><p><strong>单元测试测试策略：</strong><br>自顶向下的单元测试策略：比孤立单元测试的成本高很多，不是单元测试的一个好的选择。<br>自底向上的单元测试策略：比较合理的单元测试策略，但测试周期较长。<br>孤立单元测试策略：最好的单元测试策略。</p><p><strong>集成测试的测试策略：</strong><br>大爆炸集成：适应于一个维护型项目或被测试系统较小<br>自顶向下集成：适应于产品控制结构比较清晰和稳定；高层接口变化较小；底层接口未定义或经常可能被修改；产口控制组件具有较大的技术风险，需要尽早被验证；希望尽早能看到产品的系统功能行为。<br>自底向上集成：适应于底层接口比较稳定；高层接口变化比较频繁；底层组件较早被完成。<br>基于进度的集成<br>     优点：具有较高的并行度；能够有效缩短项目的开发进度。<br>     缺点：桩和驱动工作量较大；有些接口测试不充分；有些测试重复和浪费。</p><p><strong>系统测试的测试策略：</strong><br>数据和数据库完整性测试；<br>功能测试；<br>用户界面测试；<br>性能评测；<br>负载测试；<br>强度测试；<br>容量测试；<br>安全性和访问控制测试；<br>故障转移和恢复测试；<br>配置测试；<br>安装测试；<br>加密测试；<br>可用性测试；<br>版本验证测试；<br>文档测试。</p><h2 id="12-测试人员在软件开发过程中的任务是什么？"><a href="#12-测试人员在软件开发过程中的任务是什么？" class="headerlink" title="12.测试人员在软件开发过程中的任务是什么？"></a>12.测试人员在软件开发过程中的任务是什么？</h2><p>1）尽可能早的找出系统中的Bug；<br>2）避免软件开发过程中缺陷的出现；<br>3）衡量软件的品质，保证系统的质量；<br>4）关注用户的需求，并保证系统符合用户需求。<br><strong>总的目标是：确保软件的质量。</strong></p><h2 id="13-黑盒测试和白盒测试是软件测试的两种基本方法，请分别说明各自的优点和缺点！"><a href="#13-黑盒测试和白盒测试是软件测试的两种基本方法，请分别说明各自的优点和缺点！" class="headerlink" title="13.黑盒测试和白盒测试是软件测试的两种基本方法，请分别说明各自的优点和缺点！"></a>13.黑盒测试和白盒测试是软件测试的两种基本方法，请分别说明各自的优点和缺点！</h2><p><strong>黑盒测试</strong></p><p>优点：</p><ul><li>比较简单，不需要了解程序内部的代码及实现；</li><li>与软件的内部实现无关；  </li><li>从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题；</li><li>基于软件开发文档，所以也能知道软件实现了文档中的哪些功能；</li><li>在做软件自动化测试时较为方便。</li></ul><p>缺点：</p><ul><li>不可能覆盖所有的代码，覆盖率较低，大概只能达到总代码量的30%；</li><li>自动化测试的复用性较低。</li></ul><p><strong>白盒测试</strong></p><p>优点：</p><ul><li>帮助软件测试人员增大代码的覆盖率，提高代码的质量，发现代码中隐藏的问题。</li></ul><p>缺点：</p><ul><li>程序运行会有很多不同的路径，不可能测试所有的运行路径；</li><li>测试基于代码，只能测试开发人员做的对不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；</li><li>系统庞大时，测试开销会非常大。</li></ul><h2 id="14-如何测试一个纸杯？"><a href="#14-如何测试一个纸杯？" class="headerlink" title="14.如何测试一个纸杯？"></a>14.如何测试一个纸杯？</h2><p><strong>功能度：</strong>用水杯装水看漏不漏；水能不能被喝到<br><strong>安全性：</strong>杯子有没有毒或细菌<br><strong>可靠性：</strong>杯子从不同高度落下的损坏程度<br><strong>可移植性：</strong>杯子在不同的地方、温度等环境下是否都可以正常使用<br><strong>兼容性：</strong>杯子是否能够容纳果汁、白水、酒精、汽油等<br><strong>易用性：</strong>杯子是否烫手、是否有防滑措施、是否方便饮用<br><strong>用户文档：</strong>使用手册是否对杯子的用法、限制、使用条件等有详细描述<br><strong>疲劳测试：</strong>将杯子盛上水（案例一）放24小时检查泄漏时间和情况；盛上汽油（案例二）放24小时检查泄漏时间和情况等<br><strong>压力测试：</strong>用根针并在针上面不断加重量，看压强多大时会穿透</p><h2 id="15-测试计划工作的目的是什么？测试计划文档的内容应该包括什么？其中哪些是最重要的？"><a href="#15-测试计划工作的目的是什么？测试计划文档的内容应该包括什么？其中哪些是最重要的？" class="headerlink" title="15.测试计划工作的目的是什么？测试计划文档的内容应该包括什么？其中哪些是最重要的？"></a>15.测试计划工作的目的是什么？测试计划文档的内容应该包括什么？其中哪些是最重要的？</h2><p>软件测试计划是指导测试过程的纲领性文件：</p><p>领导能够根据测试计划进行宏观调控，进行相应资源配置等<br>测试人员能够了解整个项目测试情况以及项目测试不同阶段的所要进行的工作等<br>便于其他人员了解测试人员的工作内容，进行有关配合工作<br>包含了产品概述、测试策略、测试方法、测试区域、测试配置、测试周期、测试资源、测试交流、风险分析等内容。<br>借助软件测试计划，参与测试的项目成员，尤其是测试管理人员，可以明确测试任务和测试方法，保持测试实施过程的顺畅沟通，跟踪和控制测试进度，应对测试过程中的各种变更。</p><p><strong>测试计划编写6要素（5W1H）：</strong></p><p>why — 为什么要进行这些测试；<br>what — 测试哪些方面，不同阶段的工作内容；<br>when — 测试不同阶段的起止时间；<br>where — 相应文档，缺陷的存放位置，测试环境等；<br>who — 项目有关人员组成，安排哪些测试人员进行测试；<br>how — 如何去做，使用哪些测试工具以及测试方法进行测试</p><p>测试计划和测试详细规格、测试用例之间是战略和战术的关系，<br>测试计划主要从宏观上规划测试活动的范围、方法和资源配置，<br>而测试详细规格、测试用例是完成测试任务的具体战术。<br><strong>所以其中最重要的是测试测试策略和测试方法（最好是能先评审）。</strong></p><h2 id="16-黑盒测试的测试用例常见设计方法都有哪些？请分别以具体的例子来说明这些方法在测试用例设计工作中的应用。"><a href="#16-黑盒测试的测试用例常见设计方法都有哪些？请分别以具体的例子来说明这些方法在测试用例设计工作中的应用。" class="headerlink" title="16.黑盒测试的测试用例常见设计方法都有哪些？请分别以具体的例子来说明这些方法在测试用例设计工作中的应用。"></a>16.黑盒测试的测试用例常见设计方法都有哪些？请分别以具体的例子来说明这些方法在测试用例设计工作中的应用。</h2><p><strong>1）等价类划分</strong><br>等价类是指某个输入域的子集合。<br>在该子集合中,各个输入数据对于揭露程序中的错误都是等效的。<br>并合理地假定:测试某等价类的代表值就等于对这一类其它值的测试.<br>因此,可以把全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件,就可以用少量代表性的测试数据.取得较好的测试结果.<br>等价类划分可有两种不同的情况:有效等价类和无效等价类.</p><p><strong>2）边界值分析法</strong><br>是对等价类划分方法的补充。<br>测试工作经验告诉我,大量的错误是发生在输入或输出范围的边界上,而不是发生在输入输出范围的内部.因此针对各种边界情况设计测试用例,可以查出更多的错误.</p><p>使用边界值分析方法设计测试用例,首先应确定边界情况.通常输入和输出等价类的边界,就是应着重测试的边界情况.<br>应当选取<strong>正好等于</strong>,<strong>刚刚大于</strong>或<strong>刚刚小于</strong>边界的值作为测试数据,而不是选取等价类中的典型值或任意值作为测试数据.</p><p><strong>3）错误猜测法</strong><br>基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法.</p><p>错误推测方法的基本思想:<br>列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例.<br>例如, 在单元测试时曾列出的许多在模块中常见的错误. 以前产品测试中曾经发现的错误等, 这些就是经验的总结.<br>还有, 输入数据和输出数据为0的情况. 输入表格为空格或输入表格只有一行. 这些都是容易发生错误的情况. 可选择这些情况下的例子作为测试用例.</p><p><strong>4）因果图方法</strong><br>前面介绍的等价类划分方法和边界值分析方法,都是着重考虑输入条件,但未考虑输入条件之间的联系, 相互组合等.<br>考虑输入条件之间的相互组合,可能会产生一些新的情况. 但要检查输入条件的组合不是一件容易的事情, 即使把所有输入条件划分成等价类,他们之间的组合情况也相当多.<br>因此必须考虑采用一种适合于描述对于多种条件的组合,相应产生多个动作的形式来考虑设计测试用例. 这就需要利用因果图（逻辑模型）.<br>因果图方法最终生成的就是判定表. 它适合于检查程序输入条件的各种组合情况.</p><p><strong>5）正交表分析法</strong><br>可能因为大量的参数的组合而引起测试用例数量上的激增，同时，这些测试用例并没有明显的优先级上的差距，而测试人员又无法完成这么多数量的测试，就可以通过正交表来进行缩减一些用例，从而达到尽量少的用例覆盖尽量大的范围的可能性。</p><p><strong>6）场景分析方法</strong><br>指根据用户场景来模拟用户的操作步骤，这个比较类似因果图，但是可能执行的深度和可行性更好。 </p><p><strong>7）状态图法</strong><br>通过输入条件和系统需求说明得到被测系统的所有状态，通过输入条件和状态得出输出条件；通过输入条件、输出条件和状态得出被测系统的测试用例。</p><p><strong>8）大纲法</strong><br>大纲法是一种着眼于需求的方法，为了列出各种测试条件，就将需求转换为大纲的形式。<br>大纲表示为树状结构，在根和每个叶子结点之间存在唯一的路径。<br>大纲中的每条路径定义了一个特定的输入条件集合，用于定义测试用例。<br>树中叶子的数目或大纲中的路径给出了测试所有功能所需测试用例的大致数量。</p><h2 id="17-您认为在测试人员同开发人员的沟通过程中，如何提高沟通的效率和改善沟通的效果？维持测试人员同开发团队中其他成员良好的人际关系的关键是什么？"><a href="#17-您认为在测试人员同开发人员的沟通过程中，如何提高沟通的效率和改善沟通的效果？维持测试人员同开发团队中其他成员良好的人际关系的关键是什么？" class="headerlink" title="17.您认为在测试人员同开发人员的沟通过程中，如何提高沟通的效率和改善沟通的效果？维持测试人员同开发团队中其他成员良好的人际关系的关键是什么？"></a>17.您认为在测试人员同开发人员的沟通过程中，如何提高沟通的效率和改善沟通的效果？维持测试人员同开发团队中其他成员良好的人际关系的关键是什么？</h2><p>尽量面对面的沟通，<br>其次是能直接通过电话沟通，<br>如果只能通过Email等非及时沟通工具的话，强调必须对特性的理解深刻以及能表达清楚。<br>运用一些测试管理工具如TestDirector进行管理也是较有效的方法，同时要注意在TestDirector中对BUG有准确的描述。</p><p>在团队中建立测试人员与开发人员良好沟通中注意以下几点：<br>一真诚、<br>二是团队精神、<br>三是在专业上有共同语言、<br>四是要对事不对人，工作至上</p><p>当然也可以通过直接指出一些小问题，而不是进入BUG Tracking System来增加对方的好感。</p><h2 id="18-你对测试最大的兴趣在哪里？为什么？"><a href="#18-你对测试最大的兴趣在哪里？为什么？" class="headerlink" title="18.你对测试最大的兴趣在哪里？为什么？"></a>18.你对测试最大的兴趣在哪里？为什么？</h2><p>回答这个面试题，没有固定统一的答案，但可能是许多企业都会问到的。提供以下答案供考：<br>最大的兴趣，感觉这是一个有挑战性的工作；<br>测试是一个经验行业，工作越久越能感觉到做好测试的难度和乐趣<br>通过自己的工作，能使软件产品越来越完善，从中体会到乐趣</p><p>回答此类问题注意以下几个方面：<br>尽可能的切合招聘企业的技术路线来表达你的兴趣，例如该企业是数据库应用的企业，那么表示你的兴趣在数据库的测试，并且希望通过测试提升自己的数据库掌握能力。<br>表明你做测试的目的是为了提升能力，也是为了更好的做好测试；提升能力不是为了以后转开发或其他的，除非用人企业有这样的安排。<br>不要过多的表达你的兴趣在招聘企业的范畴这外。比如招聘企业是做财务软件的，可是你表现出来的是对游戏软件的兴趣；或招聘是做JAVA开发的，而你的兴趣是在C类语言程序的开发。</p><h2 id="19-你自认为测试的优势在哪里？"><a href="#19-你自认为测试的优势在哪里？" class="headerlink" title="19.你自认为测试的优势在哪里？"></a>19.你自认为测试的优势在哪里？</h2><p>该面试也没有固定不变的答案，但可参考以下几点，并结合自身特点：<br>有韧性、<br>有耐心、<br>责任心、<br>做事有条理性、<br>喜欢面对挑战、<br>有信心做好每一件事情、<br>较强的沟通能力、<br>具备一定的编程经验<br>时时保持怀疑态度，并且有缺陷预防的意识</p><h2 id="20-软件验收测试"><a href="#20-软件验收测试" class="headerlink" title="20.软件验收测试"></a>20.软件验收测试</h2><p>三种：</p><ul><li>正式验收测试</li><li>alpha测试</li><li>beta测试</li></ul><h2 id="21-请说出这些测试最好由那些人员完成，测试的是什么？"><a href="#21-请说出这些测试最好由那些人员完成，测试的是什么？" class="headerlink" title="21.请说出这些测试最好由那些人员完成，测试的是什么？"></a>21.请说出这些测试最好由那些人员完成，测试的是什么？</h2><p>代码、函数级测试 一般由白盒测试人员完成，他们针对每段代码或函数进行正确性检验，检查其是否正确的实现了规定的功能。<br>模块、组件级测试 主要依据是程序结构设计测试模块间的集成和调用关系，一般由测试人员完成。<br>系统测试 在于模块测试与单元测试的基础上进行测试。了解系统功能与性能，根据测试用例进行全面的测试。</p><h2 id="22-一套完整的测试应该由哪些阶段组成？"><a href="#22-一套完整的测试应该由哪些阶段组成？" class="headerlink" title="22.一套完整的测试应该由哪些阶段组成？"></a>22.一套完整的测试应该由哪些阶段组成？</h2><ul><li>可行性分析</li><li>需求分析</li><li>概要设计</li><li>详细设计</li><li>编码</li><li>单元测试</li><li>集成测试</li><li>系统测试</li><li>验收测试</li></ul><h2 id="23-你对测试最大的兴趣在哪里？为什么？"><a href="#23-你对测试最大的兴趣在哪里？为什么？" class="headerlink" title="23.你对测试最大的兴趣在哪里？为什么？"></a>23.你对测试最大的兴趣在哪里？为什么？</h2><p>最大的兴趣就是<strong>测试有难度，有挑战性！</strong><br>做测试越久越能感觉到做好测试有多难。</p><p>刚开始进入测试行业时，对测试的认识是从无忧测试网上了解到的一些资料，当时是冲着做测试需要很多技能才能做的好，虽然入门容易，但做好很难，比开发更难，虽然当时我很想做开发（学校专业课我基本上不缺席，因为我喜欢我的专业），但看到测试比开发更难更有挑战性，想做好测试的意志就更坚定了。</p><p>我觉得做测试整个过程中有2点让我觉得很有难度（对我来说，有难度的东西我就非常感兴趣），<br><strong>第一是测试用例的设计</strong><br>因为测试的精华就在测试用例的设计上了，要在版本出来之前，把用例写好，用什么测试方法写？（也就是测试计划或测试策略），如果你刚测试一个新任务时，你得花一定的时间去消化业务需求和技术基础，业务需求很好理解（多和产品经理和开发人员沟通就能达到目的），而技术基础可就没那么简单了，这需要你自觉的学习能力，比如说网站吧，最基本的技术知识你要知道网站内部是怎么运作的的，后台是怎么响应用户请求的？测试环境如何搭建？这些都需要最早的学好。至少在开始测试之前能做好基本的准备，可能会遇到什么难题？需求细节是不是没有确定好？这些问题都能在设计用例的时候发现。</p><p><strong>第二是发现BUG的时候了</strong><br>这应该是测试人员最基本的任务了，一般按测试用例开始测试就能发现大部分的bug，还有一部分bug需要测试的过程中更了解所测版本的情况获得更多信息，补充测试用例，测试出bug。还有如何发现bug？这就需要在测试用例有效的情况下，通过细心和耐心去发现bug了，每个用例都有可能发现bug，每个地方都有可能出错，所以测试过程中思维要清晰（测试过程数据流及结果都得看仔细了，bug都在里面发现的）。如何描述bug也很有讲究，bug在什么情况下会产生，如果条件变化一点点，就不会有这个bug，以哪些最少的操作步骤就能重现这个bug，这个bug产生的规律是什么？如果你够厉害的话，可以帮开发人员初步定位问题。</p><h2 id="24-请试着比较一下黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试的区别与联系。"><a href="#24-请试着比较一下黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试的区别与联系。" class="headerlink" title="24.请试着比较一下黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试的区别与联系。"></a>24.请试着比较一下黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试的区别与联系。</h2><p>　　黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。<br>　　白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。</p><p>　　软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。<br><strong>因此黑盒测试又叫<em>功能测试</em>或<em>数据驱动测试</em>。</strong></p><pre><code>黑盒测试主要是为了发现以下几类错误：1、是否有不正确或遗漏的功能？2、在接口上，输入是否能正确的接受？能否输出正确的结果？3、是否有数据结构错误或外部信息（例如数据文件）访问错误？4、性能上是否能够满足要求？5、是否有初始化或终止性错误？</code></pre><p>　　软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。<br><strong>因此白盒测试又称为<em>结构测试</em>或<em>逻辑驱动测试</em>。</strong></p><pre><code>白盒测试主要是想对程序模块进行如下检查：1、对程序模块的所有独立的执行路径至少测试一遍。2、对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。3、在循环的边界和运行的界限内执行循环体。4、测试内部数据结构的有效性，等等。</code></pre><p><strong>单元测试（模块测试）</strong><br>    是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试是用于判断某个特定条件（或者场景）下某个特定函数的行为。<br>    单元测试是由程序员自己来完成，最终受益的也是程序员自己。<br>    可以这么说，程序员有责任编写功能代码，同时也就有责任为自己的代码编写单元测试。<br>    执行单元测试，就是为了证明这段代码的行为和我们期望的一致。</p><p><strong>集成测试（也叫组装测试，联合测试）</strong><br>    是单元测试的逻辑扩展。<br>    它的最简单的形式是：两个已经测试过的单元组合成一个组件，并且测试它们之间的接口。<br>    从这一层意义上讲，组件是指多个单元的集成聚合。<br>    在现实方案中，许多单元组合成组件，而这些组件又聚合成程序的更大部分。<br>    方法是测试片段的组合，并最终扩展进程，将您的模块与其他组的模块一起测试。最后，将构成进程的所有模块一起测试。</p><p><strong>系统测试</strong><br>    是将经过测试的子系统装配成一个完整系统来测试。<br>    它是检验系统是否确实能提供系统方案说明书中指定功能的有效方法。（常见的联调测试）<br>    系统测试的目的是对最终软件系统进行全面的测试，确保最终软件系统满足产品需求并且遵循系统设计。<br>    验收测试是部署软件之前的最后一个测试操作。<br>    验收测试的目的是确保软件准备就绪，并且可以让最终用户将其用于执行软件的既定功能和任务。<br>    验收测试是向未来的用户表明系统能够像预定要求那样工作。<br>    经集成测试后，已经按照设计把所有的模块组装成一个完整的软件系统，接口错误也已经基本排除了，接着就应该进一步验证软件的有效性，这就是验收测试的任务，即软件的功能性能如同用户所合理期待的那样。</p><h2 id="25-主键、外键的作用，索引的优点与不足"><a href="#25-主键、外键的作用，索引的优点与不足" class="headerlink" title="25.主键、外键的作用，索引的优点与不足?"></a>25.主键、外键的作用，索引的优点与不足?</h2><p><strong>主键：是表中的唯一标示键。</strong><br>作用：</p><ul><li>保证实体的完整性;</li><li>加快数据库的操作速度;</li><li>增加新的表记录时，数据库会自动检索新记录的主键值，不允许该值与其他表中记录的主键重复;</li><li>数据库会按主键值的顺序显示记录，如果没有设定主键，则按输入的顺序显示记录。</li></ul><p><strong>外键：是主键的从属，表示了两个表之间的联系。</strong><br>作用：</p><ul><li>使用外键可以避免冗余。</li></ul><p><strong>索引的优点：</strong><br>1、通过创建唯一性的索引，可以保证表中数据的唯一性;<br>2、加速数据的检索速度;<br>3、加快表与表之间的连接;<br>4、在使用分组与排序数据检索时，可以显著检索分组与排序的时间;<br>5、在查询的过程中使用优化隐藏器，提供系统性能。</p><p><strong>缺点：</strong><br>1、创建索引需要时间，且随着数据量的增加而增加;<br>2、索引需要占用物理空间;<br>3、当对表中数据进行修改时，索引也要动态维护，降低了数据的维护速度。</p><h2 id="26"><a href="#26" class="headerlink" title="26."></a>26.</h2><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="1-自动售货机的测试"><a href="#1-自动售货机的测试" class="headerlink" title="1. 自动售货机的测试"></a>1. 自动售货机的测试</h2><p><strong>功能性测试：</strong><br>1）验证每个按钮是否发挥作用，如摁下选择任何一个饮料的按钮是否会提示该饮料的价格和请投币字样；<br>2）验证用户选择饮料功能是否正确，摁下每个饮料按钮是否起作用；<br>3）验证投币付款功能是否正确，包括投入纸币和硬币，纸币和硬币的种类，如纸币只接受一元、五元、十元，硬币只接受五角、一元；<br>4）验证退币功能是否正确，包括有零钱时和没有零钱时的反应；<br>5）验证第三方支付功能是否正确，如微信支付、支付宝支付等；</p><p><strong>性能测试：</strong><br>1）利用微信、支付宝等第三方平台支付时的响应速度；<br>2）选好饮料弹出提示信息的时间；<br>3）退币时的响应时间和退币速度；<br>4）付款时突然断电；</p><p><strong>易用性测试：</strong><br>1）售货机是否符合用户的使用习惯，有无错误提示信息<br>2）操作按钮是否通俗易懂，有无歧义；</p><p><strong>压力测试：</strong></p><ul><li>在反复大量输入或在恶劣的天气情况下，能否持续正常操作</li></ul><p><strong>外观测试：</strong></p><ul><li>售货机是否外形美观，布局是否合理，界面元素是否清晰</li></ul><p><strong>安全性测试：</strong><br>1）售货机货箱是否坚固耐用<br>2）是否有防盗功能<br>3）在应用第三方支付扫码时扫到非正常二维码时的处理情况</p><h2 id="2-测-QQ-登录页面"><a href="#2-测-QQ-登录页面" class="headerlink" title="2. 测 QQ 登录页面"></a>2. 测 QQ 登录页面</h2><p><strong>功能测试</strong></p><ul><li><p>正常登陆<br>1）正确的账号和密码<br>2）账号、密码最长<br>3）账号、密码最短<br>4）密码规则符合大小写<br>5）异地登陆<br>6）删除登陆历史<br>7）二维码登录<br>8）修改登录状态<br>9）记住密码<br>10）自动登陆<br>11）找回密码<br>12）注册账号<br>13）切换用户登陆<br>14）设置<br>15）关闭<br>16) 最小化</p></li><li><p>异常登陆<br>1）账号不正确<br>2）密码不正确<br>3）账号和密码都不正确<br>4）网络异常<br>5）服务器异常<br>6）数据库异常<br>7）账号被禁用<br>8）账号被锁定<br>9）正在找回密码<br>10）更新中<br>11）已登陆了再次登陆<br>12）账号、密码长度超长<br>13）账号、密码低于最短<br>14）密码规则不符合<br>15）登陆最多失败次数<br>16）网络不稳定扫描二维码登陆<br>17）弱网登陆</p></li></ul><p><strong>性能测试</strong><br>1）一台电脑同时登陆QQ的个数<br>2）QQ登陆成功所需的时间</p><p><strong>界面测试</strong><br>1）界面美观，颜色搭配合理<br>2）布局合理<br>3）按钮大小位置合适<br>4）文字、大小颜色搭配合理</p><p><strong>易用性测试</strong><br>1）用户名、密码粘贴复制<br>2）记住密码<br>3）自动登陆<br>4）找回密码</p><p><strong>兼容性测试</strong><br>1.不同的WINDOWS、操作系统<br>2.不同的QQ版本</p><p><strong>安全测试</strong><br>1）已带病毒的QQ登陆<br>2）登录验证码<br>3）记住密码<br>4）自动登陆<br>5）找回密码</p><h2 id="3-测试微信的通讯录功能"><a href="#3-测试微信的通讯录功能" class="headerlink" title="3. 测试微信的通讯录功能"></a>3. 测试微信的通讯录功能</h2><h2 id="4-如果要你来测试王者荣耀这款游戏，你会测试什么？"><a href="#4-如果要你来测试王者荣耀这款游戏，你会测试什么？" class="headerlink" title="4. 如果要你来测试王者荣耀这款游戏，你会测试什么？"></a>4. 如果要你来测试王者荣耀这款游戏，你会测试什么？</h2><h2 id="5-测试电梯"><a href="#5-测试电梯" class="headerlink" title="5. 测试电梯"></a>5. 测试电梯</h2><h2 id="6-集成测试和系统测试，并且Bug定位属于什么测试"><a href="#6-集成测试和系统测试，并且Bug定位属于什么测试" class="headerlink" title="6. 集成测试和系统测试，并且Bug定位属于什么测试"></a>6. 集成测试和系统测试，并且Bug定位属于什么测试</h2><h2 id="7-交换机测试"><a href="#7-交换机测试" class="headerlink" title="7. 交换机测试"></a>7. 交换机测试</h2><h2 id="8-如何测试一个纸杯？"><a href="#8-如何测试一个纸杯？" class="headerlink" title="8.如何测试一个纸杯？"></a>8.如何测试一个纸杯？</h2><p><strong>功能度：</strong>用水杯装水看漏不漏；水能不能被喝到<br><strong>安全性：</strong>杯子有没有毒或细菌<br><strong>可靠性：</strong>杯子从不同高度落下的损坏程度<br><strong>可移植性：</strong>杯子在不同的地方、温度等环境下是否都可以正常使用<br><strong>兼容性：</strong>杯子是否能够容纳果汁、白水、酒精、汽油等<br><strong>易用性：</strong>杯子是否烫手、是否有防滑措施、是否方便饮用<br><strong>用户文档：</strong>使用手册是否对杯子的用法、限制、使用条件等有详细描述<br><strong>疲劳测试：</strong>将杯子盛上水（案例一）放24小时检查泄漏时间和情况；盛上汽油（案例二）放24小时检查泄漏时间和情况等<br><strong>压力测试：</strong>用根针并在针上面不断加重量，看压强多大时会穿透</p><h2 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h2>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试开发工程师相关知识</title>
      <link href="/2019/09/07/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/09/07/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><strong>1. 在 student_course 表(sid, cid, score) 查询课程 1(cid=1) 成绩第2高的学生</strong></p><p><strong>2. 数据库查询慢怎么优化</strong></p><p><strong>3. 存储过程与自定义函数的区别</strong><br>1）存储过程实现的功能要复杂一些；<br>  而函数的针对性更强；<br>  （在实际过程中，很少使用函数来对表进行操作）<br>2）存储过程可以返回多个值，而函数只能有一个返回值；<br>3）存储过程一般独立的来执行；<br>  而函数可以作为其他SQL语句的组成部分来实现。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>**1. </p><h1 id="手撕代码"><a href="#手撕代码" class="headerlink" title="手撕代码"></a>手撕代码</h1><p><strong>1. 将一个输入数组转化为一个字符串序列</strong></p><p><strong>2. 查找数组中重复的数字并输出，要求输出的数字不重复</strong></p><p><strong>3. 求连续子数组的最大和</strong></p><p><strong>4. 6位数字旋转180°正常的概率，和原来一样的概率</strong></p><p><strong>5. 找到链表的第k个节点，并删除</strong></p><p>**6.</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><strong>1. 变量声明和定义，内存分配时有啥区别？</strong></p><p><strong>2. 死锁是因为什么？怎么解决？</strong></p><p><strong>3. 进程与线程的区别。</strong><br>1）进程是资源分配的基本单位；<br>   线程是分配处理机的基本单位，它与资源分配无关；<br>2）一个线程只能属于一个进程；<br>   而一个进程可以有多个线程；<br>3）一个程序至少有一个进程，一个进程至少有一个线程；<br>4）进程在执行过程中拥有独立的内存单元；<br>   而多个线程是共享内存，极大地提高了程序的运行效率；<br>   （线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉）<br>5）线程在执行过程中需要协作同步；<br>   不同进程间要利用消息通信的方式实现同步。</p><p>**4. </p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><strong>1. HTTP协议</strong></p><p><strong>2. FIR和IIR</strong></p><p><strong>3. 对面向对象的理解</strong></p><p><strong>4. TCP的三次握手和四次挥手</strong></p><p><strong>5. 输入一个URL，但是没有访问到预期的网站，是什么原因？</strong><br>1.DNS坏掉了，修改自己的IP地址为8.8.8.8试试<br>2.网络断了<br>3.服务器拒绝访问<br>4.请求或者响应在网络传输中途被劫走了</p><p>如何排查？<br>从七层网络的角度进行逐层分析，<br>物理层-即网线有没有连接；<br>数据链路层-即网口的灯有没有亮；<br>某层-可以查询本机的IP地址，根据IP地址和子网掩码的计算结果查看是否和网关在同一子网，还应检查DHCP动态分配的IP地址，看是否和网关在同一个子网；<br>检查本地ARP表中网关的IP地址和MAC地址是否对应。</p><p><em>OSI七层模型解决网络故障实战思路</em><br>物理层故障原因：①设别电源未打开 ②设别电源未接通 ③网络电缆松脱 ④电缆故障 ⑤电缆类型不正确<br>数据链路层故障原因：①设别驱动程序出错 ②设备没有安装驱动程序 ③设备配置错误<br>网络层故障原因：①IP地址是否设置正确 ②子网掩码是否正确 ③网关是否正确 ④DNS或DHCP是否正确<br>网络层常用的排除故障的命令包括：ipconfig命令、ping命令、tracert命令<br>传输层故障原因：①防火墙设置错误 ②应用程序的TCP的端口是否被打开<br>会话层、表示层、应用层故障原因：这三层主要涉及使用软件的故障原因，把应用软件设置正确，问题迎刃而解。</p><p><strong>6. 在浏览器中输入一个网址它的运行过程是怎样的？</strong><br><em>1.首先进行域名解析，*域名解析具体过程讲一下：<br>浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表；<br>若没有，则搜索操作系统的DNS缓存；<br>若没有，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找：<br>本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址；<br>本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址；<br>本地域名服务器向权限域名服务器发起请求，得到IP地址；<br>本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来；<br>操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来；<br>至此，浏览器已经得到了域名对应的IP地址。<br>*2.浏览器发起HTTP请求；</em><br><em>3.接下来到了传输层，<em>选择传输协议，TCP或者UDP，TCP是可靠的传输控制协议，对HTTP请求进行封装，加入了端口号等信息；<br>*4.然后到了网络层，</em>通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址；<br><em>5.接下来到了数据链路层，</em>把网络层交下来的IP数据报添加首部和尾部，封装为MAC帧，现在根据目的mac开始建立TCP连接，三次握手，接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层；<br>*6.服务器响应请求并请求客户端要的资源，传回给客户端；</em><br><em>7.断开TCP连接，浏览器对页面进行渲染呈现给客户端。</em></p><p><strong>7.单工、半双工、双工的含义</strong><br>单工： A收B发；<br>半双工： A收B发和B收A发都可以，但是不能同时进行；<br>双工： A向B发送的时候同时还可以接收到B发送给A的信号。</p><p>**8.</p><h1 id="C-C-语言知识"><a href="#C-C-语言知识" class="headerlink" title="C/C++语言知识"></a>C/C++语言知识</h1><p><strong>1. vector insert和push_back有什么区别？</strong></p><p><strong>2. malloc 和 new 的区别？</strong></p><p><strong>3. 软件开发流程</strong></p><p>**4. </p><h1 id="linux知识"><a href="#linux知识" class="headerlink" title="linux知识"></a>linux知识</h1><p><strong>1. 如何查看linux内核版本？</strong><br>方法1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;version</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p>方法 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><p><strong>2. shell脚本的第一句是什么？有什么作用？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>作用：执行解释器环境</p><p><strong>3. find默认的查找目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find</span><br></pre></td></tr></table></figure><p><strong>4. 查询进程的pid</strong></p><p>查看进程：<br>1）ps 命令用于查看当前正在运行的进程。<br>grep 是搜索<br>例如： ps -ef | grep java<br>表示查看所有进程里 CMD 是 java 的进程信息</p><p>2）ps -aux | grep java<br>-aux 显示所有状态</p><p>3）kill 命令用于终止进程<br>例如： kill -9 [PID]<br>-9 表示强迫进程立即停止</p><p><strong>通常用 ps 查看进程 PID ，用 kill 命令终止进程</strong></p><p><strong>5. Linux的启动顺序</strong><br>1）内核的引导；<br>2）运行 init；<br>3）系统初始化；<br>4）建立终端；<br>5）用户登录系统。</p><p>**6.</p><hr>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> test development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>embedded software classic interview questions</title>
      <link href="/2019/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/08/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-经典面试题"><a href="#第一章-经典面试题" class="headerlink" title="第一章 经典面试题"></a>第一章 经典面试题</h2><p><strong>1.用#define声明一个常数，表明1年中有多少秒（忽略闰年问题）？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</span><br></pre></td></tr></table></figure><p>要点：<br>A.没有以分号结束;<br>B.懂得预处理器将为你计算常数表达式的值。即60 * 60 * 24 * 365而不是31536000.<br>C.考虑到了16位机将会溢出，巧妙运用了UL。</p><p><strong>2.写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MIN(A,B) ((A) &lt;&#x3D; (B) ? (A) : (B))</span><br></pre></td></tr></table></figure><p>要点：<br>A.参数用括号括起来;<br>B.考察能否合理运用条件运算符;</p><p><strong>3.Heap与Stack的差别？</strong><br>答案：Heap是堆，Stack是栈。</p><p>Stack的空间由系统自动分配/释放，Heap上的空间手动分配/释放。<br>Stack空间有限，Heap是很大的自由存储区，malloc函数分配的内存空间即在堆上。</p><p>网上经典例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 0; &#x2F;&#x2F;全局初始化区 </span><br><span class="line">char *p1;&#x2F;&#x2F;全局未初始化区 </span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">  int b; &#x2F;&#x2F;栈 </span><br><span class="line">  char s[] &#x3D; &quot;abc&quot;; &#x2F;&#x2F;栈 </span><br><span class="line">  char *p2; &#x2F;&#x2F;栈 </span><br><span class="line">  char *p3 &#x3D; &quot;123456&quot;; &#x2F;&#x2F;123456\0在常量区，p3在栈上</span><br><span class="line">  static int c &#x3D;0; &#x2F;&#x2F;全局（静态）初始化区 </span><br><span class="line">  p1 &#x3D; (char *)malloc(10); &#x2F;&#x2F;堆 </span><br><span class="line">  p2 &#x3D; (char *)malloc(20); &#x2F;&#x2F;堆 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.用变量a给出下面的定义</strong><br>A.一个整型数？<br>答案：int a;</p><p>B.一个指向整型数的指针？<br>答案：int * a;</p><p>C.一个指向指针的的指针，它指向的指针是指向一个整型数？<br>答案：int ** a;</p><p>D.一个有10个整型数的数组？<br>答案：int a[10];</p><p>E.一个有10个指针的数组，该指针是指向一个整型数的？<br>答案：int * a[10];</p><p>F.一个指向有10个整型数数组的指针?<br>答案：int (* a)[10];</p><p>G.一个指向函数的指针，该函数有一个整型参数并返回一个整型数?<br>答案：int (* a)(int);</p><p>H.一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数?<br>答案：int (* a[10])(int);</p><p><strong>5.关键字static的作用是什么？</strong><br>A.在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变;<br>B.在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的局变量;<br>C.在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用;</p><p><strong>6.关键字const有什么含意？</strong><br>答案：const意味着”只读”。<br>如果回答”const意味着常数”，面试官会觉得你只是一个业余的人。</p><p><strong>7.下面的声明都是什么意思？</strong><br>const int a;<br>int const a;<br>const int *a;<br>int * const a;<br>const int * a;</p><p>答案：<br>A.前两个的作用是一样，a是一个常整型数;<br>B.第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）;<br>C.第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）;<br>D.最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数 是不可修改的，同时指针也是不可修改的）。</p><p>一个整型数   int a;<br>一个指向整型数的指针  int * a;<br>一个指向指针的指针，它指向的指针式指向一个整型数  int <em>* a;<br>一个有10个整型数的数组   int a[10];<br>一个有10指针的数组，该指针是指向一个整型数  int * a[10];<br>一个指向有10个整型数数组的指针   int (</em> a)[10];<br>一个指向函数的指针，该函数有一个整型数参数并返回一个整型数   int (* a)(int);<br>一个有10个指针的数组，该指针指向一个函数，该函数有一个整型数参数并返回一个整型  int (* a[10])(int);</p><p><strong>8.关键字volatile有什么含意?</strong><br>答案：一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。</p><p> volatile表示被修饰的符号是易变的。告诉编译器不要随便优化我的代码！！<br> *一个硬件寄存器<br> *中断中用到的变量<br> *线程之间共享变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volatile int a &#x3D; 10;</span><br><span class="line">while((a &amp; 0x01) &#x3D;&#x3D; 0);</span><br><span class="line">#define P_UART_STATUS ((const volatile unsigned int *)0x88000000);</span><br><span class="line">      &#x2F;&#x2F; volatile表示硬件会修改这个寄存器的内容</span><br><span class="line">      &#x2F;&#x2F; const表示该寄存器只读，写无意义</span><br></pre></td></tr></table></figure><p><strong>9.sizeof和strlen的区别?</strong></p><p>答案：<br>sizeof是运算符，在头文件中typedef为unsigned int,其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。<br>sizeof返回的值表示的含义如下：<br>数组——编译时分配的数组空间大小；<br>指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）。</p><p>而strlen是函数，要在运行时才能计算。参数必须是字符型指针。当数组名作为参数传入时，实际上数组就退化成指针了。<br>它的功能是：返回字符串的长度。<br>该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。<br>返回的长度大小不包括NULL。<br>strlen所作的仅仅是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符’\0’为止，然后返回计数器值(长度不包含’\0’)。</p><p><strong>10.在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务?</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">p &#x3D; (int*)0x67a9;</span><br><span class="line">*p &#x3D; 0xaa66;</span><br></pre></td></tr></table></figure><p> 一个较晦涩的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　*(int * const)(0x67a9) &#x3D; 0xaa66;</span><br></pre></td></tr></table></figure><p><strong>11.给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define BIT3 (0x1 &lt;&lt; 3)</span><br><span class="line">static int a;</span><br><span class="line"></span><br><span class="line">void set_bit3(void)</span><br><span class="line">&#123;</span><br><span class="line">  a |&#x3D; BIT3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear_bit3(void)</span><br><span class="line">&#123;</span><br><span class="line">  a &amp;&#x3D; ~BIT3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>12.下面函数错误吗？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int square(volatile int *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  return *ptr * *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：错误!</p><p>正确写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long square(volatile int *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  int a;</span><br><span class="line">  a &#x3D; *ptr;</span><br><span class="line">  return a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>13.嵌入式交叉编译环境有哪两部分组成？简述交叉编译过程。</strong></p><p>本地编译可以理解为，在当前编译平台下，编译出来的程序只能放到当前平台下运行。平时我们常见的软件开发，都是属于本地编译；<br>交叉编译可以理解为，在当前编译平台下，编译出来的程序能运行在体系结构不同的另一种目标平台上，但是编译平台本身却不能运行该程序。<br>以Linux-arm而言，我们在PC上开发的程序，只能够在Linux平台上能够运行，那我们的终极目的是能够在ARM产品上进行运行。对于这种跨平台而言，就需要交叉编译工具（arm-linux-gcc）进行编译，这样的代码才能够在ARM上进行运行。</p><p>至于为什么进行交叉编译？<br>Speed： 目标平台的运行速度往往比主机慢得多，许多专用的嵌入式硬件被设计为低成本和低功耗，没有太高的性能；<br>Capability： 整个编译过程是非常消耗资源的，嵌入式系统往往没有足够的内存或磁盘空间；<br>Availability： 即使目标平台资源很充足，可以本地编译，但是第一个在目标平台上运行的本地编译器总需要通过交叉编译获得；<br>Flexibility： 一个完整的Linux编译环境需要很多支持包，交叉编译使我们不需要花时间将各种支持包移植到目标板上。</p><p>交叉编译链就是为了编译跨平台体系结构的程序代码而形成的由多个子工具构成的一套完整的工具集，一般由编译器、连接器、解释器和调试器组成。<br>同时，它隐藏了预处理、编译、汇编、链接等细节，当我们指定了源文件(.c)时，它会自动按照编译流程调用不同的子工具，自动生成最终的二进制程序映像(.bin)。</p><p><strong>14.互斥量和信号量的区别：</strong></p><p>互斥量用于线程的互斥，信号量用于线程的同步。<br>这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别；</p><p>互斥量值只能为0/1，<br>信号量值可以为非负整数。<br>也就是说，<br>一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。<br>信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问；</p><p>互斥量的加锁和解锁必须由同一线程分别对应使放用，<br>信号量可以由一个线程释放，另一个线程得到。</p><p>这里区分一下互斥和同步：<br>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的；<br>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p><p><strong>15.Linux在某目录下查找某字符串通常如下哪个指令？</strong><br>解答：Linux的find命令用来在指定目录下查找文件，可以使用-name选项来完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;home -name &quot;*.txt&quot;            &#x2F;&#x2F;不忽略大小写</span><br><span class="line">find &#x2F;home -iname &quot;*.txt&quot;            &#x2F;&#x2F;忽略大小写</span><br></pre></td></tr></table></figure><p><strong>16.可用于中断下半段处理的处理机制有（）。</strong><br>A.tasklet<br>B.工作队列<br>C.软中断<br>D.双向链表</p><p>KEY：<br>ABC</p><p>解答：<br>上半部是不能中断的，仅仅是响应中断；下半部是可以中断的。<br>对于适时要求高的，必须放在上半部。<br>下半部的实现主要是通过软中断、tasklet、工作队列来实现的。</p><p>上半部的功能是响应中断。<br>当中断发生时，它就把设备驱动程序中中断处理例程的下半部挂到设备的下半部执行队列中去，然后继续等待新的中断到来。这样一来，上半部的执行速度就会很快，它就可以接受更多它负责的设备所产生的中断了。上半部之所以快，是因为它是完全屏蔽中断的，如果它没有执行完，其他中断就不能及时地处理，只能等到这个中断处理程序执行完毕以后。所以要尽可能多的对设备产生的中断进行服务和处理，中断处理程序就一定要快。</p><p>下半部的功能是处理比较复杂的过程。下半部和上半部最大的区别是可中断，而上半部却不可中断。下半部几乎完成了中断处理程序所有的事情，因为上半部只是将下半部排到了它们所负责的设备中断的处理队列中去，然后就不做其它的处理了。下半部所负责的工作一般是查看设备以获得产生中断的事件信息，并根据这些信息（一般通过读设备上的寄存器得来）进行相应的处理。下半部是可中断的，所以在运行期间，如果其它设备产生了中断，这个下半部可以暂时的中断掉，等到那个设备的上半部运行完了，再回头运行这个下半部。</p><p>下半部机制    上下文                                        复杂度                        执行性能    顺序执行保障<br>软中断         中断    高(需要自己确保软中断的执行顺序及锁机制)    好(全部自己实现，便于调优)        没有<br>tasklet        中断    中(提供了简单的接口来使用软中断)            中                            同类型不能同时执行<br>工作队列        进程    低(在进程上下文中运行，与写用户程序差不多)    差                            没有(和进程上下文一样被调度)</p><p><strong>17.关于链表，描述正确的选项有（）。</strong><br>A.在运行时可以动态添加<br>B.物理空间不连续，空间开销更大<br>C.查找元素不需要顺序查找<br>D.可在任意节点位置插入元素</p><p>KEY：ABD</p><p><strong>18.能在Linux内核态执行的是（）。</strong><br>A.缺页中断<br>B.时钟中断<br>C.命令解释<br>D.进程调度<br>KEY：ABD</p><p>解答：缺页中断和时钟中断都属于中断，在内核态执行。进程调度属于系统调用，在内核态执行，命令解释程序属于命令接口，在用户态执行。</p><p><strong>19.整数数组清零：bzero(),memset()。</strong></p><p><strong>20.<br>小端：低位字节数据存储在低地址<br>大端：高位字节数据存储在低地址</strong></p><p>例如：int a=0x12345678;(a首地址为0x2000)<br>0x2000  0x2001  0x2002  0x2003<br>0x12    0x34    0x56    0x78      大端格式</p><p><strong>21.异步IO和同步IO区别</strong></p><p>如果是同步IO，当一个IO操作执行时，应用程序必须等待，直到此IO执行完，<br>相反，异步IO操作在后台运行，IO操作和应用程序可以同时运行，提高系统性能，提高IO流量； </p><p>在同步文件IO中，线程启动一个IO操作然后就立即进入等待状态，直到IO操作完成后才醒来继续执行，<br>而异步文件IO中，线程发送一个IO请求到内核，然后继续处理其他事情，内核完成IO请求后，将会通知线程IO操作完成了。</p><p><strong>22.c的关键字共32个</strong></p><p> *数据类型关键字（12）<br> char,short,int,long,float,double,unsigned,signed,union,enum,void,struct</p><p> *控制语句关键字（12）<br> if,else,switch,case,default,for,do,while,break,continue,goto,return</p><p> *存储类关键字（5）<br> auto,extern,register,static,const</p><p> *其他关键字（3）<br> sizeof,typedef,volatile</p><p><strong>23.评价下面的代码片断：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　unsigned int zero &#x3D; 0;</span><br><span class="line">　　unsigned int compzero &#x3D; 0xFFFF;</span><br></pre></td></tr></table></figure><p>　　/* 1’s complement of zero * /<br>　　对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　unsigned int compzero &#x3D; ~0;</span><br></pre></td></tr></table></figure><p><strong>24.Norflash与Nandflash的区别</strong><br> (1)、NAND闪存的容量比较大<br> (2)、由于NandFlash没有挂接在地址总线上，所以如果想用NandFlash作为系统的启动盘，就需要CPU具备特殊的功能，<br> 如s3c2410在被选择为NandFlash启动方式时会在上电时自动读取NandFlash的4k数据到地址0的SRAM中。<br> (3)、NAND Flash一般地址线和数据线共用，对读写速度有一定影响。NOR Flash闪存数据线和地址线分开，<br>    所以相对而言读写速度快一些。</p><p><strong>25.反码：对原码除符号位外的其余各位逐位取反就是反码<br> 补码：负数的补码就是对反码加1<br> 正数的原码、反码、补码都一样</strong></p><p><strong>26.线程、互斥锁、信号量关键函数</strong><br> pthread_t tid;<br> pthread_create(&amp;tid,NULL,pthread_func,NULL);//创建线程<br> pthread_join(tid,NULL);//等待子线程结束，并回收资源<br> pthread_detach(tid);//与当前进程分离<br> pthread_exit(NULL);//退出调用线程<br> pthread_cancel(tid);//取消线程<br> pthread_mutex mutex=PTHREAD_MUTEX_INITIALIZER;<br> pthread_mutex_init(&amp;mutex,NULL);//初始化一个互斥锁<br> pthread_mutex_lock(&amp;mutex);//对互斥锁上锁<br> pthread_mutex_unlock(&amp;mutex);//对互斥锁解锁<br> sem_t sem;<br> sem_init(&amp;sem,0,1);//创建信号量并初始化它的值<br> sem_wait(&amp;sem);//信号量的值减1<br> sem_post(&amp;sem);//信号量的值加1</p><p><strong>27.ROM是只读存储器，掉电不丢失<br>RAM是读写存储器，掉电丢失</strong></p><p><strong>28.signed char 的取值范围-128~127.</strong></p><p><strong>29.</strong>已知strcpy函数的函数原型是：<br>char * strcpy(char * strDest, const char * strSrc)。其中，strDest是目的字符串，strSrc是源字符串。<br> 不调用C++/C的字符串库函数，请编写函数strcpy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *strcpy(char *strDest, const char *strSrc)</span><br><span class="line">&#123;</span><br><span class="line"> int i&#x3D;0;</span><br><span class="line"> if(!(strDest &amp;&amp; strSrc))</span><br><span class="line">  return;</span><br><span class="line"> while(strDest[i++] &#x3D; *strSrc++);</span><br><span class="line"> return strDest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>30.关键字static的作用是什么</strong><br>1）static用来修饰一个局部的变量的时候，<br>  生命域是全局的<br>  作用域是局部的</p><p>2）static用来修饰一个模块内的（某一个C的源程序文件）全局变量的时候<br>  生命域不变<br>  作用域减小，只在本模块内有效</p><p>3）static用来修饰一个函数的时候<br>  作用域减小，只在本模块内有效</p><p><strong>31.位转换</strong></p><p> 位 8   7   6   5   4   3   2    1<br> 数 v8  v7  v6  v5  v4  v3  v2   v1</p><p> 转换后：</p><p> 位 8   7   6   5   4   3   2   1<br> 数 v1  v2  v3  v4  v5  v6  v7  v8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unsigned char bit_reverse(unsigned char c)</span><br><span class="line">&#123;</span><br><span class="line">　　unsigned char buf &#x3D; 0;</span><br><span class="line">　　int bit &#x3D; 8;</span><br><span class="line">　　while(bit)</span><br><span class="line">　　&#123;</span><br><span class="line">　　bit--;</span><br><span class="line">　　buf |&#x3D; ((c &amp; 1) &lt;&lt; bit);</span><br><span class="line">　　c &gt;&gt;&#x3D;1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　return buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>32.字符串倒序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1)、inverted_order(char *p)</span><br><span class="line">  &#123;</span><br><span class="line">   char *s1,*s2,tem;</span><br><span class="line">   s1&#x3D;p;</span><br><span class="line">   s2&#x3D;s1+strlen(p)-1;</span><br><span class="line">   while(s1&lt;s2)</span><br><span class="line">   &#123;</span><br><span class="line">    tem&#x3D;*s1;</span><br><span class="line">    *s1&#x3D;*s2;</span><br><span class="line">    *s2&#x3D;tem;</span><br><span class="line">    s1++;</span><br><span class="line">    s2--;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2)、inverted_order(char *p)</span><br><span class="line"> &#123;</span><br><span class="line">  int len &#x3D; strlen(src);</span><br><span class="line">  char *des &#x3D; (char *)malloc(len + 1);</span><br><span class="line">  char *s &#x3D; &amp;src[len -1];</span><br><span class="line">  char *d &#x3D; des;</span><br><span class="line">  while(len-- !&#x3D; 0)</span><br><span class="line">   *d++ &#x3D; *s--;</span><br><span class="line">  *d &#x3D; 0;</span><br><span class="line">  free(des);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>33.TCP通信建立和结束的过程？端口的作用</strong><br>  三次握手:</p><p>  四次挥手:</p><p>  端口是一个软件结构，被客户程序或服务进程用来发送和接收信息。一个端口对应一个16比特的数。服务进程通常使用一个固定的端口。<br>  21端口：21端口主要用于FTP（File Transfer Protocol，文件传输协议）服务。    23端口：23端口主要用于Telnet（远程登录）服务，是Internet上普遍采用的登录和仿真程序。　　<br>  25端口：25端口为SMTP（Simple Mail TransferProtocol，简单邮件传输协议）服务器所开放，<br>  主要用于发送邮件，如今绝大多数邮件服务器都使用该协议。　　<br>  53端口：53端口为DNS（Domain Name Server，域名服务器）服务器所开放，<br>  主要用于域名解析，DNS服务在NT系统中使用的最为广泛。　　<br>  67、68端口：67、68端口分别是为Bootp服务的Bootstrap Protocol Server（引导程序协议服务端）和Bootstrap Protocol Client（引导程序协议客户端）开放的端口。　　<br>  69端口：TFTP是Cisco公司开发的一个简单文件传输协议，类似于FTP。　　<br>  79端口：79端口是为Finger服务开放的，主要用于查询远程主机在线用户、操作系统类型以及是否缓冲区溢出等用户的详细信息。880端口：80端口是为HTTP（HyperText Transport Protocol，超文本传输协议）开放的，这是上网冲浪使用最多的协议，主要用于在WWW（World Wide Web，万维网）服务上传输信息的协议。　　<br>  99端口：99端口是用于一个名为“Metagram Relay”（亚对策延时）的服务，该服务比较少见，一般是用不到的。　　<br>  109、110端口：109端口是为POP2（Post Office Protocol Version 2，邮局协议2）服务开放的，<br>  110端口是为POP3（邮件协议3）服务开放的，POP2、POP3都是主要用于接收邮件的。　<br>  111端口：111端口是SUN公司的RPC（Remote Procedure Call，远程过程调用）服务所开放的端口，主要用于分布式系统中不同计算机的内部进程通信，RPC在多种网络服务中都是很重要的组件。　　<br>  113端口：113端口主要用于Windows的“Authentication Service”（验证服务）。　　<br>  119端口：119端口是为“Network News Transfer Protocol”（网络新闻组传输协议，简称NNTP）开放的。　　<br>  135端口：135端口主要用于使用RPC（Remote Procedure Call，远程过程调用）协议并提供DCOM（分布式组件对象模型）服务。　　<br>  137端口：137端口主要用于“NetBIOS Name Service”（NetBIOS名称服务）。　　<br>  139端口：139端口是为“NetBIOS Session Service”提供的，主要用于提供Windows文件和打印机共享以及Unix中的Samba服务。　　<br>  143端口：143端口主要是用于“Internet Message Access Protocol”v2（Internet消息访问协议，简称IMAP）。　　<br>  161端口：161端口是用于“Simple Network Management Protocol”（简单网络管理协议，简称SNMP）。　　<br>  443端口：43端口即网页浏览端口，主要是用于HTTPS服务，是提供加密和通过安全端口传输的另一种HTTP。　　<br>  554端口：554端口默认情况下用于“Real Time Streaming Protocol”（实时流协议，简称RTSP）。　　<br>  1024端口：1024端口一般不固定分配给某个服务，在英文中的解释是“Reserved”（保留）。　　<br>  1080端口：1080端口是Socks代理服务使用的端口，大家平时上网使用的WWW服务使用的是HTTP协议的代理服务。　　<br>  1755端口：1755端口默认情况下用于“Microsoft Media Server”（微软媒体服务器，简称MMS）。　　<br>  4000端口：4000端口是用于大家经常使用的QQ聊天工具的，再细说就是为QQ客户端开放的端口，QQ服务端使用的端口是8000。　　<br>  5554端口：在今年4月30日就报道出现了一种针对微软lsass服务的新蠕虫病毒——震荡波（Worm.Sasser），该病毒可以利用TCP 5554端口开启一个FTP服务，主要被用于病毒的传播。　　<br>  5632端口：5632端口是被大家所熟悉的远程控制软件pcAnywhere所开启的端口。　　<br>  8080端口：8080端口同80端口，是被用于WWW代理服务的，可以实现网页浏览。</p><p><strong>34.地址解析协议（ARP）的作用是将IP地址转换成物理地址；反地址解析协议（RARP）则负责将物理地址转换成IP地址。</strong></p><p><strong>35.已知数组table，用宏求元素个数。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　COUNT(table)  (sizeof(table)&#x2F;sizeof(table[0]));</span><br></pre></td></tr></table></figure><p><strong>36.全局变量和局部变量的区别。</strong></p><p>全局变量,储存在静态区.进入main函数之前就被创建.生命周期为整个源程序;<br>局部变量,在栈中分配.在函数被调用时才被创建.生命周期为函数内。</p><p><strong>37.死锁的四个条件及处理方法。</strong><br>(1)<em>互斥条件<em>：一个资源每次只能被一个进程使用。<br>(2)</em>请求与保持条件<em>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>(3)</em>不剥夺条件</em>:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>(4)<em>循环等待条件</em>:若干进程之间形成一种头尾相接的循环等待资源关系。  </p><p>解决死锁的方法分为死锁的<strong>预防</strong>，<strong>避免</strong>，<strong>检测与恢复</strong>三种.</p><p><strong>38.进程调度策略。</strong><br>先进先出算法<br>最短CPU运行期优先调度算法<br>轮转法<br>多级队列方法</p><p><strong>39.时间换空间、空间换时间的例子。</strong></p><p>　　冒泡排序 — 时间换空间<br>　　快速排序，堆排序 — 空间换时间  </p><p><strong>40.static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？</strong></p><p>全局变量(外部变量)的说明之前再加static就构成了静态的全局变量。全局变量本身就是静态存储方式,静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。<br>这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。<br>而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效。<br>从以上分析可以看出，把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。<br>把全局变量改变为静态变量后是改变了它的作用域,限制了它的使用范围。<br>static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件.</p><p><em>static全局变量与普通的全局变量有什么区别：</em><br>static全局变量只初使化一次，防止在其他文件单元中被引用</p><p><em>static局部变量和普通局部变量有什么区别：</em><br>static局部变量只被初始化一次，下一次依据上一次结果值</p><p><em>static函数与普通函数有什么区别：</em><br>static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</p><p><strong>41.程序的局部变量存在于<em>（堆栈）</em>中，全局变量存在于<em>（静态区）</em>中，动态申请数据存在于<em>（堆）</em>中。</strong></p><p><strong>42.软件测试都有哪些种类?</strong></p><p>  人工测试：个人复查、抽查和会审<br>  机器测试：黑盒测试（针对系统功能的测试 ）和白盒测试 （测试函数功能，各函数接口）</p><p><strong>43.堆栈溢出一般是由什么原因导致的？</strong><br>    没有回收垃圾资源。</p><p><strong>44.写出float x 与“零值”比较的if语句。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(x&gt;0.000001&amp;&amp;x&lt;-0.000001)</span><br></pre></td></tr></table></figure><p><strong>45.内存对齐问题的原因?</strong></p><p> 平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据；<br> 性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐，因为为了访问未对齐的内存，处理器需要做两次内存访问，而对齐的内存访问仅需要一次。</p><p><strong>46.比较一下进程和线程的区别？</strong></p><p><em>（1）调度：</em><br>线程是CPU调度和分派的基本单位<br>进程是资源分配的最小单位</p><p><em>（2）拥有资源：</em><br>线程自己一般不拥有资源（除了必不可少的程序计数器，一组寄存器和栈），但他可以去访问其所属进程的资源，如进程代码，数据段以及系统资源（已打开的文件，I/O设备等）。</p><p><em>（3）系统开销：</em><br>在进程切换的时候，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置；<br>而线程切换只需要保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作，从而能更有效地使用系统资源和提高系统吞吐量。<br>可见，进程切换的开销也远大于线程切换的开销。</p><p><em>（4）编程调试：</em><br>进程编程调试简单可靠性高，但是创建销毁开销大；<br>线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p><p><em>（5）进程间不会相互影响；<br>线程一个线程挂掉将导致整个进程挂掉</em></p><p>进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。<br>每个线程有自己的堆栈。</p><p><strong>47.几个关于动态内存的相似案例</strong><br>（1）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void getmemory(char *p)</span><br><span class="line">&#123;</span><br><span class="line">  p&#x3D;(char *) malloc(100);</span><br><span class="line">  strcpy(p,&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">  char *str&#x3D;NULL;</span><br><span class="line">  getmemory(str);</span><br><span class="line">  printf(&quot;%s&#x2F;n&quot;,str);</span><br><span class="line">  free(str);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险.</p><p>（2）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void GetMemory(char *p)</span><br><span class="line">&#123;</span><br><span class="line"> 　p &#x3D; (char *)malloc(100);</span><br><span class="line">&#125;</span><br><span class="line">void Test(void) </span><br><span class="line">&#123;</span><br><span class="line"> 　char *str &#x3D; NULL;</span><br><span class="line"> 　GetMemory(str); </span><br><span class="line"> 　strcpy(str, &quot;hello world&quot;);</span><br><span class="line"> 　printf(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问运行Test函数会有什么样的结果？<br> 答：程序崩溃。因为GetMemory并不能传递动态内存，Test函数中的 str一直都是 NULL。strcpy(str, “hello world”);将使程序崩溃。</p><p>（3）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void GetMemory2(char **p, int num)</span><br><span class="line">&#123;</span><br><span class="line"> 　*p &#x3D; (char *)malloc(num);</span><br><span class="line">&#125;</span><br><span class="line">void Test(void)</span><br><span class="line">&#123;</span><br><span class="line"> char *str &#x3D; NULL;</span><br><span class="line"> GetMemory(&amp;str, 100);</span><br><span class="line"> strcpy(str, &quot;hello&quot;); </span><br><span class="line"> printf(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问运行Test函数会有什么样的结果？<br> 答：（1）能够输出hello<br>    （2）内存泄漏</p><p>（4）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char *GetMemory(void)</span><br><span class="line">&#123; </span><br><span class="line"> 　char p[] &#x3D; &quot;hello world&quot;;</span><br><span class="line"> 　return p;</span><br><span class="line">&#125;</span><br><span class="line">void Test(void)</span><br><span class="line">&#123;</span><br><span class="line"> 　char *str &#x3D; NULL;</span><br><span class="line"> 　str &#x3D; GetMemory(); </span><br><span class="line"> 　printf(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 请问运行Test函数会有什么样的结果？<br> 答：可能是乱码。因为GetMemory返回的是指向“栈内存”的指针，该指针的地址不是 NULL，但其原现的内容已经被清除，新内容不可知。</p><p>（5）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Test(void)</span><br><span class="line">&#123;</span><br><span class="line">  char *str &#x3D; (char *) malloc(100);</span><br><span class="line">  strcpy(str, “hello”);</span><br><span class="line">  free(str);     </span><br><span class="line">  if(str !&#x3D; NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    strcpy(str, “world”); </span><br><span class="line">    printf(str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问运行Test函数会有什么样的结果？<br> 答：篡改动态内存区的内容，后果难以预料，非常危险。因为free(str);之后，str成为野指针，if(str != NULL)语句不起作用。野指针不是NULL指针，是指向被释放的或者访问受限内存指针。造成原因：指针变量没有被初始化任何刚创建的指针不会自动成为NULL；指针被free或delete之后，没有置NULL；指针操作超越了变量的作用范围，比如要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。</p><p><strong>48.进程间通信方式：管道、命名管道、消息队列、共享内存、信号、信号量、套接字。</strong><br> (1) 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。<br>       进程的亲缘关系通常是指父子进程关系。<br> (2) 有名管道 (named pipe) ：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。<br> (3) 信号量( semophore ) ：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。<br>      它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。<br>      因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br> (4) 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。<br>      消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。<br> (5) 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br> (6) 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，<br>      这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，<br>      如信号量，配合使用，来实现进程间的同步和通信。<br> (7) 套接字( socket ) ： 套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 </p><p><strong>XX.线程间通信方式：临界区、互斥量、信号量、事件。</strong><br>（1）临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；<br>（2）互斥量（synchronized/lock）：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所有可以保证公共资源不会被多个线程同时访问。<br>（3）信号量（semghare）:为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。<br>（4）事件/信号（wait/notify）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><p><strong>49.宏和函数的优缺点？</strong><br> (1) 函数调用时，先求出实参表达式的值，然后带入形参。而使用带参数的宏只是进行简单的字符替换。<br> (2) 函数调用是在程序运行时处理的，分配临时的内存单元；<br>     而宏展开则是在编译时进行的，在展开时并不分配内存单元，不进行值的传递处理，也没有“返回值”的概念。<br> (3) 对函数中的实参和形参都要定义类型，二者的类型要求一致，应进行类型转换；<br>     而宏不存在类型问题，宏名无类型，它的参数也是无类型，只是一个符号代表，展开时带入指定的字符即可。宏定义时，字符串可以是任何类型的数据。<br> (4) 调用函数只可得到一个返回值，而宏定义可以设法得到几个结果。<br> (5) 使用宏次数多时，宏展开后源程序长，因为每次展开一次都使程序增长，而函数调用不使源程序变长。<br> (6) 宏替换不占运行时间，只占编译时间；而函数调用则占运行时间（分配单元、保留现场、值传递、返回）。</p><p><strong>50.c和c++的一些不同点（从语言本身的角度）</strong><br> 1）c++源于c，c++最重要的特性就是引入了面向对象机制，class关键字。<br> 2）c++中，变量可以在任何地方声明；c中，局部变量只能在函数开头声明。<br> 3）c++中，const型常量是编译时常量；c中，const常量只是只读的变量。<br> 4）c++有&amp;引用;c没有<br> 5）c++的struct声明自动将结构类型名typedef；c中struct的名字只在结构标签名字空间中，不是作为一种类型出现<br> 6）c语言的main函数可以递归调用;c++中则不可以<br> 7）c中，void * 可以隐式转换成其他指针类型；c++中要求现实转换，否则编译通不过</p><p><strong>51.由C/C++编译的程序占用的内存分为以下几个部分</strong><br> 1、栈区(stack)： 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br> 2、堆区(heap)： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。<br>                注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br> 3、全局区(static)： 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，<br>                   未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后有系统释放 。<br> 4、文字常量区： 常量字符串就是放在这里的， 程序结束后由系统释放。<br> 5、程序代码区： 存放函数体的二进制代码。</p><p><strong>52.线程同步的方法：信号量、条件变量、互斥锁。</strong></p><p><strong>53. 关键字volatile有什么含意?并给出三个不同的例子。</strong><br> 一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。<br> 下面是volatile变量的几个例子：</p><p> 1) 并行设备的硬件寄存器（如：状态寄存器）<br> 2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)<br> 3) 多线程应用中被几个任务共享的变量 </p><p> 回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。<br> 嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。<br> 假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，<br> 看一下这家伙是不是真正懂得volatile完全的重要性。</p><p> 1) 一个参数既可以是const还可以是volatile吗？解释为什么。<br> 2) 一个指针可以是volatile 吗？解释为什么。<br> 3) 下面的函数有什么错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int square(volatile int * ptr) &#123;</span><br><span class="line">   return * ptr * * ptr;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 下面是答案：</p><p> 1) 是的。一个例子是只读的状态寄存器。<br>   它是volatile因为它可能被意想不到地改变。<br>   它是const因为程序不应该试图去修改它。<br> 2) 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。<br> 3) 这段代码的有个恶作剧。这段代码的目的是用来返指针<em>ptr指向值的平方，但是，<br>   由于</em>ptr指向一个volatile型参数，编译器将产生类似下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int square(volatile int *ptr) &#123;</span><br><span class="line">  int a,b;</span><br><span class="line">  a &#x3D; *ptr;</span><br><span class="line">  b &#x3D; *ptr;</span><br><span class="line">  return a * b;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>  由于* ptr的值可能被意想不到地该变，因此a和b可能是不同的。<br>  结果，这段代码可能返不是你所期望的平方值！<br>  正确的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long square(volatile int *ptr) &#123;</span><br><span class="line">  int a;</span><br><span class="line">  a &#x3D; *ptr;</span><br><span class="line">  return a * a;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>  Volatile 关键字告诉编译器不要持有变量的临时性拷贝。一般用在多线程程序中，<br>  以避免在其中一个线程操作该变量时，将其拷贝入寄存器。<br> 请看以下情形:<br> A线程将变量复制入寄存器，然后进入循环，反复检测寄存器的值是否满足一定条件(它期待B线程改变变量的值。在此种情况下，当B线程改变了变量的值时，已改变的值对其在寄存器的值没有影响。所以A线程进入死循环。<br>  volatile 就是在此种情况下使用。  </p><p><strong>54.操作系统的内存分配一般有哪几种方式，各有什么优缺点？</strong><br> 定长和变长。<br> 变长：内存时比较灵活，但是易产生内存碎片。<br> 定长：灵活性差，但分配效率较高，不会产生内存碎片 </p><p><strong>55.全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？</strong><br> 答：可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错 </p><p><strong>56.ICMP（ICMP协议对于网络安全具有极其重要的意义）功能主要有：</strong><br> · 侦测远端主机是否存在。<br> · 建立及维护路由资料。<br> · 重导资料传送路径。<br> · 资料流量控制。</p><p><strong>57.列举几种进程的同步机制</strong>（比较其优缺点，待完善。）<br>1.原子操作<br>2.信号量机制<br>3.自旋锁<br>4.管程<br>5.会合<br>6.分布式系统</p><p><strong>58.进程死锁的原因</strong><br>资源竞争及进程推进顺序非法</p><p><strong>59.死锁的处理</strong><br>1.鸵鸟策略<br>2.预防策略<br>3.避免策略<br>4.检测与解除死锁</p><p><strong>60.类的静态成员和非静态成员有何区别？</strong><br>类的静态成员每个类只有一个<br>非静态成员每个对象一个</p><p><strong>61.软件测试有哪些种类？</strong><br>黑盒：针对系统功能的测试<br>白合：测试函数功能，各函数接口</p><p><strong>62.Windows消息调度机制：指令堆栈、指令队列、消息队列</strong></p><p><strong>63.程序的局部变量存在于（栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）中。</strong></p><p><strong>64.不使用库函数，编写函数int strcmp(char * source, char * dest) 相等返回0，不等返回-1。</strong></p><p>答案1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int strcmp(char *source, char *dest)</span><br><span class="line">&#123;</span><br><span class="line">  assert((source!&#x3D;NULL) &amp;&amp; (dest!&#x3D;NULL));</span><br><span class="line">  int i , j;</span><br><span class="line">  for( i&#x3D;0; source[i]&#x3D;&#x3D;dest[i]; i++);</span><br><span class="line">  if (source[i]&#x3D;&#x3D;&#39;\0&#39; &amp;&amp; dest[i]&#x3D;&#x3D;&#39;\0&#39;)</span><br><span class="line">    return 0;</span><br><span class="line">  else</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int strcmp(char *source, char *dest)</span><br><span class="line">&#123;</span><br><span class="line">  while ((*source !&#x3D; &#39;\0&#39;) &amp;&amp; (*source &#x3D;&#x3D; *dest) &amp;&amp; (*dest !&#x3D;&#x3D; &#39;\0&#39;))</span><br><span class="line">  &#123;</span><br><span class="line">    source++;</span><br><span class="line">    dest++;</span><br><span class="line">  &#125;</span><br><span class="line">  return ((*source)-(*dest))?-1:0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>65.写一函数int fun(char * p)判断一字符串是否为回文，是返回1，不是返回0，出错返回-1。</strong></p><p>答案1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int fun(char *p)</span><br><span class="line">&#123;</span><br><span class="line">  if(p&#x3D;&#x3D;NULL)</span><br><span class="line">    return -1;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int judge &#x3D; 0;</span><br><span class="line">    length &#x3D; strlen(p);</span><br><span class="line">    for(i&#x3D;0; i&lt;length&#x2F;2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      if(p[i]!&#x3D;p[length-1-i])</span><br><span class="line">      &#123;</span><br><span class="line">        judge &#x3D; 0;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (judge &#x3D;&#x3D; 0)</span><br><span class="line">      return 0;</span><br><span class="line">    else</span><br><span class="line">      return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int fun(char *p)</span><br><span class="line">&#123;</span><br><span class="line">  int len &#x3D; strlen(p)-1;</span><br><span class="line">  char *q &#x3D; p + len;</span><br><span class="line">  if(!p)</span><br><span class="line">    return -1;</span><br><span class="line">  while(p &lt; q)</span><br><span class="line">  &#123;</span><br><span class="line">    if((*p++)!&#x3D;(*q--))</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>66.异步IO和同步IO区别</strong><br>如果是同步IO，当一个IO操作执行时，应用程序必须等待，直到此IO执行完，<br>相反，异步IO操作在后台运行，IO操作和应用程序可以同时运行，提高系统性能，提高IO流量；</p><p>在同步文件IO中，线程启动一个IO操作然后就立即进入等待状态，直到IO操作完成后才醒来继续执行，<br>而异步文件IO中，线程发送一个IO请求到内核，然后继续处理其他事情，内核完成IO请求后，将会通知线程IO操作完成了。</p><p><strong>67. 效率最高的算法<br>(1)a=b * 2;<br>(2)a=b/4;<br>(3)a=b%8;<br>(4)a=b/8 * 8+b%4;<br>(5)a=b * 15。</strong></p><p>答案：<br> (1) a=b * 2 -&gt; a=b&lt;&lt;1;<br> (2) a=b/4 -&gt; a=b&gt;&gt;2;<br> (3) a=b%8 -&gt; a=b&7;<br> (4) a=b/8 * 8+b%4 -&gt; a=((b&gt;&gt;3)&lt;&lt;3)+(b&amp;3)；<br> (5) a=b * 15 -&gt; a=(b&lt;&lt;4)-b。</p><p><strong>68.内存管理MMU的作用</strong></p><ul><li>内存分配和回收</li><li>内存保护</li><li>内存扩充</li><li>地址映射 </li></ul><p><strong>69.不调用C++/C的字符串库函数，请编写函数strcpy()函数</strong><br>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *strcpy(char *strDest, const char *strSrc)</span><br><span class="line">&#123;</span><br><span class="line">  int i &#x3D; 0;</span><br><span class="line">  if(!(strDest &amp;&amp; strSrc))</span><br><span class="line">    return;</span><br><span class="line">  while (strDest[i++] &#x3D; *strSrc++);</span><br><span class="line">  return strDest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>70.关键字static的作用是什么</strong></p><p>1)static用来修饰一个局部的变量的时候，<br>  生命域是全局的<br>  作用域是局部的</p><p>2)static用来修饰一个模块内的（某一个C的源程序文件）全局变量的时候<br>  生命域不变<br>  作用域减小，只在本模块内有效</p><p>3)static用来修饰一个函数的时候<br>  作用域减小，只在本模块内有效</p><p><strong>71.堆和栈的区别</strong></p><p>（1）存储内容不同<br>栈：在函数调用时，栈中存放的是函数中（最底下是函数调用后的下一条指令）的各个参数（局部变量）。<br>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员分配。</p><p>（2）管理方式上不同<br>栈：由系统自动分配并释放空间。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间，当对应的生存周期结束后栈空间被自动释放。<br>堆：需要程序员指定大小手动申请和手动释放，在C语言中使用malloc函数申请，使用free函数释放。</p><p>（3）空间大小不同<br>栈：获取空间较小。在Windows下一般大小是1M或2M，当剩余栈空间不足时，分配失败overflow。<br>堆：获得空间根据系统的有效虚拟内存有关，比较灵活、大。</p><p>（4）能否产生碎片不同<br>栈：不会产生碎片，空间连续。<br>堆：采用的是链表的存储方式，会产生碎片。</p><p>（5）生长方向不同<br>栈： 向低地址扩展的数据结构，是一块连续的内存区域。<br>堆： 向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表空闲内存地址来存储的，自然不连续，而链表的遍历方向是由低地址向高地址。</p><p>（6）分配方式不同<br>栈：有2种分配方式：静态分配和动态分配，静态由编译器完成，例如局部变量；动态由malloc函数实现，由编译器进行释放。<br>堆： 都是动态分配的，没有静态分配的堆。</p><p>（7）分配效率不同<br>栈：由系统自动分配，速度较快。但程序员无法控制。<br>堆：由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。</p><p><strong>72.Volatile与Register的区别</strong></p><p>volatile是易变的，不稳定的意思，volatile是关键字，是一种类型修饰符，用它修饰的变量表示可以被某些编译器未知的因素更改，比如操作系统、硬件或者其他线程等，遇到这个关键字声明的变量，编译器对访问该变量的代码不在进行优化，从而可以提供对特殊地址的稳定访问。</p><p>状态要经常变化的，为了防止我们编译优化而导致的存取的数据不同步的问题，这时我们就需要用到volatile。<br>那具体到什么场景下需要用到volatile关键字呢？</p><p>1、并行设备的硬件寄存器（如：状态寄存器）；<br>2、一个中断服务子程序中会访问到的非自动变量()；<br>3、多线程应用中被几个任务共享的变量；</p><p>上面提到了非自动变量，这里进一步对几种变量做一番解释：<br>自动变量：是在函数内部定义和使用的变量，它是局部变量。<br>非自动变量：有两种，一种是全局变量，一种是静态变量。</p><p>register这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。注意是尽可能，不是绝对。你想想，一个CPU 的寄存器也就那么几个或几十个，你要是定义了很多很多register 变量，它累死也可能不能全部把这些变量放入寄存器吧。</p><p><strong>73.并发(concurrency)和并行(parallelism)</strong><br>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以，现在的cpu都是往多核方面发展。</p><hr><h2 id="第二章-好的编程习惯"><a href="#第二章-好的编程习惯" class="headerlink" title="第二章 好的编程习惯"></a>第二章 好的编程习惯</h2><ol><li>变量的声明和初始化的位置应该放在一起</li><li>遵循一致的命名约定。</li><li>描述性变量/方法名称。例如不常见的缩写Sort_PT()可能会令人困惑：PT是什么意思？如果您不能在第二个检查中回答，请优化名称以Sort_PostType()获得更好的理解。</li><li>缩进和换行符小写。</li><li>不要把代码放在一个脚本中。根据主要功能将代码分离成不同的文件。</li><li>太大的switch-case，要考虑使用函数指针数组优化。</li><li>在运算符和变量之间加上空格。</li></ol><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> embedded </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>life credo</title>
      <link href="/2019/07/16/life%20credo/"/>
      <url>/2019/07/16/life%20credo/</url>
      
        <content type="html"><![CDATA[<h2 id="1-不以物喜，不以己悲"><a href="#1-不以物喜，不以己悲" class="headerlink" title="1.不以物喜，不以己悲"></a>1.不以物喜，不以己悲</h2><h2 id="2-见贤思齐焉，见不贤而内自省也"><a href="#2-见贤思齐焉，见不贤而内自省也" class="headerlink" title="2.见贤思齐焉，见不贤而内自省也"></a>2.见贤思齐焉，见不贤而内自省也</h2><h2 id="3-格物致知"><a href="#3-格物致知" class="headerlink" title="3.格物致知"></a>3.格物致知</h2><p>探究事物原理，而从中获得智慧</p><h2 id="4-择其善者而从之，其不善者而改之"><a href="#4-择其善者而从之，其不善者而改之" class="headerlink" title="4.择其善者而从之，其不善者而改之"></a>4.择其善者而从之，其不善者而改之</h2><h2 id="5-什么都可以等，唯有尽孝需趁早"><a href="#5-什么都可以等，唯有尽孝需趁早" class="headerlink" title="5.什么都可以等，唯有尽孝需趁早"></a>5.什么都可以等，唯有尽孝需趁早</h2><h2 id="6-上善若水"><a href="#6-上善若水" class="headerlink" title="6.上善若水"></a>6.上善若水</h2><p> 居善地(居身安于卑下)，<br> 心善渊(存心宁静深沉)，<br> 言善信(交往有诚有爱)，<br> 正善治(为政天下归顺)，<br> 事善能(做事大有才能)，<br> 动善时(行动善于把握时机)。<br> 夫唯不争(唯有像水这样不争)，<br> 故无忧(才能无过无争)。</p><h2 id="7-生而不有，为而不恃，功成而弗居，夫为弗居，是以不去。"><a href="#7-生而不有，为而不恃，功成而弗居，夫为弗居，是以不去。" class="headerlink" title="7.生而不有，为而不恃，功成而弗居，夫为弗居，是以不去。"></a>7.生而不有，为而不恃，功成而弗居，夫为弗居，是以不去。</h2><h1 id="待续"><a href="#待续" class="headerlink" title="待续~~"></a>待续~~</h1><hr>]]></content>
      
      
      <categories>
          
          <category> thinking about life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令和主题更换</title>
      <link href="/2019/07/15/hexo%20%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/07/15/hexo%20%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建完成后一些简单的命令"><a href="#搭建完成后一些简单的命令" class="headerlink" title="搭建完成后一些简单的命令"></a>搭建完成后一些简单的命令</h1><hr/><h2 id="1-写文章"><a href="#1-写文章" class="headerlink" title="1.写文章"></a>1.写文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n   </span><br><span class="line">$ hexo new [layout] &quot;postname&quot;</span><br></pre></td></tr></table></figure><hr/><h2 id="2-生成静态页面"><a href="#2-生成静态页面" class="headerlink" title="2.生成静态页面"></a>2.生成静态页面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g   </span><br><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><hr/><h2 id="3-启动本地服务，进行文章预览调试"><a href="#3-启动本地服务，进行文章预览调试" class="headerlink" title="3.启动本地服务，进行文章预览调试"></a>3.启动本地服务，进行文章预览调试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s   </span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><hr/><p>或者启动指定端口的本地服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s -p 5000</span><br></pre></td></tr></table></figure><hr/><h2 id="4-部署到github上去"><a href="#4-部署到github上去" class="headerlink" title="4.部署到github上去"></a>4.部署到github上去</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d        </span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h2 id="boss：写完文章后，结合2、4用一行代码完工"><a href="#boss：写完文章后，结合2、4用一行代码完工" class="headerlink" title="boss：写完文章后，结合2、4用一行代码完工"></a>boss：写完文章后，结合2、4用一行代码完工</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><h1 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h1><h2 id="获得主题"><a href="#获得主题" class="headerlink" title="获得主题"></a>获得主题</h2><hr/>hexo的主题列表: [Hexo Themes] (https://hexo.io/themes/)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repository&gt; themes&#x2F;&lt;theme-name&gt;</span><br></pre></td></tr></table></figure><hr/><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>安装完成后，打开 hexo_config.yml, 修改主题modernist</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme：modernist</span><br></pre></td></tr></table></figure><h2 id="编辑主题配置文件"><a href="#编辑主题配置文件" class="headerlink" title="编辑主题配置文件"></a>编辑主题配置文件</h2><p>打开hexo\themes\modernist目录，编辑主题配置文件_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">menu: #配置页头显示哪些菜单</span><br><span class="line">#  Home: &#x2F;</span><br><span class="line">  Archives: &#x2F;archives</span><br><span class="line">  Reading: &#x2F;reading</span><br><span class="line">  About: &#x2F;about</span><br><span class="line">#  Guestbook: &#x2F;about</span><br><span class="line"></span><br><span class="line">excerpt_link: Read More #摘要链接文字</span><br><span class="line">archive_yearly: false #按年存档</span><br><span class="line"></span><br><span class="line">widgets: #配置页脚显示哪些小挂件</span><br><span class="line">  - category</span><br><span class="line">#  - tag</span><br><span class="line">  - tagcloud</span><br><span class="line">  - recent_posts</span><br><span class="line">#  - blogroll</span><br><span class="line"></span><br><span class="line">blogrolls: #友情链接</span><br><span class="line">  - bruce sha&#39;s duapp wordpress: http:&#x2F;&#x2F;ibruce.duapp.com</span><br><span class="line">  - bruce sha&#39;s javaeye: http:&#x2F;&#x2F;buru.iteye.com</span><br><span class="line">  - bruce sha&#39;s oschina blog: http:&#x2F;&#x2F;my.oschina.net&#x2F;buru</span><br><span class="line">  - bruce sha&#39;s baidu space: http:&#x2F;&#x2F;hi.baidu.com&#x2F;iburu</span><br><span class="line"></span><br><span class="line">fancybox: true #是否开启fancybox效果</span><br><span class="line"></span><br><span class="line">duoshuo_shortname: buru #多说账号</span><br><span class="line"></span><br><span class="line">google_analytics:</span><br><span class="line">rss:</span><br></pre></td></tr></table></figure><h2 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd themes&#x2F;modernist</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github + hexo 搭建个人网站教程</title>
      <link href="/2019/07/15/hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
      <url>/2019/07/15/hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-github创建个人仓库"><a href="#1-github创建个人仓库" class="headerlink" title="1.github创建个人仓库"></a>1.github创建个人仓库</h2><p>（1）登录到github账号（如果没有github账号，可以用邮箱注册一个：<a href="https://github.com/" target="_blank" rel="noopener">github注册页面</a>）</p><p>（2）创建一个新的仓库repositories。<br>仓库名应该为：<strong>用户名</strong>.github.io,这个用户名可以使用你的github账号代替。<br><img src="https://s2.ax1x.com/2019/12/24/lC4LWV.png" alt="lC4LWV.png"></p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p>(1)想了解什么是github可以戳这里：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248" target="_blank" rel="noopener">廖雪峰老师讲解github</a></p><p>(2)从<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git官网</a>上下载.<br>下载后安装，在命令行中输入git测试是否安装成功，若安装成功，则会出现以下图片：<br><img src="https://s2.ax1x.com/2019/12/24/lCINjO.png" alt="lCINjO.png"></p><p>(3)安装成功后，将git与github账号绑定，鼠标右击打开git bash，设置user.name 和 user.email配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;github用户名&quot;</span><br><span class="line">git config --global user.email &quot;github注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>生成ssh密钥文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;github注册邮箱（我是QQ邮箱）&quot;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/12/24/lC778I.png" alt="lC778I.png"></p><p>（4）默认不需要密码，找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容复制。（打不开就用记事本打开，然后全选，复制）<br><img src="https://s2.ax1x.com/2019/12/24/lCHkrT.png" alt="lCHkrT.png"></p><p>（5）打开<a href="https://github.com/settings/keys" target="_blank" rel="noopener">github_setting_keys</a>页面，新建new SSH Key.<br><img src="https://s2.ax1x.com/2019/12/24/lCH0QP.png" alt="lCH0QP.png"></p><p>title为标题，随便填。<br>将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH Key.</p><p>在git bash中检测github公钥设置是否成功，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/12/24/lCbI1I.png" alt="lCbI1I.png"><br>如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p><h2 id="3-安装node-js"><a href="#3-安装node-js" class="headerlink" title="3.安装node.js"></a>3.安装node.js</h2><p>因为hexo基于node.js,下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">download | node.js</a><br>下载安装包，检测node.js是否成功，在命令行输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/12/24/lCqMDK.png" alt="lCqMDK.png"><br>注意安装Node.js会包含环境变量及npm的安装,检测npm是否安装成功，在命令行中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/12/24/lCq1ED.png" alt="lCq1ED.png"></p><p>到这里，安装hexo的环境已经全部搭建完成了。</p><h2 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4.安装hexo"></a>4.安装hexo</h2><p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，<br>Hexo框架与以后你自己发布的网页都在这个文件夹中。<br>创建好后，通过命令行进入文件夹中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli &#x2F;&#x2F;使用npm命令安装Hexo，这一步安装时间较长，耐心等待</span><br><span class="line">hexo init blog  &#x2F;&#x2F;初始化我们的博客</span><br></pre></td></tr></table></figure><p>注意，这里的命令都是作用在刚刚创建的Blog文件夹中。<br>为了检测我们的网站雏形，分别按顺序输入以下三条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new test_my_site</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>打开浏览器，输入地址：<br>localhost:4000<br>可以看出我们写出第一篇博客.</p><p>注意，如果访问不了“localhost:4000”，说明4000端口被占用了，换一个端口，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -p 5000</span><br></pre></td></tr></table></figure><p>然后打开“localhost:5000”就可以了</p><h2 id="5-推送网站"><a href="#5-推送网站" class="headerlink" title="5.推送网站"></a>5.推送网站</h2><p>上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为<strong>站点</strong>配置文件，如下图<br><img src="https://s2.ax1x.com/2019/12/24/lCL6oD.png" alt="lCL6oD.png"></p><p>进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为<strong>主题</strong>配置文件，如下图<br><img src="https://s2.ax1x.com/2019/12/24/lCL2JH.png" alt="lCL2JH.png"></p><p>（1）将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：<br><img src="https://s2.ax1x.com/2019/12/24/lCOFfJ.png" alt="lCOFfJ.png"><br>保存站点配置文件。<br>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。</p><p>（2）最后安装Git部署插件，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>（3）分别输入三个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。</p><hr>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影视资源网址</title>
      <link href="/2019/05/12/TV%20source/"/>
      <url>/2019/05/12/TV%20source/</url>
      
        <content type="html"><![CDATA[<h1 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h1><br><pre><code>以下网址有在其他平台需要VIP会员才能看得视频资源如果使用PV端，最好使用谷歌浏览器且装有去广告插件（Adblock Plus）</code></pre><br><h2 id="可-在线-倍速-观看"><a href="#可-在线-倍速-观看" class="headerlink" title="可 在线 倍速 观看"></a>可 在线 倍速 观看</h2><br><ul><li><strong><a href="http://aaqqy.com/" target="_blank" rel="noopener">YY4480</a></strong> <br></li><li><strong><a href="http://www.82tu.cc/index.html" target="_blank" rel="noopener">2TU影院</a></strong> <br></li><li><strong><a href="https://www.dililitv.com/" target="_blank" rel="noopener">嘀哩哩</a></strong><br></li><li><strong><a href="https://qukantv.net/" target="_blank" rel="noopener">去看TV</a></strong><br></li></ul><h2 id="其余片源"><a href="#其余片源" class="headerlink" title="其余片源"></a>其余片源</h2><br><ul><li><strong><a href="https://www.yingshidaquan.info/" target="_blank" rel="noopener">影视大全</a></strong><br></li><li><strong><a href="https://www.dandanzan.com/" target="_blank" rel="noopener">蛋蛋赞</a></strong><br></li><li><strong><a href="http://www.imomoe.jp/" target="_blank" rel="noopener">樱花动漫</a></strong><br></li><li><strong><a href="http://www.8gw.com/" target="_blank" rel="noopener">八哥网</a></strong><br></li><li><strong><a href="https://www.nfmovies.com/" target="_blank" rel="noopener">奈菲影视</a></strong></li></ul><br><hr><h2 id="百度网盘资源分享"><a href="#百度网盘资源分享" class="headerlink" title="百度网盘资源分享"></a>百度网盘资源分享</h2><br><pre><code>百度网盘入口主要用于工具软件、电子书籍、资料的搜索</code></pre><br><ul><li><strong><a href="http://www.panduoduo.net/" target="_blank" rel="noopener">盘多多</a></strong></li></ul><br>]]></content>
      
      
      <categories>
          
          <category> entertainment </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你发现你的磁盘容量由原来的500GB变成了64MB了！</title>
      <link href="/2019/04/24/windows%20%E4%B8%8B%E7%9B%98%E7%AC%A6%E5%AE%B9%E9%87%8F%E5%8F%98%E5%B0%8F/"/>
      <url>/2019/04/24/windows%20%E4%B8%8B%E7%9B%98%E7%AC%A6%E5%AE%B9%E9%87%8F%E5%8F%98%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-按-window-R-键，输入-cmd-，打开命令提示符"><a href="#1-按-window-R-键，输入-cmd-，打开命令提示符" class="headerlink" title="1 按 window + R 键，输入 cmd ，打开命令提示符"></a>1 按 window + R 键，输入 cmd ，打开命令提示符</h2><h2 id="2-查看目前的盘符"><a href="#2-查看目前的盘符" class="headerlink" title="2 查看目前的盘符"></a>2 查看目前的盘符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list disk</span><br></pre></td></tr></table></figure><h2 id="3-找到你要恢复容量的磁盘，记住编号"><a href="#3-找到你要恢复容量的磁盘，记住编号" class="headerlink" title="3 找到你要恢复容量的磁盘，记住编号"></a>3 找到你要恢复容量的磁盘，记住编号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select disk 盘符编号</span><br></pre></td></tr></table></figure><h2 id="4-关闭命令窗，打开-“我的电脑”-gt-”计算机管理”-gt-”磁盘管理”"><a href="#4-关闭命令窗，打开-“我的电脑”-gt-”计算机管理”-gt-”磁盘管理”" class="headerlink" title="4 关闭命令窗，打开 “我的电脑”-&gt;”计算机管理”-&gt;”磁盘管理”"></a>4 关闭命令窗，打开 “我的电脑”-&gt;”计算机管理”-&gt;”磁盘管理”</h2><h2 id="5-找到那个未分配的磁盘，添加新标卷。"><a href="#5-找到那个未分配的磁盘，添加新标卷。" class="headerlink" title="5 找到那个未分配的磁盘，添加新标卷。"></a>5 找到那个未分配的磁盘，添加新标卷。</h2>]]></content>
      
      
      <categories>
          
          <category> acrobatics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁盘容量，disk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how to install color-compile in linux</title>
      <link href="/2019/04/14/color-compile/"/>
      <url>/2019/04/14/color-compile/</url>
      
        <content type="html"><![CDATA[<h2 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1. 下载源码"></a>1. 下载源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;chinaran&#x2F;color-compile&#x2F;</span><br></pre></td></tr></table></figure><hr><h2 id="2-开始编译安装"><a href="#2-开始编译安装" class="headerlink" title="2. 开始编译安装"></a>2. 开始编译安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd color-compile</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><hr><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd color-compile</span><br><span class="line">make TEST</span><br></pre></td></tr></table></figure><hr><h2 id="4-卸载"><a href="#4-卸载" class="headerlink" title="4. 卸载"></a>4. 卸载</h2><p>Makefile中没有make uninstall的命令<br>查看Makefile中install命令的执行操作，我们可以猜测出卸载的途径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">install:</span><br><span class="line">    cp color_compile &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">    cp out_color_info &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line">    echo &#39;alias gcc&#x3D;&quot;color_compile gcc&quot;&#39; &gt;&gt; $(ALIAS_FILE)</span><br><span class="line">    echo &#39;alias g++&#x3D;&quot;color_compile g++&quot;&#39; &gt;&gt; $(ALIAS_FILE)</span><br><span class="line">    echo &#39;alias make&#x3D;&quot;color_compile make&quot;&#39; &gt;&gt; $(ALIAS_FILE)</span><br></pre></td></tr></table></figure><p>卸载命令</p><h1 id="删掉或者注释掉-ALIAS-FILE-即-bashrc-中以下几行"><a href="#删掉或者注释掉-ALIAS-FILE-即-bashrc-中以下几行" class="headerlink" title="删掉或者注释掉 $(ALIAS_FILE) 即 ~/.bashrc 中以下几行"></a>删掉或者注释掉 $(ALIAS_FILE) 即 ~/.bashrc 中以下几行</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias gcc&#x3D;&quot;color_compile gcc&quot;</span><br><span class="line">alias g++&#x3D;&quot;color_compile g++&quot;</span><br><span class="line">alias make&#x3D;&quot;color_compile make&quot;</span><br></pre></td></tr></table></figure><p>彻底卸载可以删除二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;color_compile</span><br><span class="line">rm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;out_color_info</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> color </tag>
            
            <tag> compile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu emacs 的傻瓜安装与卸载教程</title>
      <link href="/2019/04/01/ubuntu%20emacs%20%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/"/>
      <url>/2019/04/01/ubuntu%20emacs%20%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="install"><a href="#install" class="headerlink" title="install"></a>install</h1><p>To ensure a clean installation, please follow these steps:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install</span><br><span class="line">$ sudo apt-get purge emacs emacs-snapshot-common emacs-snapshot-bin-common emacs-snapshot emacs-snapshot-el emacs-snapshot-gtk emacs23 emacs23-bin-common emacs23-common emacs23-el emacs23-nox emacs23-lucid auctex apel emacs24 emacs24-bin-common emacs24-common emacs24-common-non-dfsg emacs24-el</span><br></pre></td></tr></table></figure><p>To add this PPA:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:cassou&#x2F;emacs</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install emacs24 emacs24-el emacs24-common-non-dfsg</span><br></pre></td></tr></table></figure><p>the end:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ emacs</span><br></pre></td></tr></table></figure><p>按照以上顺序执行完即可</p><h1 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove emacs</span><br><span class="line">或</span><br><span class="line">sudo apt-get remove --auto-remove emacs24 emacs24-el emacs24-common-non-dfsg</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> emacs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>love, death and robot</title>
      <link href="/2019/03/16/love,%20death%20and%20robot/"/>
      <url>/2019/03/16/love,%20death%20and%20robot/</url>
      
        <content type="html"><![CDATA[<h2 id="第一集-桑尼的优势"><a href="#第一集-桑尼的优势" class="headerlink" title="第一集 桑尼的优势"></a>第一集 桑尼的优势</h2><p>性别，恐惧，暴力等主题。都在突出强暴二字。<br>在比赛过程中，女主是拿自己的命作为赌注，输了自己就死了，赢了，也就赢得了尊严。<br>她的优势就是对死亡的恐惧，而别人输了比赛，最多只是意念操控的怪兽没了。<br>她是复仇成功了呢？还是正义得到了声张？</p><h2 id="第二集-三个机器人"><a href="#第二集-三个机器人" class="headerlink" title="第二集 三个机器人"></a>第二集 三个机器人</h2><p>在几千年后，人类灭亡了，这三个机器人聚集在了一起，他们原本是在各自生产线上，为人类做着工作，没有多余的程序，不懂世间的一切，人类文明的一切。<br>他们在马路上悠闲的走着，走走停停，没有感情的讨论着人类，人类的物质，人类的文明，人类的灭亡。<br>他们发现旧时代的机器，试图去理解亲情这种高层次的情感，然而还是不太容易。不过即使是这样，高个子机器人还是从它的祖先身上拆下了一只眼睛，装在了自己的身上。虽然所谓的亲情并不存在，但这种祖辈传承下来的东西却不会消失，并将继续传承下去。这同样也是在暗示着人类的进化与发展。</p><p>似乎灭亡好像迟早要来，死亡也没那么可怕了。一切都是咎由自取吧~</p><h2 id="第三集-证人"><a href="#第三集-证人" class="headerlink" title="第三集 证人"></a>第三集 证人</h2><p>男女主仿佛是认识，但是又不是认识的。这一集结局很反转，要看两遍我好像才能体会到其中的主题。<br>一个极力想解释、表达自己，一个由于对未知的恐惧、仇恨极力的回避交流甚至暴力对抗，有点像一对小情侣，发生了矛盾，但是缺乏交流沟通，各自有各自的立场，从而形成相互伤害的恶性循环。<br>“爱”是真的能拯救世界的。<br>他不是人与人之间因为荷尔蒙的分泌产生的爱，而是在荷尔蒙退去后人与人之间遇到了沟通障碍但是仍能相互包容理解的爱。<br>虽然矛盾与冲突不可避免，但如何让矛盾最小化甚至消除矛盾才是人类进步的或者说需要学习的地方啊~</p><h2 id="第四集-机动装甲"><a href="#第四集-机动装甲" class="headerlink" title="第四集 机动装甲"></a>第四集 机动装甲</h2><p>在影片的最后，仿佛人类才是入侵者。<br>但是，人类有感情，心中有大义，我也希望自己是那种在关键危急时刻可以牺牲自我保全整体的人~<br>有勇气按下自爆键的人，帅呆了==</p><h2 id="第五集-吸魂者"><a href="#第五集-吸魂者" class="headerlink" title="第五集 吸魂者"></a>第五集 吸魂者</h2><p>这一集给我的感觉是，不要触犯他人的领地，侵犯他人的隐私。<br>不然，会有恶魔与你对抗。<br>死亡很暴力，生命很脆弱。</p><h2 id="第六集-当酸奶统治世界"><a href="#第六集-当酸奶统治世界" class="headerlink" title="第六集 当酸奶统治世界"></a>第六集 当酸奶统治世界</h2><p>总觉得在影射某个东西，某个潜意识当中希望得到却又害怕得到的东西。<br>很有趣的一集。</p><h2 id="第七集-裂缝以外"><a href="#第七集-裂缝以外" class="headerlink" title="第七集 裂缝以外"></a>第七集 裂缝以外</h2><p>活在虚幻的世界里到底是不是一件快乐的事情？<br>有时候真相是残酷的，是赤裸裸的，珍惜那些不愿意告诉你真相的人，他们只愿你能够活的无忧无虑，赤诚善良。<br>在你人生面临灾难和巨大压力时，最后仅能留住的美好和希望，却是最深渊的恐惧。</p><h2 id="第八集-祝有好收获"><a href="#第八集-祝有好收获" class="headerlink" title="第八集 祝有好收获"></a>第八集 祝有好收获</h2><p>只有自己强大起来了，才能去保护那些受欺负的。<br>有一篇知乎上的文章解说的很好，短小而精悍，我拿来借鉴一下。</p><p>狐狸很明显象征着“中国”这一文明概念，“妖”象征原始，“人”象征现代<br>亦人亦妖状态是原始的中国，朦朦胧胧田园之美，同时也很腐朽<br>洋人来了，妖的状态就褪去了，完全变成了洋人眼中的人的状态<br>经过工业化、现代化改造之后，重新变回了那个妖的状态（找回自我），只不过内在与以往完全不同了，机械狐是全新的现代化中国</p><p>作者：UFO<br>链接：<a href="https://www.zhihu.com/question/316926430/answer/632229266" target="_blank" rel="noopener">知乎</a></p><h2 id="第九集-垃圾场"><a href="#第九集-垃圾场" class="headerlink" title="第九集 垃圾场"></a>第九集 垃圾场</h2><p>让我看了很不是滋味！<br>难道世界终有一天会变成一个诺大的垃圾场吗？<br>难道这些垃圾只能变成废物，不能循环、利用、或者是销毁吗？<br>我想总有办法阻止或者延缓那一天的到来吧？</p><h2 id="第十集-变形者"><a href="#第十集-变形者" class="headerlink" title="第十集 变形者"></a>第十集 变形者</h2><p>有一些动物，异于常人，人类就会觉得不一样并且歧视他们。<br>任何事物有好有坏，好的也要当朋友一样看待，坏的也算是共同的敌人，给与相同的尊重，即使物种不一样<br>他们没有恶意，死了，也没有受到人类应有的待遇与尊重，应该要思考一下人类与动物的关系了，太讽刺了<br>希望那些变形者，本性是善良的。</p><h2 id="第十一集-帮手"><a href="#第十一集-帮手" class="headerlink" title="第十一集 帮手"></a>第十一集 帮手</h2><p>人在危难时刻被激发出来的求生欲，转化的力量是无穷的。</p><h2 id="第十二集-古鱼复苏"><a href="#第十二集-古鱼复苏" class="headerlink" title="第十二集 古鱼复苏"></a>第十二集 古鱼复苏</h2><p>亦真亦假，年轻人终究不听老一辈人的话语，到头来牺牲的是自己的生命。</p><h2 id="第十三集-幸运十三"><a href="#第十三集-幸运十三" class="headerlink" title="第十三集 幸运十三"></a>第十三集 幸运十三</h2><p>可能每个人的心里，都有一个幸运物，你带着它过关斩将，闯过一个又一个的难关。<br>对旧物的热爱与不舍，毕竟它承载着你的太多的回忆，她曾经与你一起并肩作战过。<br>当人与一个物品产生感情时，一切都是那么的和谐与美好。<br>这让我想起了，有人跟我说过，时间万物都是有感情，有思想的。只是人类不懂，包括一张桌子，一支笔，如果陪伴你久了，也会对你产生感情。<br>那就希望那些被我遗弃的物品，不要怨恨我。</p><h2 id="第十四集-齐马的作品"><a href="#第十四集-齐马的作品" class="headerlink" title="第十四集 齐马的作品"></a>第十四集 齐马的作品</h2><p>万物都是要回归原始的<br>对真理的探寻，就是回家。感激周围的环境，勿忘初心。<br>专注于一项的简单的事情中，是最快乐的。<br>很喜欢这一集~</p><h2 id="第十五集-盲点"><a href="#第十五集-盲点" class="headerlink" title="第十五集 盲点"></a>第十五集 盲点</h2><p>备份是个好习惯，希望你也有。</p><h2 id="第十六集-冰河时代"><a href="#第十六集-冰河时代" class="headerlink" title="第十六集 冰河时代"></a>第十六集 冰河时代</h2><p>这是一部以上帝的视角来观看整个地球的发展史。经历过冰河时代、恐龙时代、石器时代、文艺复兴、战争、战争后的重塑等等。脑洞很大，具有讽刺意味。最终的结局是，经过地球的毁灭后，一切又重新开始，回到了恐龙时代。<br>人类文明在其他文明的眼中，也不过如此。</p><h2 id="第十七集-不一样的历史"><a href="#第十七集-不一样的历史" class="headerlink" title="第十七集 不一样的历史"></a>第十七集 不一样的历史</h2><p>历史是自己创造的。<br>历史的偶然性和必然性。<br>偶然性指的是希特勒的各种死法。<br>必然性指的是世界大战总会爆发，人类总会登上月球。</p><h2 id="第十八集-秘密战争"><a href="#第十八集-秘密战争" class="headerlink" title="第十八集 秘密战争"></a>第十八集 秘密战争</h2><p>一群精英的战士知道了这个恶魔出没的古老传说，依然选择坚守阵地，用最悲壮的方式迎接死亡。我很沉重。</p><hr># 未完待续~<hr>]]></content>
      
      
      <categories>
          
          <category> thinking about life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Picture test</title>
      <link href="/2019/03/16/pictures%20test/"/>
      <url>/2019/03/16/pictures%20test/</url>
      
        <content type="html"><![CDATA[<hr><ul><li><p>最爱的金毛呀~<br><img src="https://s2.ax1x.com/2019/03/23/AJFazq.md.jpg" alt="金毛与山水"></p><hr></li><li><p>山水最是宜人<br><img src="https://s2.ax1x.com/2019/03/23/AJAKDf.jpg" alt="山水"></p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> entertainment </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/01/hello-world/"/>
      <url>/2019/03/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> entertainment </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
