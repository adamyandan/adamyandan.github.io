<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不想当咸鱼的蛋蛋</title>
  
  <subtitle>尹小丹的博客</subtitle>
  <link href="https://adamyandan.github.io/atom.xml" rel="self"/>
  
  <link href="https://adamyandan.github.io/"/>
  <updated>2020-05-29T01:52:24.365Z</updated>
  <id>https://adamyandan.github.io/</id>
  
  <author>
    <name>尹小丹</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多协议网关软件性能测试详细步骤</title>
    <link href="https://adamyandan.github.io/2020/05/28/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/"/>
    <id>https://adamyandan.github.io/2020/05/28/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3%E8%BD%AF%E4%BB%B6%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/</id>
    <published>2020-05-28T13:46:01.000Z</published>
    <updated>2020-05-29T01:52:24.365Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="一、串口波特率测试"><a href="#一、串口波特率测试" class="headerlink" title="一、串口波特率测试"></a>一、串口波特率测试</h2><p><strong>测试目的：</strong>要求多协议网关能正常支持9600-115200bps串口波特率<br><strong>期望结果：</strong>多协议网关能够通过串口正常获取数据<br><strong>软件：</strong>串口调试助手sscom3.2、putty或者securecrt<br><strong>步骤：</strong></p><ol><li>sscom3.2调到9600波特率</li><li>在securecrt或者putty中输入命令：piccom –b 9600 /dev/ttyS1</li><li>在sscom3.2中的字符串输入框中输入一些内容，putty上也能显示出来<br><strong>结果：</strong><ol><li>波特率为9600：<br><img src="https://s1.ax1x.com/2020/05/28/teTRgA.png" alt="teTRgA.png"></li><li>波特率为19200：<br><img src="https://s1.ax1x.com/2020/05/28/teTOvn.png" alt="teTOvn.png"></li><li>波特率为38400：<br><img src="https://s1.ax1x.com/2020/05/28/teTxbV.png" alt="teTxbV.png"></li><li>波特率为57600：<br><img src="https://s1.ax1x.com/2020/05/28/te795F.png" alt="te795F.png"></li><li>波特率为57600：<br><img src="https://s1.ax1x.com/2020/05/28/te7PC4.png" alt="te7PC4.png"></li></ol></li></ol><h2 id="二、以太网速率测试"><a href="#二、以太网速率测试" class="headerlink" title="二、以太网速率测试"></a>二、以太网速率测试</h2><p><strong>测试目的：</strong>要求多协议网关以太网支持速率10Mbps-100Mbps<br><strong>期望结果：</strong>通过修改不同电脑网卡的属性值，测试能否ping通测试电脑；若10Mbps与100Mbps都能ping通，则以太网支持速率10Mbps-100Mbps<br><strong>软件：</strong>securecrt<br><strong>步骤：</strong></p><ol><li>以太网-&gt;属性-&gt;配置-&gt;高级-&gt;speed &amp; duplex-&gt;分别选择10 Mbps全双工和100Mbps全双工</li><li>用securecrt进入网关 ping 主机IP<br><strong>结果：</strong><ol><li>10M以太网速率：<br><img src="https://s1.ax1x.com/2020/05/28/te7wGQ.png" alt="te7wGQ.png"></li><li>100M以太网速率：<br><img src="https://s1.ax1x.com/2020/05/28/te7srq.png" alt="te7srq.png"></li></ol></li></ol><h2 id="三、支持协议类型测试"><a href="#三、支持协议类型测试" class="headerlink" title="三、支持协议类型测试"></a>三、支持协议类型测试</h2><p><strong>测试目的：</strong>要求多协议网关能正确解析IEEE802.3协议<br><strong>期望结果：</strong>测试电脑能够正常收到ping命令<br><strong>软件：</strong>securecrt、wireshark<br><strong>步骤：</strong></p><ol><li>用网关ping电脑</li><li>用wireshark抓包，可以抓到ICMP格式的报文<br><strong>结果：</strong><ol><li>执行ping命令<br><img src="https://s1.ax1x.com/2020/05/28/te7vzd.png" alt="te7vzd.png">  </li><li>Wireshark抓包图<br><img src="https://s1.ax1x.com/2020/05/28/teHCeP.png" alt="teHCeP.png"></li></ol></li></ol><h2 id="四、-支持IPv4-IPv6协议测试"><a href="#四、-支持IPv4-IPv6协议测试" class="headerlink" title="四、  支持IPv4/IPv6协议测试"></a>四、  支持IPv4/IPv6协议测试</h2><p><strong>测试目的：</strong>要求多协议网关能正确解析IPv4/IPv6协议<br><strong>期望结果：</strong>测试电脑能够正常收到ping命令和ping6命令<br><strong>步骤：</strong></p><ol><li>分别ping 电脑的IPv4和IPv6地址</li><li>通过抓包或者securecrt界面的显示均可证明。<br><strong>结果：</strong><ol><li>IPv4通信<br><img src="https://s1.ax1x.com/2020/05/28/teLtyj.png" alt="teLtyj.png"></li><li>IPv6通信<br><img src="https://s1.ax1x.com/2020/05/28/teLNOs.png" alt="teLNOs.png"></li></ol></li></ol><h2 id="五、支持SMTP协议测试"><a href="#五、支持SMTP协议测试" class="headerlink" title="五、支持SMTP协议测试"></a>五、支持SMTP协议测试</h2><p><strong>测试目的：</strong>要求被测网关能够支持SMTP协议<br><strong>期望结果：</strong>通过指定邮箱获取SMTP软件发送的邮件，指定邮箱能够获取到网关发送的邮件<br><strong>步骤：</strong></p><ol><li>配置ssmtp.conf文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; XXXXXXXX@163.com</span><br><span class="line">mailhub &#x3D; smtp.163.com</span><br><span class="line">rewriteDomain &#x3D; 163.com</span><br><span class="line">hostname &#x3D; 163.com</span><br><span class="line">FromLineOverride &#x3D; YES</span><br><span class="line">AuthUser &#x3D; XXXXXXXXXX@163.com(这两个邮箱号是一样的)</span><br><span class="line">AuthPass &#x3D; 密码</span><br></pre></td></tr></table></figure></li><li>编写 vim sendmail文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#！&#x2F;bin&#x2F;sh</span><br><span class="line">(echo &quot;From:&lt;XXX@163.com&gt;&quot;;</span><br><span class="line"> echo &quot;To:&lt;XXX@qq.com&gt;&quot;;</span><br><span class="line"> echo &quot;&quot;;</span><br><span class="line"> echo &quot;Subject:I am openwrt.com!&quot;</span><br><span class="line"> echo &quot;$1&quot;</span><br><span class="line"> echo &quot;&quot;</span><br><span class="line">  )|ssmtp -v -f &quot;openwrt.com&quot; -F &quot;www.openwrt.com&quot; XXX@qq.com</span><br></pre></td></tr></table></figure></li><li>执行<code>./sendmail</code>命令</li></ol><h2 id="六、支持HTTP协议测试"><a href="#六、支持HTTP协议测试" class="headerlink" title="六、支持HTTP协议测试"></a>六、支持HTTP协议测试</h2><p><strong>测试目的：</strong>要求被测网关能够支持HTTP协议<br><strong>期望结果：</strong>通过Wireshark软件对被测网关与测试电脑进行交互的数据包进行分析，数据包符合HTTP标准<br><strong>步骤：</strong></p><ol><li>电脑登陆luci，访问网关web界面</li><li>用wireshark软件进行抓包，可抓到HTTP格式的报文<br><strong>结果：</strong><ol><li>测试电脑访问网关web界面<br><img src="https://s1.ax1x.com/2020/05/28/teLc6J.png" alt="teLc6J.png">  </li><li>Wireshark抓包图<br><img src="https://s1.ax1x.com/2020/05/28/teLgX9.png" alt="teLgX9.png"></li></ol></li></ol><h2 id="七、支持POP3协议测试"><a href="#七、支持POP3协议测试" class="headerlink" title="七、支持POP3协议测试"></a>七、支持POP3协议测试</h2><p><strong>测试目的：</strong>要求被测网关能够支持POP3协议<br><strong>期望结果：</strong>通过POP3软件获取指定邮箱的邮件，被测网关能够获取到指定邮箱的邮件<br><strong>步骤：</strong></p><ol><li>配置fdm.conf文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">##Accounts and rules for:</span><br><span class="line">#&gt;foo@example.com</span><br><span class="line">#&gt;bar@gmail.com</span><br><span class="line">## Last edit 21-dec-09</span><br><span class="line"></span><br><span class="line">#Catch-all action(mbox):</span><br><span class="line">action “inbox” mbox “%h&#x2F;mail&#x2F;INBOX”</span><br><span class="line">#catch-all action (maildir):</span><br><span class="line">Account “XXXX”</span><br><span class="line">Pop3 server “pop.163.com”</span><br><span class="line">User XXXXX@163.com pass “XXXX”</span><br><span class="line">match all action “inbox”</span><br></pre></td></tr></table></figure></li><li>在/etc目录下，输入命令：<code>fdm –kv fetch</code><br><strong>结果：</strong><ol><li>网关接收邮件<br><img src="https://s1.ax1x.com/2020/05/28/teLH6H.png" alt="teLH6H.png"></li></ol></li></ol><h2 id="八、支持FTP协议测试"><a href="#八、支持FTP协议测试" class="headerlink" title="八、支持FTP协议测试"></a>八、支持FTP协议测试</h2><p><strong>测试目的：</strong>要求被测网关能够支持FTP协议<br><strong>期望结果：</strong>通过FTP软件测试电脑上传文件到被测网关，被测网关能够接收上传文件<br><strong>软件：</strong>WINSCP、WIRESHARK<br><strong>步骤：</strong></p><ol><li>在winscp软件中与网关连接，并上传文件</li><li>同时打开wireshark软件进行抓包</li><li>会抓取到FTP格式的报文<br><strong>结果：</strong><ol><li>FTP软件配置<br><img src="https://s1.ax1x.com/2020/05/28/teLO0I.png" alt="teLO0I.png"></li><li>Wireshark抓取FTP数据包<br><img src="https://s1.ax1x.com/2020/05/28/teLvAP.png" alt="teLvAP.png"></li></ol></li></ol><h2 id="九、WIFI标准测试"><a href="#九、WIFI标准测试" class="headerlink" title="九、WIFI标准测试"></a>九、WIFI标准测试</h2><p><strong>测试目的：</strong>要求多协议网关支持802.11标准<br><strong>期望结果：</strong>ping命令能够被正确发送并收到回复<br><strong>步骤：</strong></p><ol><li>网关开启wifi功能，电脑连接wifi</li><li>通过wireshark抓取无线网络连接数据包ICMP报文</li></ol><h2 id="十、建立连接功能测试"><a href="#十、建立连接功能测试" class="headerlink" title="十、建立连接功能测试"></a>十、建立连接功能测试</h2><p><strong>测试目的：</strong>要求测试网关支持OPC UA客户端连接<br><strong>期望结果：</strong>通过Wireshark网络封包分析到OPC UA客户端软件发出连接请求报文后，网关能够将连接请求响应报文返回给OPC UA客户端软件，并且OPC UA客户端显示与网关成功建立连接<br><strong>步骤：</strong></p><ol><li>在opc ua客户端试图连接网关时，同时打开wireshark进行抓包</li><li>可以抓到opc ua格式的报文（需筛选报文格式）（OpenSecureChannel message: OpenSecureChannelRequest）<br><strong>结果：</strong><br><img src="https://s1.ax1x.com/2020/05/28/teOyUP.png" alt="teOyUP.png"></li></ol><h2 id="十一、读功能测试"><a href="#十一、读功能测试" class="headerlink" title="十一、读功能测试"></a>十一、读功能测试</h2><p><strong>测试目的：</strong>要求测试网关支持OPC UA客户端读操作<br><strong>期望结果：</strong>通过OPC UA客户端软件向网关发起读请求，通过Wireshark网络封包分析到OPC UA客户端软件发出读请求报文后，网关能够将需要读取的信息返回给OPC UA客户端软件，并且OPC UA客户端显示读成功<br><strong>步骤：</strong></p><ol><li>UA Secure Conversation Message: ReadRequest<br><strong>结果：</strong><br><img src="https://s1.ax1x.com/2020/05/28/teOoEq.png" alt="teOoEq.png"></li></ol><h2 id="十二、写功能测试"><a href="#十二、写功能测试" class="headerlink" title="十二、写功能测试"></a>十二、写功能测试</h2><p><strong>测试目的：</strong>要求测试多协议网关支持OPC UA客户端写操作<br><strong>期望结果:</strong>通过OPC UA客户端软件向多协议网关发起写请求，通过Wireshark网络封包分析到OPC UA客户端软件发出写请求报文后，多协议网关中的值正确变化，并且OPC UA客户端显示写成功<br><strong>步骤：</strong></p><ol><li>UA Secure Conversation Message: WriteRequest<br><strong>结果：</strong><br><img src="https://s1.ax1x.com/2020/05/28/teOL2F.png" alt="teOL2F.png"></li></ol><h2 id="十三、发布-订阅功能测试"><a href="#十三、发布-订阅功能测试" class="headerlink" title="十三、发布/订阅功能测试"></a>十三、发布/订阅功能测试</h2><p><strong>测试目的：</strong>要求多协议网关支持OPC UA发布/订阅功能<br><strong>期望结果：</strong>通过OPC UA客户端软件向多协议网关发起连接请求，通过Wireshark网络封包分析到OPC UA客户端软件发出发布/订阅请求报文后，多协议网关的OPC UA服务器能够回复发布/订阅响应报文，并且OPC UA客户端显示发布/订阅关系建立成功，并且数据能够周期性更新<br><strong>步骤：</strong></p><ol><li>UA Secure Conversation Message: PublishRequest<br><strong>结果：</strong><br><img src="https://s1.ax1x.com/2020/05/28/teXkxe.png" alt="teXkxe.png"><br><img src="https://s1.ax1x.com/2020/05/28/teXnat.png" alt="teXnat.png"></li></ol><h2 id="十四、断开连接功能测试"><a href="#十四、断开连接功能测试" class="headerlink" title="十四、断开连接功能测试"></a>十四、断开连接功能测试</h2><p><strong>测试目的：</strong>要求多协议网关支持与OPC UA客户端断开连接<br><strong>期望结果:</strong>通过OPC UA客户端软件向多协议网关发起断开连接请求，通过Wireshark网络封包分析到OPC UA客户端软件发出断开请求报文后，多协议网关能够将断开连接成功结果返回给OPC UA客户端软件，并且OPC UA客户端显示与多协议网关成功断开连接<br><strong>步骤：</strong></p><ol><li>CloseSecureChannel message: CloseSecureChannelRequest<br><strong>结果：</strong><br><img src="https://s1.ax1x.com/2020/05/28/teXGrj.png" alt="teXGrj.png"></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h2 id=&quot;一</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term="多协议网关" scheme="https://adamyandan.github.io/tags/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>展厅设备手册</title>
    <link href="https://adamyandan.github.io/2020/05/28/%E5%B1%95%E5%8E%85%E8%AE%BE%E5%A4%87%E5%BC%80%E5%90%AF%E6%89%8B%E5%86%8C/"/>
    <id>https://adamyandan.github.io/2020/05/28/%E5%B1%95%E5%8E%85%E8%AE%BE%E5%A4%87%E5%BC%80%E5%90%AF%E6%89%8B%E5%86%8C/</id>
    <published>2020-05-28T09:07:01.000Z</published>
    <updated>2020-05-28T13:44:10.764Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="一、OPC-UA信息共享平台"><a href="#一、OPC-UA信息共享平台" class="headerlink" title="一、OPC UA信息共享平台"></a>一、OPC UA信息共享平台</h2><ol><li>跑一个程序</li><li>跑一个客户端</li></ol><p>打开终端，依次输入如下指令：</p><ol><li>先跑一个程序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd Desktop</span><br><span class="line">$ cd New</span><br><span class="line">$ cd 3_iot</span><br><span class="line">$ cd CS</span><br><span class="line">$ .&#x2F;csadapter</span><br></pre></td></tr></table></figure></li><li>再跑一个OPC UA客户端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd Desktop</span><br><span class="line">$ cd New</span><br><span class="line">$ cd Script</span><br><span class="line">$ cd copy</span><br><span class="line">$ .&#x2F;OPC UA</span><br></pre></td></tr></table></figure></li></ol><p>地址：<code>127.0.0.1</code><br>端口号：<code>5222</code></p><h2 id="二、863节点运行系统"><a href="#二、863节点运行系统" class="headerlink" title="二、863节点运行系统"></a>二、863节点运行系统</h2><ol><li>先打开UA Export看所有网络的数据有没有上来，没有上来的话，就要一一进入各网络的网关去跑代码</li><li>“工程管理器” -&gt; database -&gt; 启动应用</li><li>左下角 “命令符”，（运行代码，将组态与个网关连接）</li><li>打开 “运行系统” 可视化界面。</li></ol><h2 id="三、各网络网关地址与端口号统计"><a href="#三、各网络网关地址与端口号统计" class="headerlink" title="三、各网络网关地址与端口号统计"></a>三、各网络网关地址与端口号统计</h2><ol><li>WIAPA:    192.168.2.99  15000</li><li>Modbus:   192.168.2.100 15000</li><li>Profibus: 192.168.2.101 16664</li><li>6tisch:   192.168.2.102 15000</li><li>6lowpan:  192.168.2.103 15000</li><li>control:                16664</li><li>meter:                  8667 </li></ol><h2 id="四、IOT实验箱展示"><a href="#四、IOT实验箱展示" class="headerlink" title="四、IOT实验箱展示"></a>四、IOT实验箱展示</h2><ol><li>连 wifi （opent-wrt）</li><li>打开文件“iot-tianzhanbei-big-141008”</li><li><code>./CISCO</code></li><li>server ip: 192.168.1.1</li><li>port: 5222</li></ol><h2 id="五、如何在linux下设置单网卡多个IP"><a href="#五、如何在linux下设置单网卡多个IP" class="headerlink" title="五、如何在linux下设置单网卡多个IP"></a>五、如何在linux下设置单网卡多个IP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig br-lan:0 XX:XX:XX:XX netmask 255.255.255.0 up</span><br><span class="line">ifconfig br-lan:1 XX:XX:XX:XX netmask 255.255.255.0 up</span><br></pre></td></tr></table></figure><p>但是后面reboot后ip地址又变回去了，必须设置启动时自动激活IP设置。<br>于是将上面的代码放入自启动文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;rc.local</span><br></pre></td></tr></table></figure><p>查路由表会发现只有br-lan口才是最后的出口。</p><h2 id="六、863组态历史数据开启"><a href="#六、863组态历史数据开启" class="headerlink" title="六、863组态历史数据开启"></a>六、863组态历史数据开启</h2><ol><li>画面管理 -&gt; 工程 -&gt; 模板 </li><li>变量 -&gt; 新建变量</li><li>实例 -&gt; 新建实例 、 实例属性，找到对应的映射关系</li><li>选中里面的图表，左边的属性下 -&gt; 曲线属性，选择线条颜色</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h2 id=&quot;一</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term="展厅设备" scheme="https://adamyandan.github.io/tags/%E5%B1%95%E5%8E%85%E8%AE%BE%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>机房服务器问题手册</title>
    <link href="https://adamyandan.github.io/2020/05/28/%E6%9C%BA%E6%88%BF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%8B%E5%86%8C/"/>
    <id>https://adamyandan.github.io/2020/05/28/%E6%9C%BA%E6%88%BF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%8B%E5%86%8C/</id>
    <published>2020-05-28T09:07:01.000Z</published>
    <updated>2020-05-28T13:39:02.186Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h1 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h1><p>  机房里的服务器，在进行“思科-时天河-重邮工业互联网研究院”的项目，网线连通局域网，开4G路由器，让机房服务器连wifi进行上网。<br>  机房电脑开机密码：Cqupt123</p><h2 id="一、机房服务器连上WIFI后依旧无法上网的问题"><a href="#一、机房服务器连上WIFI后依旧无法上网的问题" class="headerlink" title="一、机房服务器连上WIFI后依旧无法上网的问题"></a>一、机房服务器连上WIFI后依旧无法上网的问题</h2><ol><li>先用4G路由器有线连接服务器</li><li>修改正确的时间，看能否上网，能，进行下一步</li><li>修改到2018年8月1日，看能否上网，能，进行下一步</li><li>能否进入 DATAFLOW ，能，进入下一步</li><li>用有线连接服务器，无线连接设备网关，进行展示。</li></ol><h2 id="二、机房EFM服务器开启命令"><a href="#二、机房EFM服务器开启命令" class="headerlink" title="二、机房EFM服务器开启命令"></a>二、机房EFM服务器开启命令</h2><p>打开终端界面，依次按如下命令开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo su</span><br><span class="line">$ source &#x2F;etc&#x2F;profile</span><br><span class="line">$ cd &#x2F;opt&#x2F;cisco&#x2F;kinetic&#x2F;efm-server&#x2F;bin</span><br><span class="line">$ .&#x2F;daemon.sh start</span><br></pre></td></tr></table></figure><h2 id="三、若机房的电脑重启了，怎么办？"><a href="#三、若机房的电脑重启了，怎么办？" class="headerlink" title="三、若机房的电脑重启了，怎么办？"></a>三、若机房的电脑重启了，怎么办？</h2><ol><li>打开ubuntu 64虚拟机<br>路径： D盘/虚拟机（英文）/ubuntu 64<br>有 cisco 这个用户名</li><li>切换到root用户（sudo su）<br>若网站 2.5：8443/dataflow.html 左边的选项是灰色的，则输入命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>然后执行EFM服务器执行命令，参照二</li><li>开启天河的端口映射（online那个）<br>若主机地址改了，则也需要相应的更改NATAPP中的IPv4地址<br>网站地址：<br>NATAPP.cn</li><li>打开  天河界面（T5制造平台）<br>账号：efmAdmin<br>密码：123456</li><li>若需要联网远程接入天河数据库界面，则需要开启NATAPP的.exe文件</li></ol><h2 id="四、相关配置"><a href="#四、相关配置" class="headerlink" title="四、相关配置"></a>四、相关配置</h2><ol><li>虚拟网络编辑器 -&gt; NAT setting -&gt; 此虚拟机IP地址：8443 -&gt; 主机端口号8443 -&gt; 确认</li><li><a href="https://192.168.2.XX/dataflow.html" target="_blank" rel="noopener">https://192.168.2.XX/dataflow.html</a> 思科kinetic平台</li></ol><h2 id="五、若想在dataflow中的DS-Link中添加OPC-UA网络"><a href="#五、若想在dataflow中的DS-Link中添加OPC-UA网络" class="headerlink" title="五、若想在dataflow中的DS Link中添加OPC UA网络"></a>五、若想在dataflow中的DS Link中添加OPC UA网络</h2><p>Alias (在upstream底下的OPC UA中）</p><ol><li>Discover tags , Add Endpoints(输入名称+URL)</li><li>在（发现中）里发现节点 <strong>[勿需手动添加]</strong></li><li>订阅 describe</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h1 id=&quot;说</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term="机房服务器" scheme="https://adamyandan.github.io/tags/%E6%9C%BA%E6%88%BF%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>多协议网关设计方案</title>
    <link href="https://adamyandan.github.io/2020/05/25/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/"/>
    <id>https://adamyandan.github.io/2020/05/25/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</id>
    <published>2020-05-25T08:46:01.000Z</published>
    <updated>2020-05-25T09:03:59.575Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>  在工业互联网的信息时代，现场设备需要实现互联互通，消除信息孤岛。然而，工业控制网络本身就存在通讯协议异构、接口不统一的问题，这不利于现场设备底层数据的采集和信息共享，同时对工业控制系统的网络安全提出更高的要求。因此，开发一个工业多协议安全网关已成为必然趋势。</p><p>  本工业多协议安全网关负责对不同的通信协议进行翻译，实现不同协议网络间信息包转发，简化网络管理，将有不同通信接口的传感器都连接到同一个网关上，进行分布式数据传输和控制，大大降低了设计成本，便于后期的维护。本工业多协议安全网关主要是由主控模块MT7620、协议转换模块、组态模块、WIA-PA模块和数据汇聚模块组成，可以支持FF、PROFIBUS、HART三种工业现场总线协议以及WIA-PA工业无线网络的接入，利用NCS4000组态系统、Linux平台进行开发，并且可通过OPC UA统一接口实现对数据的共享，支持读、取、写、发布/订阅功能。</p><p>  该工业多协议安全网关满足以下指标：</p><p>  (1)    网关正常支持9600-115200bps串口波特率；<br>  (2)    网关支持以太网速率10Mbps-100Mbps自适应；<br>  (3)    网关能正确解析IEEE802.3协议、IPv4/IPv6协议、SMTP、HTTP、POP3、FTP协议；<br>  (4)    网关支持报文过滤、权限管理等安全功能；<br>  (5)    网关支持802.11标准，无线传输速率达到11Mbps，发射功率在12-15 dBm范围内；<br>  (6)    网关的吞吐量可达到100Mbps；<br>  (7)    网关的包转发速率可达到250 Kbps；<br>  (8)    网关的传输时延小于50ms；<br>  (9)    网关可以并行传输处理控制和服务信息；<br>  (10)    网关的工作环境温度范围为-40℃~70℃(在电源模块70%负载时)、-40～55 ℃（在电源模块100%负载时）；<br>  (11)    网关兼容现场总线FF、PROFIBUS、HART通信协议和无线工业通信协议WIA-PA；<br>  (12)    网关支持OPC UA、Modbus统一接口，满足连接、读写、发布/订阅的功能；<br>  (13)    网关具有不同仪表接口和业务要素的统一转换接口，上行接口速率大于等于100Mbps，下行可接入点规模大于16个点。</p><h2 id="2-总体设计方案"><a href="#2-总体设计方案" class="headerlink" title="2.总体设计方案"></a>2.总体设计方案</h2><p>  本项目所研发的工业多协议安全网关包括主控模块MT7620、协议转换模块、组态模块、WIA-PA模块和数据汇聚模块。主控模块用于承载OpenWRT系统，对网关基本路由功能提供支持，协议转换模块用于将底层采集到的不同协议数据进行统一的XML描述；组态模块用于工业现场有线/无线网络子网的组网以及入网；WIA-PA模块通过无线的方式采集底层的WIA-PA网络中的数据；数据汇聚模块拥有FF网络接口、PROFIBUS网络接口和HART网络接口，用于采集底层PROFIBUS、Fieldbus和HART现场总线网络数据；工业多协议安全网关通过协议转换模块将不同协议的数据转换为统一的XML格式，再使用有线网络或者无线网络将统一后的数据通过统一的网络接口（OPC UA或者Modbus TCP）传输至局域网或广域网。该工业多协议安全网关集无线/有线数据采集、网络组态、协议转换等功能为一体，支持底层有线/无线网络、局域网或广域网网络之间的互联互通，并通过OPC UA技术和Modbus TCP数据通信协议实现设备管理与数据传输的无缝衔接。工业多协议安全网关的总体设计如下图所示。<br><a href="https://imgchr.com/i/t9728S" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9728S.png" alt="t9728S.png"></a></p><h2 id="3-主要模块设计"><a href="#3-主要模块设计" class="headerlink" title="3.主要模块设计"></a>3.主要模块设计</h2><h3 id="3-1-主控模块"><a href="#3-1-主控模块" class="headerlink" title="3.1 主控模块"></a>3.1 主控模块</h3><p>  工业多协议安全网关的主控模块包括MT7620主控制单元、无线模块单元、电源管理单元、以太网控制单元、串口转USB调试单元等。网关设计了三个UART接口、一个网口、一个GPIO口；其中UART0作为普通串口与无线模块交互数据，UART1作为调试串口。工业现场总线模块则通过UART2串口与主控模块进行数据交互。工业多协议安全网关的主控模块结构图如下图所示。<br><a href="https://imgchr.com/i/t97jKJ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t97jKJ.png" alt="t97jKJ.png"></a><br>  工业多协议安全网关主控模块使用OpenWRT系统。该系统针对网络路由功能的需要，在嵌入式Linux系统的基础上进行优化，不仅能够很好地支持各种处理器架构，还能够支持IPv4/IPv6网络的路由转发功能。同时，该系统作为开源嵌入式Linux系统，能够对STMP、POP3、HTTP、FTP等协议提供支持。主控模块能够读取现场总线设备、WIA-PA设备的数据，并提供OPC UA、Modbus统一接口。</p><h3 id="3-2-数据汇聚模块"><a href="#3-2-数据汇聚模块" class="headerlink" title="3.2 数据汇聚模块"></a>3.2 数据汇聚模块</h3><p>  现场总线控制系统是一种开放式、安全性好、成本低、新型的分布控制系统，以控制、计算机、数字通讯等技术为主要内容的综合技术，成为自动化技术发展热点，并将导致自动化系统结构与设备的深刻变革。工业多协议安全网关现场总线模块包括FF数据汇聚模块、HART数据汇聚模块、PROFIBUS数据汇聚模块，能够读取现场总线的各种信息和实时数据，同时提供了8个FF端子、4个PROFIBUS接口和8个HART通道，能够连接大量的现场总线设备。</p><p>  3.2.1 FF数据汇聚模块<br>  NCS40000控制系统可以访问FF数据汇聚模块，该模块可以与符合FF H1标准的各种仪表和设备连接，控制站可以通过 NCS4000-FFH1-0201 模块对 H1 仪表和设备进行组态、监视、诊断、维护等功能。具有热插拔、故障和状态指示等功能。</p><p>  该模块的主要特点如下：</p><ul><li><p>通道至系统隔离 </p></li><li><p>总线供电 </p></li><li><p>电流调制方式 </p></li><li><p>通过 FF 协议物理层一致性测试</p><p>目前该模块支持两个H1接口，可以连接两个H1网段，在网段上作为LAS运行。FF数据汇聚模块端子接线如下图所示，其中CH1和CH2表示不同的H1网段，每个网段可以接入四个设备。底层FF设备通过工业多协议安全网关的FF模块接入网络，同时将数据通过该模块传输至主控模块进行下一步传输与处理。<br><a href="https://imgchr.com/i/t9HEKH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9HEKH.png" alt="t9HEKH.png"></a></p></li></ul><p>  3.2.2 HART数据汇聚模块<br>  HART数据汇聚模块是一个具有8个通道的HART通讯模块，可以检测来自HART现场设备的电流输入和HART信号，具有热插拔、故障和状态指示等功能。通过组态软件对该模块进行通道配置，模块能够读取现场设备的实时数据。</p><p>  该模块的主要特点如下：</p><ul><li><p>通道至系统隔离</p></li><li><p>支持0～20mA，4～20mA量程的电流输入信号，每通道支持一个HART变送器</p></li><li><p>支持2、4线制变送器</p></li><li><p>2线制接线方式具有输入开路、短路检测功能</p></li><li><p>支持HART变送器的多变量读取</p><p>HART数据汇聚模块端子接线如下图所示，其中CH1-CH8分别表示8个不同的HART通道，可接入8个设备，用户可通过NCS4000组态控制系统对每个通道进行配置以及开启与关闭。<br><a href="https://imgchr.com/i/t9HJqs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9HJqs.png" alt="t9HJqs.png"></a></p></li></ul><p>  3.2.3 PROFIBUS数据汇聚模块<br>  符合PROFIBUS协议标准的设备通过工业多协议安全网关的PROFIBUS数据汇聚模块接入网络，同时将数据通过该模块传输至主控模块进行下一步传输与处理。该模块提供4个接口端子，可一次接入4个PROFIBUS-DP/PROFIBUS-PA设备，底层设备通过组态模块（NCS-4000）获得唯一的地址，PROFIBUS数据汇聚模块通过每个设备的唯一地址对底层设备管理、读取/发送数据，以此保证数据的准确性，该模块还具有热插拔、故障和状态指示等功能。</p><p>  该模块的主要特点如下：</p><ul><li><p>通道至系统隔离</p></li><li><p>支持PROFIBUS 协议中的DP-V1 协议</p></li><li><p>每个PROFIBUS主站可连接125 个从站</p></li><li><p>一个控制器最多可带2 个PROFIBUS 主站模块<br><a href="https://imgchr.com/i/t9HdiV" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9HdiV.png" alt="t9HdiV.png"></a></p><p>PROFIBUS主站模块端子接线如上图所示，该模块拥有4个PROFIBUS-DP设备接口（A-, B+和G），接入DP分线器后可同时管理多个PROFIBUS-DP设备。接入DP/PA耦合器后，该模块则可以管理PROFIBUS-PA设备。CNTR端子代表着一个可逆计数器，VP端子表示正向电极，PE则是保护导体端子，为该模块提供安全保证。</p></li></ul><h3 id="3-3-NCS4000组态模块"><a href="#3-3-NCS4000组态模块" class="headerlink" title="3.3 NCS4000组态模块"></a>3.3 NCS4000组态模块</h3><p>  工业多协议安全网关提供NCS4000组态功能，NCS4000控制系统是全分布式的现场总线控制系统，适用于中、大规模工业控制环境，提供过程控制、逻辑控制功能，可以广泛应用于冶金、水泥焦化污处理、石油、化工等行业。通过NCS4000组态模块能够对FF、HART、PROFIBUS等现场总线设备进行参数配置和数据读取。</p><p>  NCS4000控制系统具有如下特点： </p><ul><li>支持 FF、HART、MODBUS、PROFIBUS多种现场总线标准；</li><li>支持设备管理、诊断与维护功能； </li><li>支持分布式组态、离线仿真等多种功能；</li><li>支持 IEC61131-3编程标准； </li><li>开放的数据访问接口。</li></ul><h3 id="3-4-WIA-PA数据前端模块"><a href="#3-4-WIA-PA数据前端模块" class="headerlink" title="3.4 WIA-PA数据前端模块"></a>3.4 WIA-PA数据前端模块</h3><p>  WIA-PA数据前端模块在WIA-PA网络中以WIA-PA网关的角色出现，完成整个网络的组网与管理以及数据传输功能。转换模块实现WIA-PA网络及其设备接入以IPv6协议为寻址方法和以OPC UA协议为传输方法的网络转换。具体方法是在模块中将WIA-PA的用户应用对象转换为遵循XML描述格式；在应用子层，将WIA-PA的Client-Server、Publisher-Subscriber和Report-Sink通信模式转换为OPC UA协议中对应的传输方式；在网络层，将WIA-PA的网内地址映射为标准的IPv6地址，使WIA-PA网络的每个设备都有一个虚拟的IPv6地址，外部网络可通过IPv6地址对WIA-PA设备进行寻址。<br><a href="https://imgchr.com/i/t9b3Y6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9b3Y6.png" alt="t9b3Y6.png"></a></p><h3 id="3-5-协议转换模块"><a href="#3-5-协议转换模块" class="headerlink" title="3.5 协议转换模块"></a>3.5 协议转换模块</h3><p>  工业多协议安全网关提供了协议转换功能，将设备地址转换为标准的IPv6地址，将网络内部的信息数据转换为XML格式。同时，网关利用XML对网络内的设备进行描述，并使用统一的IP协议经过边界网关，将设备描述信息、数据信息、管理信息等XML 信息传输至上层应用。在这种架构下，虽然现场网络的设备并不能直接支持XML和IP，但借助于多协议网关的转换功能，每个现场设备仍具有单独的IP 地址，并通过XML与后台进行数据信息和管理信息交互。通过该模块，能够将工业现场总线及工业无线网络的数据转换成XML格式，建立以XML为核心的信息描述与数据交换机制，最后将工业网络数据通过OPC UA统一转换接口对外提供服务。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term="多协议网关" scheme="https://adamyandan.github.io/tags/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>多协议网关外部接线端口说明</title>
    <link href="https://adamyandan.github.io/2020/05/25/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3%E5%A4%96%E9%83%A8%E6%8E%A5%E7%BA%BF%E7%AB%AF%E5%8F%A3%E8%AF%B4%E6%98%8E/"/>
    <id>https://adamyandan.github.io/2020/05/25/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3%E5%A4%96%E9%83%A8%E6%8E%A5%E7%BA%BF%E7%AB%AF%E5%8F%A3%E8%AF%B4%E6%98%8E/</id>
    <published>2020-05-25T08:27:01.000Z</published>
    <updated>2020-05-25T08:35:43.614Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>多协议边界网关包含FF、HART、DP共3种现场总线模块，通过以太网连接电脑上位机，可以对FF、HART、DP设备进行配置、组态等操作。<br>多协议边界网关整体如下图所示。</p><p><a href="https://imgchr.com/i/t94u5D" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t94u5D.png" alt="t94u5D.png"></a></p><h2 id="二、接口描述"><a href="#二、接口描述" class="headerlink" title="二、接口描述"></a>二、接口描述</h2><ol><li><p>下侧接口<br><a href="https://imgchr.com/i/t94Tqx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t94Tqx.png" alt="t94Tqx.png"></a></p></li><li><p>上侧接口<br><a href="https://imgchr.com/i/t94HZ6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t94HZ6.png" alt="t94HZ6.png"></a></p></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h2 id=&quot;一</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term="多协议网关" scheme="https://adamyandan.github.io/tags/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>NCS400展厅组态安装软件（路径需要用英文）</title>
    <link href="https://adamyandan.github.io/2020/05/25/NCS400%E5%B1%95%E5%8E%85%E7%BB%84%E6%80%81%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%EF%BC%88%E8%B7%AF%E5%BE%84%E9%9C%80%E8%A6%81%E7%94%A8%E8%8B%B1%E6%96%87%EF%BC%89/"/>
    <id>https://adamyandan.github.io/2020/05/25/NCS400%E5%B1%95%E5%8E%85%E7%BB%84%E6%80%81%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%EF%BC%88%E8%B7%AF%E5%BE%84%E9%9C%80%E8%A6%81%E7%94%A8%E8%8B%B1%E6%96%87%EF%BC%89/</id>
    <published>2020-05-25T08:15:01.000Z</published>
    <updated>2020-05-25T08:26:45.070Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="一、安装环境及注意事项"><a href="#一、安装环境及注意事项" class="headerlink" title="一、安装环境及注意事项"></a>一、安装环境及注意事项</h2><ol><li><p>（ win 7 旗舰版 + office 2007 ） 或 （ win 10 专业版 + office 2007 ）</p></li><li><p>安装路径都要为<strong>英文</strong></p></li><li><p>所有的软件都要<strong>以管理员身份运行</strong></p></li></ol><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li><p>先安装 “SQLServer 2008 R2 Express” 里的文件 “SQLEXPR_x86_CHS”<br>其中，将  “账户设置” 改为 <strong>“SYSTEM”</strong></p></li><li><p>执行 “MCView_2.3.0.exe”<br>在执行过程中如果遇到问题， 先执行 “vcredistx64.exe” , win 7系统可能没有一个插件，需要手动安装 “dotNetFx40_Full_x86_x64.exe” </p></li><li><p>执行 “NCSView_v2.4.4_For_UA.exe”<br>到 “工程管理器” 工程中 打开 “test_863.mvsp”（或其他工程项目）</p></li></ol><h2 id="安装完后，退出。并按照实验室祖传的打开方式，进行测试验证。"><a href="#安装完后，退出。并按照实验室祖传的打开方式，进行测试验证。" class="headerlink" title="安装完后，退出。并按照实验室祖传的打开方式，进行测试验证。"></a>安装完后，退出。并按照实验室祖传的打开方式，进行测试验证。</h2><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h2 id=&quot;一</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term="NCS4000组态" scheme="https://adamyandan.github.io/tags/NCS4000%E7%BB%84%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>2020重邮研究生经费报销流程</title>
    <link href="https://adamyandan.github.io/2020/05/25/2020%E9%87%8D%E9%82%AE%E7%A0%94%E7%A9%B6%E7%94%9F%E7%BB%8F%E8%B4%B9%E6%8A%A5%E9%94%80%E6%B5%81%E7%A8%8B/"/>
    <id>https://adamyandan.github.io/2020/05/25/2020%E9%87%8D%E9%82%AE%E7%A0%94%E7%A9%B6%E7%94%9F%E7%BB%8F%E8%B4%B9%E6%8A%A5%E9%94%80%E6%B5%81%E7%A8%8B/</id>
    <published>2020-05-25T07:02:01.000Z</published>
    <updated>2020-05-25T07:24:23.371Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="一、纸张按以下顺序排列："><a href="#一、纸张按以下顺序排列：" class="headerlink" title="一、纸张按以下顺序排列："></a>一、纸张按以下顺序排列：</h2><ol><li>投递式报销专用封面</li><li>投递式报账票据汇总表</li><li>票据报销审批单</li><li>打印的发票（发票如果直接用A4纸打印出来的话，就不需要粘贴到“票据粘贴单”中）</li><li>票据粘贴单（如果有发票的话，需要粘到这张纸上面）（话费、图书、论文查重费都可以）</li></ol><h2 id="二、需要准备的材料，以及填写的内容、步骤"><a href="#二、需要准备的材料，以及填写的内容、步骤" class="headerlink" title="二、需要准备的材料，以及填写的内容、步骤"></a>二、需要准备的材料，以及填写的内容、步骤</h2><ol><li><p>投递式报销封面<br><a href="https://imgchr.com/i/t9G6Mt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9G6Mt.jpg" alt="t9G6Mt.jpg"></a></p></li><li><p>票据汇总表<br><a href="https://imgchr.com/i/t9JeWd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9JeWd.jpg" alt="t9JeWd.jpg"></a></p></li><li><p>报销审批单<br><a href="https://imgchr.com/i/t9JJYQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9JJYQ.jpg" alt="t9JJYQ.jpg"></a></p></li><li><p>在每一张发票上写上：</p></li></ol><p> <strong>本人承诺此发票为重复报销，真实有效（姓名，日期）</strong></p><ol start="5"><li><p>导师签字</p></li><li><p>辅导员签字、备案</p></li><li><p>院长签字</p></li><li><p>学院盖章</p></li><li><p>去财务处投递</p></li></ol><h2 id="三、凑发票小技巧"><a href="#三、凑发票小技巧" class="headerlink" title="三、凑发票小技巧"></a>三、凑发票小技巧</h2><ol><li><p>联通的话费电子发票可以改抬头，使用联通的<strong>手机营业厅</strong>APP，可以推送电子发票<strong>（但有限额）</strong></p></li><li><p>话费、书籍发票上的姓名需要写自己的名字</p></li><li><p><strong>发票不要超过200元</strong>，若超过一定的面额，需要附上以下说明：<br><a href="https://imgchr.com/i/t9Yw3d" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/25/t9Yw3d.jpg" alt="t9Yw3d.jpg"></a></p></li><li><p>发票一定要贴好，全方位无死角贴满！</p></li></ol><h2 id="其余形式的报销，在下就没有总结了，抱歉。"><a href="#其余形式的报销，在下就没有总结了，抱歉。" class="headerlink" title="其余形式的报销，在下就没有总结了，抱歉。"></a>其余形式的报销，在下就没有总结了，抱歉。</h2><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h2 id=&quot;一</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term="经费报销" scheme="https://adamyandan.github.io/tags/%E7%BB%8F%E8%B4%B9%E6%8A%A5%E9%94%80/"/>
    
  </entry>
  
  <entry>
    <title>多协议网关NCS4000控制器操作指南</title>
    <link href="https://adamyandan.github.io/2020/01/14/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3NCS4000%E6%8E%A7%E5%88%B6%E5%99%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <id>https://adamyandan.github.io/2020/01/14/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3NCS4000%E6%8E%A7%E5%88%B6%E5%99%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</id>
    <published>2020-01-14T06:48:11.000Z</published>
    <updated>2020-01-14T07:24:36.693Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,laboratory --><h2 id="安装NCS4000Setup-exe"><a href="#安装NCS4000Setup-exe" class="headerlink" title="安装NCS4000Setup.exe"></a>安装NCS4000Setup.exe</h2><pre><code>把“NCS4000Setup.exe”软件装在C盘里一直按“下一步”即可。一般存储路径：C：/Program Files(x86)/CQUPT/NCS4000/</code></pre><h2 id="1-建立数据库与设备连接"><a href="#1-建立数据库与设备连接" class="headerlink" title="1.建立数据库与设备连接"></a>1.建立数据库与设备连接</h2><p>1）打开“系统信息数据库管理”<br><img src="https://s2.ax1x.com/2020/01/14/lbv2G9.png" alt="lbv2G9.png"><br>新建数据库，设置名字和保存路径<br>创建新数据库成功后，管理工具会询问是否将新建数据库设为激活，点击“是”。</p><p>然后可以点那个<br><img src="https://s2.ax1x.com/2020/01/14/lbv4r6.png" alt="lbv4r6.png"><br>之后就会启动了</p><p>2）打开“系统诊断工具”<br><img src="https://s2.ax1x.com/2020/01/14/lbv5qK.png" alt="lbv5qK.png"></p><p>3）打开 “资源管理器”<br>若这里初始化失败<br><img src="https://s2.ax1x.com/2020/01/14/lbvjMt.png" alt="lbvjMt.png"><br>安装的位置，删掉原来的ios_ip_setting.ini 文件<br>将ios_ip_setting.ini.tmpl 文件改为ios_ip_setting.ini<br>用记事本打开这个刚改完名字的文件，在这里：<br><img src="https://s2.ax1x.com/2020/01/14/lbxkzn.png" alt="lbxkzn.png"><br>将这里的IP Address改为 本计算机的IP地址。在192.168.2.XXX网段。</p><p>4）又打开“系统诊断工具”<br><img src="https://s2.ax1x.com/2020/01/14/lbxZLV.png" alt="lbxZLV.png"><br>先按“停止”，后按“启动”<br>点“更新”<br><strong>需要等待一段时间</strong>，才能显示黄色里的设备信息<br>关掉这个“系统诊断工具”。</p><p>5） “资源管理器”里的东西，一切正常了<br><img src="https://s2.ax1x.com/2020/01/14/lbxndU.png" alt="lbxndU.png"></p><h2 id="2-使用已有得数据库"><a href="#2-使用已有得数据库" class="headerlink" title="2.使用已有得数据库"></a>2.使用已有得数据库</h2><p>1）启动“系统信息数据库管理”（一般会保留上次用过的数据库）<br><img src="https://s2.ax1x.com/2020/01/14/lbx1zR.png" alt="lbx1zR.png"></p><p>2）双击“设置激活数据库”</p><p>3）选择你的数据库（可以为中文名字）<br><img src="https://s2.ax1x.com/2020/01/14/lbxJL6.png" alt="lbxJL6.png"></p><p>4）选中后，按“确定，然后点击绿色的那个按钮。运行数据库就行了</p><p>5）之后就是“资源管理器”中的配置了</p><h2 id="3-资源管理器的使用"><a href="#3-资源管理器的使用" class="headerlink" title="3.资源管理器的使用"></a>3.资源管理器的使用</h2><p>1）运行“资源管理器”</p><p>2）选择“物理网络”，在右侧窗口可以看到在线物理控制器信息<br><img src="https://s2.ax1x.com/2020/01/14/lbxNdO.png" alt="lbxNdO.png"></p><p>3）设计控制策略结构<br>    1.右键选择“系统组态配置信息-&gt;控制策略”节点<br>        选择“新建区域”命令<br>        <img src="https://s2.ax1x.com/2020/01/14/lbxrQI.png" alt="lbxrQI.png"><br>        在“控制策略”节点下会自动添加一个区域对象子节点“区域1”<br>        <img src="https://s2.ax1x.com/2020/01/14/lbx5Ss.png" alt="lbx5Ss.png"><br>    2.右键选择刚刚创建的“区域1”节点<br>        选择“新建模块”命令，添加一个“功能块图”<br>        <img src="https://s2.ax1x.com/2020/01/14/lbxzlR.png" alt="lbxzlR.png"><br>    3.同样地方法，添加一个“梯形图”<br>        <img src="https://s2.ax1x.com/2020/01/14/lbzM0f.png" alt="lbzM0f.png"><br>        <img src="https://s2.ax1x.com/2020/01/14/lbz3tg.png" alt="lbz3tg.png"></p><p>4） 编辑功能块图模块<br>右键选择“系统组态配置信息-&gt;控制策略-&gt;区域1-&gt;Fbd1”<br>选择“编辑-&gt;使用组态软件离线编辑”</p><p>5）添加功能块对象<br>    1. 在控制策略开发环境的模板视图中，选中“功能块库-&gt;输入/输出-&gt;DI”节点<br>    2. “拖拽”至左边的编辑视图中<br>    3. 放“DO”节点<br><img src="https://s2.ax1x.com/2020/01/14/lqSPvn.png" alt="lqSPvn.png"><br>    4. 在模块视图中，右键选择“Fbd1”节点。<br>        选择“添加参数”命令<br>        <img src="https://s2.ax1x.com/2020/01/14/lqS3b6.png" alt="lqS3b6.png"><br>    5. 在属性视图中，将参数对象“Param_1”的对象名称修改为“In1”、参数类型修改为“输入”<br>        <img src="https://s2.ax1x.com/2020/01/14/lqSdxA.png" alt="lqSdxA.png"><br>    6. 使用同样方法，再添加一个对象名称为“Out1”、参数类型修改为“输出”<br>    7. 在“模块视图”和“编辑窗口”都删掉“DI_1”<br>    8. 左边的参数都拖出去，确定连接关系<br>    <img src="https://s2.ax1x.com/2020/01/14/lqSTaT.png" alt="lqSTaT.png"><br>    在模块视图中，右键选择“Fbd1”节点，在弹出的快捷菜单中，选择“有效性检查”命令；<br>    在输出视图中，应显示相关的成功信息。<br>    <img src="https://s2.ax1x.com/2020/01/14/lqSqG4.png" alt="lqSqG4.png"><br>    9.保存，退出。</p><p>6）编辑梯形图模块<br>    1.使用工具条的“添加网络”命令，添加两个网络对象，网络标识分别为“000001”和“000002”<br>    <img src="https://s2.ax1x.com/2020/01/14/lqppdK.png" alt="lqppdK.png"><br>    <img src="https://s2.ax1x.com/2020/01/14/lqpPiD.png" alt="lqpPiD.png"><br>    2. 哎呀，具体的看操作手册 P40页，别人讲很详细了，不想写了。。。。</p><h2 id="4-中途添加设备（在已有的数据库基础上）"><a href="#4-中途添加设备（在已有的数据库基础上）" class="headerlink" title="4.中途添加设备（在已有的数据库基础上）"></a>4.中途添加设备（在已有的数据库基础上）</h2><p>增加 “Modbus从站设置”，对应网络的 “数据项个数”、修改“起始地址”和“读写数量”；<br>去相应的网络下，增加“IO节点”；</p><ul><li><p><strong>增加FF设备</strong></p><p>  1）打开“资源管理器”<br>  2）右键“FF设备库”、“导入FF设备”；<br>  3）在“H1网段”下，“新建H1设备”；<br>  4）选择“物理设备”，将显示的设备拖到新建的设备下，进行映射（模块会自动识别所连接的FF设备）<br>  5）在“FF控制策略”模块下，右键“组态离线编辑”，点击空白地方，左边的“属性”选择“H1网段”；<br>  6）在右边出现的“17-AI7001”拖到空白处即出现“AI_2.”选择参数并拖出，连线；<br>  7）将参数加入Modbus。</p></li><li><p><strong>增添HART设备</strong></p><p>  1）在“控制网络”、“I/O模块列表”、“IO模块4”、“HART”中添加“IO节点”<br>  <img src="https://s2.ax1x.com/2020/01/14/lqpWFO.png" alt="lqpWFO.png"> </p><p>  <img src="https://s2.ax1x.com/2020/01/14/lqpo6A.png" alt="lqpo6A.png"><br>  2）使用“组态软件离线编辑”，增加<br>  <img src="https://s2.ax1x.com/2020/01/14/lqpOk8.png" alt="lqpOk8.png"></p></li><li><p><strong>增添PROFIBUS设备</strong></p><p>  我忘记啦==5555555</p></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,laboratory --&gt;

&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term="多协议网关" scheme="https://adamyandan.github.io/tags/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E7%BD%91%E5%85%B3/"/>
    
    <category term="NCS4000" scheme="https://adamyandan.github.io/tags/NCS4000/"/>
    
  </entry>
  
  <entry>
    <title>cheat software安装方法和注意事项</title>
    <link href="https://adamyandan.github.io/2020/01/14/809%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%85%B6%E4%BB%96%E4%BD%BF%E7%94%A8/"/>
    <id>https://adamyandan.github.io/2020/01/14/809%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%85%B6%E4%BB%96%E4%BD%BF%E7%94%A8/</id>
    <published>2020-01-14T03:50:01.000Z</published>
    <updated>2020-01-14T06:47:13.618Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="准备工具："><a href="#准备工具：" class="headerlink" title="准备工具："></a>准备工具：</h2><ul><li>Everything（搜索软件）</li><li>Greenshot （截屏软件）<br><img src="https://s2.ax1x.com/2020/01/14/lb6xHO.png" alt="lb6xHO.png"><br>(前提是必须有公网！！才能远程！！！)<br>（或者是在同一个局域网下）</li></ul><p><strong>总而言之，别人ping得通你的电脑！</strong></p><h2 id="安装注意事项"><a href="#安装注意事项" class="headerlink" title="安装注意事项"></a>安装注意事项</h2><p><strong>1、Everything搜索软件</strong><br><img src="https://s2.ax1x.com/2020/01/14/lbcFgI.jpg" alt="lbcFgI.jpg"><br>搜索软件安装时在该页面选择“简体中文”，其他操作只需下一步即可，安装位置可自定义。</p><p><strong>2、截图软件</strong><br><img src="https://s2.ax1x.com/2020/01/14/lbcnUg.png" alt="lbcnUg.png"><br>截屏软件安装过程中当遇到该页面时，将滚动条下滑选择“简体中文”，其他操作只需下一步即可，安装位置可自定义。</p><h2 id="设置注意事项"><a href="#设置注意事项" class="headerlink" title="设置注意事项"></a>设置注意事项</h2><p><strong>1、搜索软件</strong><br>打开Everything——&gt;工具——&gt;选项——&gt;HTTP（左边选项栏中的最后一个）——&gt;启用HTTP服务器前打钩——&gt;HTTP服务器端口设置<strong>（该数值一定要大于1024）</strong>——&gt;应用——&gt;确定<br>（操作完成）</p><p><strong>2、截屏软件</strong></p><p>找到截屏软件图标（一般都在电脑右下方处），鼠标放在该图标上右键对其进行基本设置</p><p><em>常规</em></p><p>鼠标右键——&gt;设置（可能有人会遇到打开是英文，别慌，进行设置即可为中文，）——&gt;<br>    常规——&gt;语言部分选择“简体中文”<br>    常规——&gt;热键（可以设置快捷键，方便自己后期操作，我用的是默认设置值F1）<br><img src="https://s2.ax1x.com/2020/01/14/lbgAJJ.png" alt="lbgAJJ.png"></p><p><em>抓图</em><br><img src="https://s2.ax1x.com/2020/01/14/lbgeQ1.png" alt="lbgeQ1.png"><br>检查一下“显示通知”选项前是否有勾勾，如果没有就跳过这页，如果有就取消该勾勾。</p><p><em>输出</em><br>对“保存路径”处进行设置，设置自己后面想保存截图的位置。（最好找个显眼的地方，好方便别人找到）<br><img src="https://s2.ax1x.com/2020/01/14/lbgNOP.png" alt="lbgNOP.png"></p><p><em>抓图后的动作</em><br>选择“直接保存”即可。<br><img src="https://s2.ax1x.com/2020/01/14/lbgDYQ.png" alt="lbgDYQ.png"></p><h2 id="最后将你的地址发给别人"><a href="#最后将你的地址发给别人" class="headerlink" title="最后将你的地址发给别人"></a>最后将你的地址发给别人</h2><p>地址书写形式=<strong>外网IP地址:端口号</strong><br>（这里的端口号就是搜索软件中设置的HTTP端口号，这里的冒号必须是英文的哦，否则就是错误地址。）</p><p><em>外网IP在这里获取</em><br><img src="https://s2.ax1x.com/2020/01/14/lbgTp9.png" alt="lbgTp9.png"><br>点击进入后——“详细信息”</p><p><img src="https://s2.ax1x.com/2020/01/14/lbgbOx.png" alt="lbgbOx.png"><br>获取该IP地址即可<br><img src="https://s2.ax1x.com/2020/01/14/lbv1Df.png" alt="lbv1Df.png"></p><p>!!!!如果你怕别人访问你的电脑，你可以在使用外之后将HTTP端口关闭，或者每次填写不同的端口。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h2 id=&quot;准</summary>
      
    
    
    
    <category term="acrobatics" scheme="https://adamyandan.github.io/categories/acrobatics/"/>
    
    
    <category term="cheat" scheme="https://adamyandan.github.io/tags/cheat/"/>
    
  </entry>
  
  <entry>
    <title>天河可视化应用程序在应用层部署操作说明</title>
    <link href="https://adamyandan.github.io/2020/01/14/%E5%A4%A9%E6%B2%B3%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%BA%94%E7%94%A8%E5%B1%82%E9%83%A8%E7%BD%B2%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/"/>
    <id>https://adamyandan.github.io/2020/01/14/%E5%A4%A9%E6%B2%B3%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%BA%94%E7%94%A8%E5%B1%82%E9%83%A8%E7%BD%B2%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/</id>
    <published>2020-01-14T03:39:01.000Z</published>
    <updated>2020-01-14T03:44:54.505Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="1-部署方式"><a href="#1-部署方式" class="headerlink" title="1.部署方式"></a>1.部署方式</h2><p>1）应用程序采用Tomcat方式进行部署，目前配置的端口号为8080，可修改。<br>修改的方式为：在tomcat 文件中找conf文件夹中的server.xml，修改 &lt;Connector port=”8080”中port值。<br><img src="https://s2.ax1x.com/2020/01/14/lbyzfs.png" alt="lbyzfs.png"></p><p>例如：<Connector port="8080" protocol="HTTP/1.1"               connectionTimeout="20000"               redirectPort="8443" /></p><p>2）服务器重启或配置信息更改之后，需手动重启一下服务startup.bat，关闭服务为shutdown.bat。<br><img src="https://s2.ax1x.com/2020/01/14/lb6C60.png" alt="lb6C60.png"></p><p>3）应用程序文件存放于服务器D：/thsoft 下。</p><h2 id="2-登陆访问"><a href="#2-登陆访问" class="headerlink" title="2.登陆访问"></a>2.登陆访问</h2><p>1）目前局域网访问的地址链接为：<a href="http://192.168.2.3:8080/thsoft-website" target="_blank" rel="noopener">http://192.168.2.3:8080/thsoft-website</a><br>用户名：admin<br>密码：admin</p><p>2）如需外网访问需将服务器IP地址进行映射。</p><h2 id="3-程序内容"><a href="#3-程序内容" class="headerlink" title="3.程序内容"></a>3.程序内容</h2><p>应用程序主要包含的内容有三部分：中央监控大厅、现场状态监控和现场看板。</p><p>1）中央监控大厅<br>通过车间产线模拟每个设备的运行场景，根据采集的数据动态判断每个设备当前的状态和采集值。每两秒刷新一次数据。<br><img src="https://s2.ax1x.com/2020/01/14/lb6A7F.png" alt="lb6A7F.png"></p><p>2）现场状态监控<br>根据采集的数据实时监控设备的运行状态，灰色图标表示“停机”，绿色图标表示“正常”，红色图标表示“报修”。<br><img src="https://s2.ax1x.com/2020/01/14/lb6Vk4.png" alt="lb6Vk4.png"></p><p>3）现场看板<br>系统将采集的数据分类汇总以统计图的形式展示出来，供决策分析。<br><img src="https://s2.ax1x.com/2020/01/14/lb6eh9.png" alt="lb6eh9.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term="T5制造平台" scheme="https://adamyandan.github.io/tags/T5%E5%88%B6%E9%80%A0%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>S323实验室IoT防BUG反玄学手册</title>
    <link href="https://adamyandan.github.io/2020/01/14/%E5%AE%9E%E9%AA%8C%E5%AE%A4IOT%E7%A0%94%E5%8F%91%E5%B9%B3%E5%8F%B0%E9%98%B2BUG%E6%89%8B%E5%86%8C/"/>
    <id>https://adamyandan.github.io/2020/01/14/%E5%AE%9E%E9%AA%8C%E5%AE%A4IOT%E7%A0%94%E5%8F%91%E5%B9%B3%E5%8F%B0%E9%98%B2BUG%E6%89%8B%E5%86%8C/</id>
    <published>2020-01-14T03:29:01.000Z</published>
    <updated>2020-01-14T03:37:58.913Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h2><p>iot系统一共两套，中央馆为iot-1系统，经开区为iot-2系统。</p><p>电脑：iot-1使用一体机，iot-2需要自带笔记本。<br>虚拟机：“ubuntu 12.04 copy”，自带笔记本需要拷贝过去。<br>芯片：iot-1芯片完全正常，iot-2有一定概率出现无法识别bug。<br>节点：节点数量较多时，可能不会全部上线。开个四五个就可以了，不能上的就关掉。<br>激活芯片1个：可以被系统稳定识别出ttyACM0。</p><h2 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h2><ol><li>将芯片插在路由器usb口中，启动路由器。</li><li>启动主机，连接wifi。Iot-1 wifi名称为openwrt，iot-2wifi名称为openwrt111。</li><li>打开虚拟机“ubuntu 12.04 copy”，进入桌面。</li><li>使用一体机的话，进入IoT-tiaozhanbei-big-140008，使用笔记本的话，进入IoT-tiaozhanbei-140008，两者区别在于界面的显示大小。</li><li>打开CISCO图标，连接192.168.1.1，端口号5222，点击连接。</li></ol><h2 id="3-BUG解决方案"><a href="#3-BUG解决方案" class="headerlink" title="3.BUG解决方案"></a>3.BUG解决方案</h2><p>Q1：界面连接不上。</p><p>A: 最大的可能是系统没有识别ttyACM0。解决方法是：使用一个有ttyACM0的协调器芯片插入路由器，重启路由器，等到路由完全启动后，拔出协调器芯片，换上iot-1或iot-2芯片，重启路由器，这时候一般都可以正常连接了。</p><p>如上述操作反复试验无效，则可能是路由器无法有效识别ttyACM0的原因。此时将芯片直插电脑，进入linux shell，输入以下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;Desktop&#x2F;src</span><br><span class="line">sudo .&#x2F;iot-deamon –s &#x2F;dev&#x2F;ttyACM0 aaaa::1&#x2F;64</span><br></pre></td></tr></table></figure><p>如果守护程序启动正常，则可以再连接界面。</p><p>Q2: 界面能连接上，但是topology一片空白。</p><p>A: 你一定没有使用ubuntu 12.04 copy虚拟机。</p><p>最后如果还不行，<strong>玄学。</strong></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term="IoT" scheme="https://adamyandan.github.io/tags/IoT/"/>
    
    <category term="BUG" scheme="https://adamyandan.github.io/tags/BUG/"/>
    
  </entry>
  
  <entry>
    <title>H3C路由器配置方法</title>
    <link href="https://adamyandan.github.io/2020/01/14/H3C%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <id>https://adamyandan.github.io/2020/01/14/H3C%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</id>
    <published>2020-01-14T03:08:01.000Z</published>
    <updated>2020-01-14T03:26:47.094Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="1-1-NAT-PT简介"><a href="#1-1-NAT-PT简介" class="headerlink" title="1.1 NAT-PT简介"></a>1.1 NAT-PT简介</h2><h3 id="1-1-1-NAT-PT应用场景"><a href="#1-1-1-NAT-PT应用场景" class="headerlink" title="1.1.1 NAT-PT应用场景"></a>1.1.1 NAT-PT应用场景</h3><p>IPv6的应用是个循序渐进的过程，在很长时间内，IPv4网络和IPv6网络会同时存在且需要相互通信。在IPv4网络完全过渡到IPv6网络之前，两个网络之间直接的通信可以通过NAT-PT（Network Address Translation-Protocol Translation，附带协议转换的网络地址转换）来实现。NAT-PT提供了IPv4和IPv6地址之间的相互转换功能，例如，使用此技术可以使IPv6网络中的主机直接访问IPv4网络中的FTP服务器。<br>如图1-1所示，NAT-PT作用于IPv4和IPv6网络边缘设备上，所有的地址转换过程都在该设备上实现，对IPv4和IPv6网络来说是透明的，即用户不必改变目前的IPv4网络中主机的配置就可实现IPv6网络与IPv4网络的通信。</p><p>图1-1 NAT-PT示意图：<br><img src="https://s2.ax1x.com/2020/01/14/lbBIKO.png" alt="lbBIKO.png"></p><h3 id="1-1-2-NAT-PT基本概念"><a href="#1-1-2-NAT-PT基本概念" class="headerlink" title="1.1.2 NAT-PT基本概念"></a>1.1.2 NAT-PT基本概念</h3><p>1）NAT-PT机制</p><p>有三种NAT-PT机制可实现IPv4和IPv6地址之间的相互转换：<br>    (1) 静态映射<br>    静态映射是指采用手工配置的IPv6地址与IPv4地址的一一对应关系来实现IPv6地址与IPv4地址的转换。<br>    (2) 动态映射<br>    动态映射是指动态地创建IPv6地址与IPv4地址的对应关系来实现IPv6地址与IPv4地址的转换。和静态映射不同，动态映射中IPv6和IPv4地址之间不存在固定的一一对应关系。<br>    (3) NAPT-PT机制<br>    NAPT-PT（Network Address Port Translation-Protocol Translation，附带协议转换的网络地址端口转换）是指在IP地址静态或动态转换的基础上对TCP、UDP的端口号也进行转换。采用这种“IP地址＋端口号”的映射方式，不同的IPv6地址转换时，可以对应同一个IPv4地址，通过不同的端口号来区分不同的IPv6主机，从而节省IPv4地址资源。</p><p>2）NAT-PT前缀</p><p>NAT-PT前缀是长度为96位的IPv6地址前缀，它具有以下两个作用：</p><ul><li>从IPv6网络发送到IPv4网络的报文到达NAT-PT设备后，设备会检测报文目的IPv6地址的前缀，只有与所配置的NAT-PT前缀相同的报文才允许进行IPv6到IPv4的转换。</li><li>从IPv4网络发送到IPv6网络的报文，经过NAT-PT转换后，源IPv6地址的前缀为配置的NAT-PT前缀。</li></ul><h3 id="1-1-3-NAT-PT实现过程"><a href="#1-1-3-NAT-PT实现过程" class="headerlink" title="1.1.3 NAT-PT实现过程"></a>1.1.3 NAT-PT实现过程</h3><p>1）IPv6侧发起会话<br>图1-2 NAT-PT的实现过程（IPv6侧发起会话）：<br><img src="https://s2.ax1x.com/2020/01/14/lbDddH.png" alt="lbDddH.png"></p><pre><code>(1) 判断是否进行NAT-PT转换：NAT-PT设备接收到IPv6网络主机（IPv6 host）发送给IPv4网络主机（IPv4 host）的报文后，判断该报文是否要转发到IPv4网络。如果报文目的IPv6地址前缀与设备上预先配置的NAT-PT前缀相同，则该报文需要转发到IPv4网络，需要进行NAT-PT转换。(2) 转换源IP地址：设备根据IPv6侧配置的静态或者动态映射，进行IPv6地址到IPv4地址的转换，将报文的源IPv6地址转换为IPv4地址。(3) 转换目的IP地址：设备根据IPv4侧配置的静态映射将目的IPv6地址转换为IPv4地址。如果没有配置静态映射，那么，如果报文中的目的IPv6地址的低32位可以直接转换为合法的IPv4地址，则直接转换为目的IPv4地址；否则，转换不成功。(4) 转发报文并记录映射关系：报文的源IPv6地址和目的IPv6地址都转换为IPv4地址后，设备按照正常的转发流程将报文转发到IPv4网络中的主机。同时，将IPv6地址与IPv4地址的映射关系保存在设备中。(5) 根据记录的映射关系转发应答报文：IPv4网络主机发送给IPv6网络主机的报文到达NAT-PT设备后，设备将根据已保存的映射关系进行相反的转换，从而将报文发送给IPv6网络主机。</code></pre><p>2）IPv4侧发起会话<br>    (1) 判断是否需要进行NAT-PT转换：NAT-PT设备接收到IPv4网络主机发送给IPv6网络主机的报文后，判断该报文是否要转发到IPv6网络。如果报文目的IPv4地址与IPv6侧配置的静态映射IPv4地址相同，则该报文需要转发到IPv6网络，需要进行NAT-PT转换。<br>    (2) 转换源IP地址：设备根据IPv4侧配置的静态或者动态映射，进行IPv4地址到IPv6地址的转换，将报文的源IPv4地址转换为IPv6地址。如果未配置IPv4侧报文的映射，则在源IPv4地址前添加配置的第一个NAT-PT前缀，作为转换后的源IPv6地址。<br>    (3) 转换目的IP地址：设备根据IPv6侧配置的静态映射将目的IPv4地址转换为IPv6地址。<br>    (4) 转发报文并记录映射关系：报文的源IPv4地址和目的IPv4地址都转换为IPv6地址后，设备按照正常的转发流程将报文转发到IPv6网络中的主机。同时，将IPv4地址与IPv6地址的映射关系保存在设备中。<br>    (5) 根据记录的映射关系转发应答报文：IPv6网络主机发送给IPv4网络主机的报文到达NAT-PT设备后，设备将根据已保存的映射关系进行相反的转换，从而将报文发送给IPv4网络主机。</p><h3 id="1-1-4-NAT-PT的局限性"><a href="#1-1-4-NAT-PT的局限性" class="headerlink" title="1.1.4 NAT-PT的局限性"></a>1.1.4 NAT-PT的局限性</h3><p>NAT-PT具有下列一些局限性：</p><ul><li>属于同一会话的请求和响应都必须通过同一台NAT-PT设备，才能进行NAT-PT转换。</li><li>不能转换IPv4报文头的可选项部分。</li><li>缺少端到端的安全性。</li></ul><p>因此，在一些场合不推荐使用NAT-PT，例如，IPv6网络中主机跨越IPv4网络与另一IPv6网络中主机通信时，推荐使用隧道技术。<br>目前，设备支持NAT-PT转换的协议包括ICMP、DNS、FTP以及与网络层协议相关但协议字段不涉及IP地址信息的协议。隧道技术的详细介绍，请参见“三层技术-IP业务配置指导”中的“隧道”。</p><h3 id="1-1-5-协议规范"><a href="#1-1-5-协议规范" class="headerlink" title="1.1.5 协议规范"></a>1.1.5 协议规范</h3><p>与NAT-PT相关的协议规范有：</p><ul><li>RFC 2765：Stateless IP/ICMP Translation Algorithm</li><li>RFC 2766：Network Address Translation - Protocol Translation (NAT-PT)</li></ul><h2 id="2-配置NAT-PT"><a href="#2-配置NAT-PT" class="headerlink" title="2.配置NAT-PT"></a>2.配置NAT-PT</h2><p>在配置NAT_PT之前，首先要让路由器与电脑连接，配置命令的输入需要使用命令窗口输入，msr900路由器可以通过console线连接console口和电脑开启命令窗口，也通过网线使用telnet连接，但是目前没有console线，所以使用telnet连接路由器，这里只介绍我们使用的连接方式，方法如下：</p><ol><li><p>连接网线<br>将网线连接到GE1-GE4口和电脑网口，由于路由器初始地址是192.168.1.1，因此将电脑IPv4地址改到192.168.1.0/255.255.255.0网段，比如192.168.1.2，才能和路由器通信， </p></li><li><p>连接路由器：<br>要使用telnet功能需要在路由器中开启telnet功能，开启方法如下：<br>将网线插到电脑和路由器GE1-GE4端口，在web端登陆192.168.1.1，进入web配置界面。<br><img src="https://s2.ax1x.com/2020/01/14/lbr10g.png" alt="lbr10g.png"><br><img src="https://s2.ax1x.com/2020/01/14/lbr37Q.png" alt="lbr37Q.png"><br>初始用户名和密码都是admin，登陆管理界面（有些浏览器登陆可能有问题，不能登陆就换个其它浏览器试试，谷歌浏览器是可以登陆的）</p></li></ol><p>登陆成功之后会显示如下界面：<br><img src="https://s2.ax1x.com/2020/01/14/lbrYhn.png" alt="lbrYhn.png"></p><p>登陆过后选择系统管理→服务管理→勾选启用Telnet服务<br><img src="https://s2.ax1x.com/2020/01/14/lbr0nU.png" alt="lbr0nU.png"></p><p>然后在系统管理→用户管理→修改用户→选中admin→勾选Telnet服务<br><img src="https://s2.ax1x.com/2020/01/14/lbrWjK.png" alt="lbrWjK.png"></p><p>最后点击保存，以保存当前设置<br><img src="https://s2.ax1x.com/2020/01/14/lbrhnO.png" alt="lbrhnO.png"></p><p>之后在电脑上打开控制面板选择程序→打开启用或关闭Windows功能→勾选telnet客户端<br><img src="https://s2.ax1x.com/2020/01/14/lbr5He.png" alt="lbr5He.png"><br><img src="https://s2.ax1x.com/2020/01/14/lbroAH.png" alt="lbroAH.png"></p><p>完成设置之后就可以使用telnet登陆路由器：<br>在cmd中输入命令telnet [路由器地址]，就可以使用telnet连接到路由器<br><img src="https://s2.ax1x.com/2020/01/14/lbrTNd.png" alt="lbrTNd.png"></p><p>连接之后输入之前web端的用户名和密码就可以登陆到路由器了<br><img src="https://s2.ax1x.com/2020/01/14/lbrOjf.png" alt="lbrOjf.png"><br><img src="https://s2.ax1x.com/2020/01/14/lbsFg0.png" alt="lbsFg0.png"></p><p>telnet登陆成功之后就可以输入命令了（注：命令可以按tap键补全）</p><h2 id="3-配置示例"><a href="#3-配置示例" class="headerlink" title="3.配置示例"></a>3.配置示例</h2><p><img src="https://s2.ax1x.com/2020/01/14/lbsEuT.png" alt="lbsEuT.png"><br>依照上图为例进行配置<br>配置NAT-PT示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">system-view</span><br><span class="line">ipv6</span><br><span class="line">interface GigabitEthernet0&#x2F;1  &#x2F;&#x2F; 0&#x2F;1代表选择GE1口</span><br><span class="line">display this   &#x2F;&#x2F;如查看到打印信息“port link-mode bridge”说明此时这个GE口是bridge模式，需要改变成route模式，初始状态下GE口都是bridge模式</span><br><span class="line"></span><br><span class="line">port link-mode route   &#x2F;&#x2F;改变GE口为route模式</span><br><span class="line">ip address 8.0.0.1 255.255.255.0   &#x2F;&#x2F;将此GE口IPv4地址设置为8.0.0.1（注：每个route模式的GE口与其它所有端口都不能在同一网段）</span><br><span class="line"></span><br><span class="line">natpt enable   &#x2F;&#x2F;启动NAT-PT功能</span><br><span class="line">display this   &#x2F;&#x2F;可以再查看一次端口状态，确认配置无误</span><br><span class="line">quit</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0&#x2F;2   &#x2F;&#x2F;选择GE2口</span><br><span class="line">display this    &#x2F;&#x2F;检查GE口模式</span><br><span class="line">port link-mode route   &#x2F;&#x2F;改变GE口为route模式</span><br><span class="line">ipv6 address 2001::1&#x2F;64   &#x2F;&#x2F;将此GE口IPv6地址设置为2001::1</span><br><span class="line">natpt enable </span><br><span class="line">display this   &#x2F;&#x2F;确定配置无误</span><br><span class="line">quit</span><br><span class="line"></span><br><span class="line">natpt prefix 3001::  &#x2F;&#x2F;配置NAT-PT前缀</span><br><span class="line">natpt v4bound static 8.0.0.2 3001::5   &#x2F;&#x2F;配置IPv4侧报文的静态映射</span><br><span class="line">natpt v6bound static 2001::2 9.0.0.5   &#x2F;&#x2F;配置IPv6侧报文的静态映射</span><br></pre></td></tr></table></figure><p>此时路由器已经设置完毕，可以输入命令<code>display cu</code>并不断按<code>enter</code>键打印所有配置信息检查配置是否正确。</p><p>由于IPv4侧和IPv6侧不在同一网段，要相互通信必须经过一个网关，此时路由器就充当了网关的功能，因此需要将IPv4侧主机IPv4地址设置到8.0.0.0/24网段，比如8.0.0.2。网关设置为8.0.0.1。最后连上GE1口。同理将IPv6侧主机IPv6地址设置到2001::/64网段，比如2001::2。并且将网关设置为2001::1。</p><p>配置完成之后，将IPv4端插在GE1口，将IPv6端插在GE2口，在IPv4端ping 9.0.0.5能收到从IPv6端发回来的相应报文，同样在IPv6端ping 3001::5能收到从IPv4端发回的响应报文</p><p>确定配置成功后，在路由器输入quit退出到用户界面，就是显示<H3C>，而不是[H3C]的界面，输入save，根据提示，将此时的设置保存为文件natpt.cfg。（注：名称可以任取，但必须加.cfg）</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term="H3C路由器" scheme="https://adamyandan.github.io/tags/H3C%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>S323实验室打印机脱机了怎么办？（HP LaserJet MFP M227fdw 型号）</title>
    <link href="https://adamyandan.github.io/2020/01/14/S323%E6%89%93%E5%8D%B0%E6%9C%BA%E8%84%B1%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://adamyandan.github.io/2020/01/14/S323%E6%89%93%E5%8D%B0%E6%9C%BA%E8%84%B1%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-01-14T03:02:01.000Z</published>
    <updated>2020-05-26T13:37:40.335Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="先执行最简单的方案：执行-步骤1-gt-步骤2-gt-步骤4-。"><a href="#先执行最简单的方案：执行-步骤1-gt-步骤2-gt-步骤4-。" class="headerlink" title="先执行最简单的方案：执行 步骤1 -&gt; 步骤2 -&gt; 步骤4 。"></a>先执行最简单的方案：执行 步骤1 -&gt; 步骤2 -&gt; 步骤4 。</h2><h2 id="1-win10下，用cortana搜索“打印机和扫描仪”；"><a href="#1-win10下，用cortana搜索“打印机和扫描仪”；" class="headerlink" title="1.win10下，用cortana搜索“打印机和扫描仪”；"></a>1.win10下，用cortana搜索“打印机和扫描仪”；</h2><p><img src="https://s2.ax1x.com/2020/01/14/lb0hng.png" alt="lb0hng.png"></p><h2 id="2-在已知的设备栏中，找到我们的打印机（现在改名字了，叫S323）"><a href="#2-在已知的设备栏中，找到我们的打印机（现在改名字了，叫S323）" class="headerlink" title="2.在已知的设备栏中，找到我们的打印机（现在改名字了，叫S323）"></a>2.在已知的设备栏中，找到我们的打印机（现在改名字了，叫S323）</h2><p><img src="https://s2.ax1x.com/2020/01/14/lbBSE9.png" alt="lbBSE9.png"><br>点击“删除设备”；</p><h2 id="3-然后去“设备管理器”，在“图像设备”栏下，右键“卸载设备”。"><a href="#3-然后去“设备管理器”，在“图像设备”栏下，右键“卸载设备”。" class="headerlink" title="3.然后去“设备管理器”，在“图像设备”栏下，右键“卸载设备”。"></a>3.然后去“设备管理器”，在“图像设备”栏下，右键“卸载设备”。</h2><h2 id="4-回到“打印机与扫描仪”界面，点击“添加打印机和扫描仪”，下面就可以扫描到我们的打印机了；"><a href="#4-回到“打印机与扫描仪”界面，点击“添加打印机和扫描仪”，下面就可以扫描到我们的打印机了；" class="headerlink" title="4.回到“打印机与扫描仪”界面，点击“添加打印机和扫描仪”，下面就可以扫描到我们的打印机了；"></a>4.回到“打印机与扫描仪”界面，点击“添加打印机和扫描仪”，下面就可以扫描到我们的打印机了；</h2><h2 id="5-之后打开之前在光盘中早就装好的驱动，打开那个软件，添加新设备，找到172-16-34-200的地址，按指示行动！"><a href="#5-之后打开之前在光盘中早就装好的驱动，打开那个软件，添加新设备，找到172-16-34-200的地址，按指示行动！" class="headerlink" title="5.之后打开之前在光盘中早就装好的驱动，打开那个软件，添加新设备，找到172.16.34.200的地址，按指示行动！"></a>5.之后打开之前在光盘中早就装好的驱动，打开那个软件，添加新设备，找到172.16.34.200的地址，按指示行动！</h2><p><strong>如果还是不行的话，建议多试几遍？或者自求多福？==</strong><br>我尽力了/。</p><hr><p>2020.05.26更新</p><h2 id="以下是一些可尝试步骤："><a href="#以下是一些可尝试步骤：" class="headerlink" title="以下是一些可尝试步骤："></a>以下是一些可尝试步骤：</h2><ol><li><p>若 “网络连接” 中有很多 “本地连接XX”，如下图所示。则先 <strong>禁用</strong>不必要的本地连接；<br><a href="https://imgchr.com/i/tF0pIs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/26/tF0pIs.png" alt="tF0pIs.png"></a></p></li><li><p>在 “以太网” 的 “属性” 下，设置静态IPv4地址；<br><a href="https://imgchr.com/i/tF0KiR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/26/tF0KiR.png" alt="tF0KiR.png"></a></p></li></ol><p>注意事项：</p><ul><li>子网掩码为<code>255.255.0.0</code></li><li>默认网关为<code>172.16.34.1</code></li></ul><ol start="3"><li><p>用<code>ipconfig</code>命令查看自己的电脑是否将静态IPv4地址分配成功；</p></li><li><p>用<code>ping 172.16.34.200</code>命令检查，自己的电脑是否ping得通打印机；</p></li><li><p>执行 步骤4  </p></li></ol><p>应该后面没问题了~</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h2 id=&quot;先</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term="打印机" scheme="https://adamyandan.github.io/tags/%E6%89%93%E5%8D%B0%E6%9C%BA/"/>
    
    <category term="脱机" scheme="https://adamyandan.github.io/tags/%E8%84%B1%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>天河数据库.DBF文件占用内存大的解决方法</title>
    <link href="https://adamyandan.github.io/2020/01/14/%E5%A4%A9%E6%B2%B3%E6%95%B0%E6%8D%AE%E5%BA%93DBF%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E5%A4%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://adamyandan.github.io/2020/01/14/%E5%A4%A9%E6%B2%B3%E6%95%B0%E6%8D%AE%E5%BA%93DBF%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E5%A4%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2020-01-14T02:34:01.000Z</published>
    <updated>2020-01-14T03:00:26.065Z</updated>
    
    <content type="html"><![CDATA[<!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --><h2 id="简单问题介绍"><a href="#简单问题介绍" class="headerlink" title="简单问题介绍"></a>简单问题介绍</h2><p>UNDOTBS01.DBF，是表空间文件，主要就是为了undo，即撤销、回滚，只要有DML操作等，就会产生undo数据，久而久之会变得非常大，占用大量磁盘空间。<br><img src="https://s2.ax1x.com/2020/01/14/lbdw8K.jpg" alt="lbdw8K.jpg"></p><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><ol><li>进入机房的服务器，先用管理员身份登录 plsqidev.exe 。</li></ol><p><img src="https://s2.ax1x.com/2020/01/14/lbdvxU.png" alt="lbdvxU.png"></p><ol start="2"><li><p>输入用户名，选择对应的选项。</p><p>用户名：sys/change_on_install（管理员身份）<br>密码：oracle  或者密码：123456<br>数据库orcl<br>连接名用sysdba </p></li><li><p>按下面步骤操作一番。</p><p>New -&gt; SQL Window (新建一个.sql脚本文件)<br>1）create undo tablespace undotBS2 datafile ‘C:\Oracle\oradata\thapp\UNDOTBS2.DBF’ size 100m;<br>//在这个路径是大文件所在路径，新创建这个UNDOTBS2.DBF文件，先不执行<br>2）注释掉上面那一条<br>select * from dba_tablespaces；<br>执行这个<br>3）只执行1）中的命令<br>4）alter system set undo_tablespace=undotBS2;<br>依旧只执行这一条<br>5）drop tablespace undotbs1 including contents;<br>6）执行2）中的命令<br>7）alter database datafile ‘C:\Oracle\oradata\thapp\undotbs2.dbf’ autoextend off;<br>//跟之前创建的文件名保持一致<br>8）重启oracle服务<br>右击计算机-&gt;管理-&gt;服务-&gt;<br><img src="https://s2.ax1x.com/2020/01/14/lbweMD.png" alt="lbweMD.png"><br>-&gt;右击重新启动</p></li><li><p>登陆 plsqidev.exe 。</p><p> Username:THAPP_ENTITY<br> Passwd:thsoft<br> Database:THAPP<br> Connect as:Normal</p></li><li><p>查看三张表。</p><p> Myproject -&gt; Tables -&gt; DEMO_xxx<br> 右击Query Data即可</p></li></ol><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>按照以上步骤，就可以删除原来占用内存比较大的.DBF文件啦~<br>不然的话，天河数据库会跑崩，或者思科的dataflow界面数据上不去！</p><p>本方法参考的网址：<a href="https://blog.csdn.net/sinat_27933301/article/details/80932226" target="_blank" rel="noopener">https://blog.csdn.net/sinat_27933301/article/details/80932226</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- English,acrobatics,contiki,entertainment,hexo,interview,linux,technology,thinking about life,windows,wireshark,labratory --&gt;

&lt;h2 id=&quot;简</summary>
      
    
    
    
    <category term="laboratory" scheme="https://adamyandan.github.io/categories/laboratory/"/>
    
    
    <category term=".DBF文件" scheme="https://adamyandan.github.io/tags/DBF%E6%96%87%E4%BB%B6/"/>
    
    <category term="占内存" scheme="https://adamyandan.github.io/tags/%E5%8D%A0%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>那些让你怦然心动的英语</title>
    <link href="https://adamyandan.github.io/2020/01/11/The%20English%20that%20makes%20your%20heart%20skip%20a%20beat/"/>
    <id>https://adamyandan.github.io/2020/01/11/The%20English%20that%20makes%20your%20heart%20skip%20a%20beat/</id>
    <published>2020-01-11T13:28:01.000Z</published>
    <updated>2020-01-11T14:08:15.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-dust"><a href="#1-dust" class="headerlink" title="1. dust"></a>1. dust</h2><p>dust同时又是自己的反义词哦。<br>dust the bookshelves，将灰尘从书架上扫落<br>dust the cake with icing sugar，在蛋糕上撒糖粉</p><p>dust既可以表示从物体表面上扫落粉尘，又能表示在物体表面上撒上粉尘。</p><p>这类词叫<code>auto-antonym</code>，特性就是自身有两个正好相反的含义。<br><a href="http://www.fun-with-words.com/nym_autoantonyms.html" target="_blank" rel="noopener">fun-with-words</a>和<a href="https://www.mentalfloss.com/article/57032/25-words-are-their-own-opposites" target="_blank" rel="noopener">25 Words That Are Their Own Opposites</a>收集了一些相同特性的单词,有兴趣的可以了解一下。</p><h2 id="2-serendipity"><a href="#2-serendipity" class="headerlink" title="2.serendipity"></a>2.serendipity</h2><p>即，与美好的事物不期而遇，意外发现美好事物的能力。<br><img src="https://s2.ax1x.com/2020/01/11/lIBmss.png" alt="lIBmss.png"></p><p>serendipity可以是你匆忙赶到考场后发现自己忘了带笔，却意外地在桌子地抽屉里发现了一只笔；可以是你在漫无目的地闲逛时，无意中却遇到了最美的风景；可以是“与君初相识，犹如故人归”；可以是觅得知己时地相见恨晚；可以是短暂相交后地性情相投；可以是《罗马假日》里公主与平民间只有一天却足以铭记终生地爱情；可以是《泰坦尼克号》里Jack和Rose的船上的相遇。</p><p><strong>总之，serendipity代表着一切与美好的不期而遇。</strong></p><p>由serendipity这个词引出了serendipper，指有感知力和洞察力，能够发现生活中美好垫底的人。</p><p>Be a serendipper, and find your own serendipity!</p><h2 id="3-redamancy"><a href="#3-redamancy" class="headerlink" title="3.redamancy"></a>3.redamancy</h2><p>是一个单词，也是一个故事。</p><p>释义：你爱着某人时，某人也在爱你。</p><h2 id="4-iridescent"><a href="#4-iridescent" class="headerlink" title="4. iridescent"></a>4. iridescent</h2><p>释义：彩虹色的、彩虹般绚丽的</p><p>这是《怦然心动》这部电影中，男主的爷爷说出的一句经典台词。<br><img src="https://s2.ax1x.com/2020/01/11/lIBbOs.jpg" alt="lIBbOs.jpg"></p><p>Some of us get dipped in flat, some in satin, some in gloss. But every once in a while you find someone who’s iridescent, and when you do, nothing will ever compare.<br>有些人平庸浅薄，金玉其外，败絮其中。可不经意间，有一天你会遇到一个彩虹般绚丽的人，从此以后，其他人就不过是匆匆浮云。（斯人若彩虹，遇上方知有）</p><p>看到这段，不禁让我想起一句诗：曾经沧海难为水，除去巫山不是云。</p><h2 id="5-frenemy"><a href="#5-frenemy" class="headerlink" title="5. frenemy"></a>5. frenemy</h2><p>释义：亦敌亦友</p><p>送给最大的敌人，也是最敬佩的朋友。</p><p>英英释义：”Frenemy” (alternately spelled “frienemy”) is a portmanteau of “friend” and “enemy” that can refer to either an enemy pretending to be a friend or someone who really is a friend but is also a rival.</p><h2 id="6-shmily"><a href="#6-shmily" class="headerlink" title="6.shmily"></a>6.shmily</h2><p>一个缩写词<br>释义：看我是多么的爱你(see how much I love you)</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-dust&quot;&gt;&lt;a href=&quot;#1-dust&quot; class=&quot;headerlink&quot; title=&quot;1. dust&quot;&gt;&lt;/a&gt;1. dust&lt;/h2&gt;&lt;p&gt;dust同时又是自己的反义词哦。&lt;br&gt;dust the bookshelves，将灰尘从书架上扫落&lt;b</summary>
      
    
    
    
    <category term="English" scheme="https://adamyandan.github.io/categories/English/"/>
    
    
    <category term="English" scheme="https://adamyandan.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>matlab 2016a破解教程</title>
    <link href="https://adamyandan.github.io/2020/01/10/matlab%202016a%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/"/>
    <id>https://adamyandan.github.io/2020/01/10/matlab%202016a%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/</id>
    <published>2020-01-10T07:05:01.000Z</published>
    <updated>2020-01-10T07:39:58.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装教程"><a href="#一、安装教程" class="headerlink" title="一、安装教程"></a>一、安装教程</h2><ol><li>下载的所需准备文件</li></ol><ul><li>Matlab_R2016a_win64.iso(安装文件)</li><li>Matlab_R2016a_破解文档(破解时会用到)</li></ul><p>链接：<a href="https://pan.baidu.com/s/1VnKc7fCHMfR_UFZcGkmMpw" target="_blank" rel="noopener">https://pan.baidu.com/s/1VnKc7fCHMfR_UFZcGkmMpw</a><br>提取码：38n4 </p><ol start="2"><li><p>用解压软件解压安装文件（.iso后缀的）<br><img src="https://s2.ax1x.com/2020/01/10/lhNrN9.png" alt="lhNrN9.png"></p></li><li><p>点击set up进行安装<br><img src="https://s2.ax1x.com/2020/01/10/lhN5AH.png" alt="lhN5AH.png"></p></li><li><p>点击setup.exe，之后稍等一会儿，MathWorks安装程序启动，启动后选择“使用文件安装密钥 不需要Internet连接”<br><img src="https://s2.ax1x.com/2020/01/10/lhUuCR.png" alt="lhUuCR.png"></p></li><li><p>点击下一步，是否接受许可协议的条款哪儿选择“是”<br><img src="https://s2.ax1x.com/2020/01/10/lhUd2t.png" alt="lhUd2t.png"></p></li><li><p>点击下一步，选择“我已有我的许可证的文件安装密钥”。</p></li></ol><p>在下面输入秘钥：“09806-07443-53955-64350-21751-41297”<br><img src="https://s2.ax1x.com/2020/01/10/lhU2Ps.png" alt="lhU2Ps.png"></p><ol start="7"><li><p>选择要安装的目录，我安装在“D:\Program Files\matlab”<br><img src="https://s2.ax1x.com/2020/01/10/lhUHIJ.png" alt="lhUHIJ.png"></p></li><li><p>选择需要安装的产品，建议全选，也可根据自己需要选择要安装的产品，我是全选的，选择之后点击“下一步”。<br><img src="https://s2.ax1x.com/2020/01/10/lhaiid.png" alt="lhaiid.png"></p></li><li><p>之后进入安装选项，下面的两个选项都选择，之后点击“下一步”<br><img src="https://s2.ax1x.com/2020/01/10/lhaVQP.png" alt="lhaVQP.png"></p></li><li><p>进入“确认”页面，点击“安装”</p></li><li><p>进入安装界面，有进度条显示安装进度，安装过程需要较长时间<br><img src="https://s2.ax1x.com/2020/01/10/lhalJs.png" alt="lhalJs.png"></p></li><li><p>安装完成之后，进入“产品配置说明”界面，点击“下一步”继续<br><img src="https://s2.ax1x.com/2020/01/10/lhaNeU.png" alt="lhaNeU.png"></p></li><li><p>之后进入“安装完毕”界面，点击“完成”按钮，完成安装.<br><img src="https://s2.ax1x.com/2020/01/10/lhaBWR.png" alt="lhaBWR.png"><br>安装完成后不要急着打开，接下来是破解教程。</p></li></ol><h2 id="二、破解教程"><a href="#二、破解教程" class="headerlink" title="二、破解教程"></a>二、破解教程</h2><ol><li><p>将下载的Matlab 2016a 破解文件解压，解压后文件如图所示。<br>文件夹中的“license_standalone.lic”就是许可文件<br><img src="https://s2.ax1x.com/2020/01/10/lhdm11.png" alt="lhdm11.png"></p></li><li><p>之后打开MATLAB的安装目录D:\Program Files\matlab\bin\win64点击“activate_matlab.exe”进行激活，选择“在不选择Internet情况下手动激活”，点击“下一步”继续。<br><img src="https://s2.ax1x.com/2020/01/10/lhd0HS.png" alt="lhd0HS.png"></p></li><li><p>选择“输入许可证文件的完成路径（包括文件名）”,在“浏览中”选择刚才解压的“Matlab_R2016a_破解文档”文件夹中的许可文件<br><img src="https://s2.ax1x.com/2020/01/10/lhdqjx.png" alt="lhdqjx.png"><br><img src="https://s2.ax1x.com/2020/01/10/lhdxED.png" alt="lhdxED.png"></p></li><li><p>之后进入“离线激活”界面，现在的许可证文件的路径已经填写完整，点击“下一步”<br><img src="https://s2.ax1x.com/2020/01/10/lhwZVS.png" alt="lhwZVS.png"></p></li><li><p>之后提示“激活完成”，如图所示。此时不要打开软件。<br><img src="https://s2.ax1x.com/2020/01/10/lhw3rV.png" alt="lhw3rV.png"></p></li><li><p>打开解压的“Matlab_R2016a_破解文档”文件夹中的MATLAB Production Server\R2016a\bin\win64，复制其中的三个dll文件<br><img src="https://s2.ax1x.com/2020/01/10/lhwwx1.png" alt="lhwwx1.png"></p></li><li><p>之后打开D:\Program Files\matlab\R2016a\bin\win64文件，<br>将复制的dll文件粘贴在这个文件夹中，系统会提示“复制文件”选项，所有文件都选择“复制和替换”即可。</p></li><li><p>之后打开软件，就拥有一个完全免费的matlab 2016a中文破解版本了。<br><img src="https://s2.ax1x.com/2020/01/10/lhwRGd.png" alt="lhwRGd.png"><br><img src="https://s2.ax1x.com/2020/01/10/lhwIqf.png" alt="lhwIqf.png"></p></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、安装教程&quot;&gt;&lt;a href=&quot;#一、安装教程&quot; class=&quot;headerlink&quot; title=&quot;一、安装教程&quot;&gt;&lt;/a&gt;一、安装教程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;下载的所需准备文件&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Matlab_R2016a_win6</summary>
      
    
    
    
    <category term="technology" scheme="https://adamyandan.github.io/categories/technology/"/>
    
    
    <category term="matlab" scheme="https://adamyandan.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>在cooja中运行collect view实验例子出现问题时</title>
    <link href="https://adamyandan.github.io/2020/01/09/%E5%9C%A8cooja%E4%B8%AD%E4%BD%BF%E7%94%A8example%E4%B8%8B%E7%9A%84collect%20view%E5%AE%9E%E4%BE%8B%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%97%B6/"/>
    <id>https://adamyandan.github.io/2020/01/09/%E5%9C%A8cooja%E4%B8%AD%E4%BD%BF%E7%94%A8example%E4%B8%8B%E7%9A%84collect%20view%E5%AE%9E%E4%BE%8B%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%97%B6/</id>
    <published>2020-01-09T14:50:01.000Z</published>
    <updated>2020-01-09T15:04:19.446Z</updated>
    
    <content type="html"><![CDATA[<p>Cooja是Contiki无线嵌入式系统自带的网络模拟器，Cooja的功能十分强大，开发者通过使用Cooja可以建立基于软件的开发工程，对各种所支持的板进行模拟，而不需要硬件资源。</p><p>collectview是cooja中自带的工具，可以对WSN中的节点进行详细的分析，如占空比、能源消耗、网络结构图等。</p><p>下面说一下如何在cooja中运行collectview的官方例子，系统版本为contiki-3.0，环境为虚拟机上运行InstantContiki3.0。</p><ol><li>运行cooja仿真器，找到collectview的例子</li></ol><p>选择：file-&gt;open simulation-&gt;browse<br>路径：contiki-3.0/examples/collect/example-collect-view.csc。</p><ol start="2"><li><p>打开工程后，会弹出“sensor data collect with contiki”窗口。</p></li><li><p>点击<code>start</code>按钮。<br>启动网络</p></li><li><p>在“sensor data collect with contiki”窗口选择“node control”模块后，并点击<code>start collect</code>按钮</p></li><li><p>你会发现“power”等其他选项卡，里面的内容一片空白，没有显示统计数据。而且如果点击其他选项还可能报错误，如下图所示：<br><img src="https://s2.ax1x.com/2020/01/09/lftsgK.png" alt="lftsgK.png"></p></li><li><p>别慌，按以下步骤操作：</p></li></ol><ul><li>关闭目前开启的“sensor data collect with contiki”窗口；</li><li>在cooja中选择tools-&gt;Collect View-&gt;Sky1；</li><li>之后，就会重新打开了一个“Sensor Data Collect with Contiki”界面；</li><li>在这个界面中再选择”Node Control”，点击“Start Collect”，然后点击“Send command to nodes”；</li><li>再选择”Power”就会显示网络数据的统计信息（可能需要等一会，用于统计）。</li></ul><p>之后就有数据显示出来了，如下图所示：<br><img src="https://s2.ax1x.com/2020/01/09/lftI8P.png" alt="lftI8P.png"><br><img src="https://s2.ax1x.com/2020/01/09/lftTv8.jpg" alt="lftTv8.jpg"></p><p>具体原因我也不清楚，由于刚接触Cooja仿真，所以大家如果有知道原因的，请为我解答一下。<br>例子能够运行之后，下一步就是将collect view功能集成到其他程序中，从而实现在其他contiki程序中对网络数据进行统计。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Cooja是Contiki无线嵌入式系统自带的网络模拟器，Cooja的功能十分强大，开发者通过使用Cooja可以建立基于软件的开发工程，对各种所支持的板进行模拟，而不需要硬件资源。&lt;/p&gt;
&lt;p&gt;collectview是cooja中自带的工具，可以对WSN中的节点进行详细的</summary>
      
    
    
    
    <category term="contiki" scheme="https://adamyandan.github.io/categories/contiki/"/>
    
    
    <category term="contiki" scheme="https://adamyandan.github.io/tags/contiki/"/>
    
    <category term="cooja" scheme="https://adamyandan.github.io/tags/cooja/"/>
    
  </entry>
  
  <entry>
    <title>wireshark在win10下检测不出捕获接口</title>
    <link href="https://adamyandan.github.io/2020/01/09/wireshark%20%E5%9C%A8win10%E4%B8%8B%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%87%BA%E6%8D%95%E8%8E%B7%E6%8E%A5%E5%8F%A3/"/>
    <id>https://adamyandan.github.io/2020/01/09/wireshark%20%E5%9C%A8win10%E4%B8%8B%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%87%BA%E6%8D%95%E8%8E%B7%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-01-09T09:50:01.000Z</published>
    <updated>2020-01-09T14:50:19.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可能性1：NPF服务没有启动"><a href="#可能性1：NPF服务没有启动" class="headerlink" title="可能性1：NPF服务没有启动"></a>可能性1：NPF服务没有启动</h2><p>安装wireshark后打开提示没有找到捕获接口，可能是NPF（Netgroup Packet Filter 网络数据包过滤器）服务没有启动，解决办法就是启动NPF服务，然后重启wireshark。 </p><p>启动NPF的方法：</p><ol><li>以管理员的身份运行命令行程序cmd.exe;</li><li>输入<code>net start npf</code>命令，确定后就会提示服务启动成功;</li><li>这样的方式只能在这一次启动NPF服务，电脑重启之后又要重新启动，如果希望电脑启动时自动启用NPF服务，则可以在上面第二步将命令行换成<code>sc config npf start=auto</code>。</li></ol><h2 id="可能性2：wireshark自带的wincap不支持win10"><a href="#可能性2：wireshark自带的wincap不支持win10" class="headerlink" title="可能性2：wireshark自带的wincap不支持win10"></a>可能性2：wireshark自带的wincap不支持win10</h2><p>在<a href="http://www.win10pcap.org/download/" target="_blank" rel="noopener">下载安装Win10Pcap</a>网址可解决此问题。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;可能性1：NPF服务没有启动&quot;&gt;&lt;a href=&quot;#可能性1：NPF服务没有启动&quot; class=&quot;headerlink&quot; title=&quot;可能性1：NPF服务没有启动&quot;&gt;&lt;/a&gt;可能性1：NPF服务没有启动&lt;/h2&gt;&lt;p&gt;安装wireshark后打开提示没有找到捕获</summary>
      
    
    
    
    <category term="wireshark" scheme="https://adamyandan.github.io/categories/wireshark/"/>
    
    
    <category term="wireshark" scheme="https://adamyandan.github.io/tags/wireshark/"/>
    
    <category term="windows" scheme="https://adamyandan.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>contiki compile error</title>
    <link href="https://adamyandan.github.io/2020/01/07/contiki%20compile%20error/"/>
    <id>https://adamyandan.github.io/2020/01/07/contiki%20compile%20error/</id>
    <published>2020-01-07T14:50:01.000Z</published>
    <updated>2020-01-07T14:53:19.086Z</updated>
    
    <content type="html"><![CDATA[<p>在cooja仿真添加sky mote的时候，选择相对应的<code>.c</code>文件后，编译会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make: msp430-gcc: Command not found</span><br><span class="line">  CC        ..&#x2F;..&#x2F;core&#x2F;net&#x2F;rime&#x2F;rimeaddr.c</span><br><span class="line">make: msp430-gcc: Command not found</span><br><span class="line">make: *** [obj_sky&#x2F;rimeaddr.o] Error 127</span><br></pre></td></tr></table></figure><p>说明没有安装msp430插件，需要执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-msp430</span><br></pre></td></tr></table></figure><p>安装完成后，再次选择文件点击编译，就好啦~</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在cooja仿真添加sky mote的时候，选择相对应的&lt;code&gt;.c&lt;/code&gt;文件后，编译会出现以下错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl</summary>
      
    
    
    
    <category term="contiki" scheme="https://adamyandan.github.io/categories/contiki/"/>
    
    
    <category term="contiki" scheme="https://adamyandan.github.io/tags/contiki/"/>
    
    <category term="cooja" scheme="https://adamyandan.github.io/tags/cooja/"/>
    
  </entry>
  
  <entry>
    <title>cooja中的RPL目标函数与仿真（DGRM模式下）</title>
    <link href="https://adamyandan.github.io/2020/01/05/contiki%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RPL%E7%AF%87%EF%BC%881%EF%BC%89/"/>
    <id>https://adamyandan.github.io/2020/01/05/contiki%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RPL%E7%AF%87%EF%BC%881%EF%BC%89/</id>
    <published>2020-01-05T14:00:01.000Z</published>
    <updated>2020-01-08T14:49:46.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>低功耗和有损耗网络的路由协议利用目标函数(OF)建立一个面向目标的有向无环图(DODAG)。目标函数根据某种算法或计算公式使用路由度量来形成DODAG。基本上，目标函数优化或约束用于形成路由的路由度量，从而帮助选择最佳路由。在同一个节点和网格网络上可能有许多目标函数在运行，因为不同的部署目标差异很大，单个网格网络可能需要承载具有非常不同的路径质量要求的流量。</p><p>在Contiki中实现RPL，内置有两个目标函数，但是默认情况下它使用的是最小化ETX值的那个。但是，在所有路由场景中，相同的策略不可能是最佳的路由策略。因此，需要相应地修改目标函数，以适应任何额外的约束或实现不同的目标。</p><h2 id="2-这章节将会学到"><a href="#2-这章节将会学到" class="headerlink" title="2.这章节将会学到"></a>2.这章节将会学到</h2><p>本教程的基本假设是您了解用于低功耗和有损网络(RPL)的路由协议的工作原理。<br>这里使用并解释了ContikiOS 3.0 RPL的实现。<br>以下是本教程的解释:</p><ul><li>不同的RPL相关功能及其工作</li><li>示例场景和RPL目标函数的修改</li><li>基于DGRM模型的Cooja仿真</li></ul><h2 id="3-源代码路径"><a href="#3-源代码路径" class="headerlink" title="3.源代码路径"></a>3.源代码路径</h2><p>在contiki-3.0的操作系统下</p><p>~/contiki/core/net/rpl/rpl-conf.h<br>~/contiki/core/net/rpl/rpl-of0.c<br>~/contiki/core/net/rpl/rpl-mrhof.c<br>~/contiki/tools/cooja</p><h2 id="4-相关文件及功能"><a href="#4-相关文件及功能" class="headerlink" title="4. 相关文件及功能"></a>4. 相关文件及功能</h2><p>具有RPL要点的一些重要文件:rpl-config.h, rpl-of0.c, rpl-mhrof.c。但是这里只提到了这些文件中的一些重要函数。</p><h3 id="rpl-conf-h"><a href="#rpl-conf-h" class="headerlink" title="rpl-conf.h"></a>rpl-conf.h</h3><p><strong>RPL_CONF_STATS</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Set to 1 to enable RPL statistics *&#x2F;</span><br><span class="line">#ifndef RPL_CONF_STATS</span><br><span class="line">#define RPL_CONF_STATS 0</span><br><span class="line">#endif &#x2F;* RPL_CONF_STATS *&#x2F;</span><br></pre></td></tr></table></figure><p>这里禁用了RPL配置统计信息。我们需要将它设置为1。</p><p><strong>RPL_DAG_MC</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line"> * Select routing metric supported at runtime. This must be a valid</span><br><span class="line"> * DAG Metric Container Object Type (see below). Currently, we only </span><br><span class="line"> * support RPL_DAG_MC_ETX and RPL_DAG_MC_ENERGY.</span><br><span class="line"> * When MRHOF (RFC6719) is used with ETX, no metric container must</span><br><span class="line"> * be used; instead the rank carries ETX directly.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifdef RPL_CONF_DAG_MC</span><br><span class="line">#define RPL_DAG_MC RPL_CONF_DAG_MC</span><br><span class="line">#else</span><br><span class="line">#define RPL_DAG_MC RPL_DAG_MC_NONE</span><br><span class="line">#endif &#x2F;* RPL_CONF_DAG_MC *&#x2F;</span><br></pre></td></tr></table></figure><p>选择运行时支持的路由度量。<br>这里支持使用ETX和ENERGY类型的RPL度量容器。（RPL_DAG_MC_ETX 和 RPL_DAG_MC_ENERGY）<br>如果您开发了一个目标函数和相关的度量容器，则可以支持它。</p><p><strong>RPL_OF</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * The objective function used by RPL is configurable through the </span><br><span class="line"> * RPL_CONF_OF parameter. This should be defined to be the name of an </span><br><span class="line"> * rpl_of object linked into the system image, e.g., rpl_of0.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifdef RPL_CONF_OF</span><br><span class="line">#define RPL_OF RPL_CONF_OF</span><br><span class="line">#else</span><br><span class="line">&#x2F;* ETX is the default objective function. *&#x2F;</span><br><span class="line">#define RPL_OF rpl_mrhof</span><br><span class="line">#endif &#x2F;* RPL_CONF_OF *&#x2F;</span><br></pre></td></tr></table></figure><p>RPL_OF配置了RPL的目标函数。在这里，ETX是默认的目标函数。这应该定义为链接到系统映像的rpl_of对象的名称，比如rpl_of0。在这里，您还可以将它定义为您自己开发的目标函数。</p><p><strong>RPL_LEAF_ONLY</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * This value decides if this node must stay as a leaf or not</span><br><span class="line"> * as allowed by draft-ietf-roll-rpl-19#section-8.5</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifdef RPL_CONF_LEAF_ONLY</span><br><span class="line">#define RPL_LEAF_ONLY RPL_CONF_LEAF_ONLY</span><br><span class="line">#else</span><br><span class="line">#define RPL_LEAF_ONLY 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>节点是否应该作为叶节点由这个值决定。<br>(如draft-ietf-roll-rpl-19#section-8.5中所述)</p><p><strong>RPL_CONF_DEFAULT_ROUTE_INFINITE_LIFETIME</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * RPL Default route lifetime</span><br><span class="line"> * The RPL route lifetime is used for the downward routes and for the default</span><br><span class="line"> * route. In a high density network with DIO suppression activated it may happen</span><br><span class="line"> * that a node will never send a DIO once the DIO interval becomes high as it</span><br><span class="line"> * has heard DIO from many neighbors already. As the default route to the</span><br><span class="line"> * preferred parent has a lifetime reset by receiving DIO from the parent, it</span><br><span class="line"> * means that the default route can be destroyed after a while. Setting the</span><br><span class="line"> * default route with infinite lifetime secures the upstream route.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifdef RPL_CONF_DEFAULT_ROUTE_INFINITE_LIFETIME</span><br><span class="line">#define RPL_DEFAULT_ROUTE_INFINITE_LIFETIME                    RPL_CONF_DEFAULT_ROUTE_INFINITE_LIFETIME</span><br><span class="line">#else</span><br><span class="line">#define RPL_DEFAULT_ROUTE_INFINITE_LIFETIME                    0</span><br><span class="line">#endif &#x2F;* RPL_CONF_DEFAULT_ROUTE_INFINITE_LIFETIME *&#x2F;</span><br></pre></td></tr></table></figure><p>RPL路由生存期用于向下路由和默认路由的构建。在高密度网络且DIO不活跃时（组网稳定后），可能会发生这种情况：一个节点永远不会发送DIO报文了，一旦发送DIO的时间间隔变得很高则已经收到很多邻居的来信了。默认路径通过接收来自父节点的DIO信号来重置首选父节点的生存期，它表示默认路由可以在一段时间后销毁。<br>设置具有无限生存期的默认路由保护上行路由。</p><p><strong>RPL_DIO_INTERVAL_MIN</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * The DIO interval (n) represents 2^n ms.</span><br><span class="line"> *</span><br><span class="line"> * According to the specification, the default value is 3 which</span><br><span class="line"> * means 8 milliseconds. That is far too low when using duty cycling</span><br><span class="line"> * with wake-up intervals that are typically hundreds of milliseconds.</span><br><span class="line"> * ContikiRPL thus sets the default to 2^12 ms &#x3D; 4.096 s.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifdef RPL_CONF_DIO_INTERVAL_MIN</span><br><span class="line">#define RPL_DIO_INTERVAL_MIN        RPL_CONF_DIO_INTERVAL_MIN</span><br><span class="line">#else</span><br><span class="line">#define RPL_DIO_INTERVAL_MIN        12</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>DIO以2^n ms的时间间隔对外发送。<br>根据说明，默认的值为3（即2^3=8 ms）。当使用任务循环时，这个值太低了唤醒间隔通常为数百毫秒。<br>ContikiRPL因此设置默认值为2^12 ms = 4.096 s.</p><p><strong>RPL_INIT_LINK_METRIC</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Initial metric attributed to a link when the ETX is unknown</span><br><span class="line"> *&#x2F;</span><br><span class="line">#ifndef RPL_CONF_INIT_LINK_METRIC</span><br><span class="line">#define RPL_INIT_LINK_METRIC        2</span><br><span class="line">#else</span><br><span class="line">#define RPL_INIT_LINK_METRIC        RPL_CONF_INIT_LINK_METRIC</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>当ETX的值位置是，初始化这个度量值为2</p><h3 id="of0-c"><a href="#of0-c" class="headerlink" title="of0.c"></a>of0.c</h3><p>这个文件中描述了RPL中of0目标函数的定义。</p><p><strong>calculate_rank(rpl_parent_t * p, rpl_rank_t base_rank)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static rpl_rank_t</span><br><span class="line">calculate_rank(rpl_parent_t *p, rpl_rank_t base_rank)</span><br><span class="line">&#123;</span><br><span class="line">  rpl_rank_t increment;</span><br><span class="line">  if(base_rank &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    if(p &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">      return INFINITE_RANK;</span><br><span class="line">    &#125;</span><br><span class="line">    base_rank &#x3D; p-&gt;rank;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment &#x3D; p !&#x3D; NULL ?</span><br><span class="line">                p-&gt;dag-&gt;instance-&gt;min_hoprankinc :</span><br><span class="line">                DEFAULT_RANK_INCREMENT;</span><br><span class="line"></span><br><span class="line">  if((rpl_rank_t)(base_rank + increment) &lt; base_rank) &#123;</span><br><span class="line">    PRINTF(&quot;RPL: OF0 rank %d incremented to infinite rank due to wrapping\n&quot;,</span><br><span class="line">        base_rank);</span><br><span class="line">    return INFINITE_RANK;</span><br><span class="line">  &#125;</span><br><span class="line">  return base_rank + increment;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里计算节点的秩。节点的秩基于它的父级秩(parents rank)和基级秩(base rank)。</p><ul><li>如果基秩为0，而节点没有父结点，则节点的秩为无穷大。</li><li>如果基秩为0并且父秩存在，那么基秩就等于父秩。</li><li>如果基秩不为零，那么根据父级是否存在，增量(increment)将成为DAG instance中父节点的min_hoprankinc或DEFAULT_RANK_INCREMENT。</li></ul><p>简而言之，如果没有父节点，那么base_rank将增加为一个默认的增量，否则它将使用有关父级的信息来增加base_rank。</p><p>在最后一部分中，如果计算出的新秩(new rank)小于基秩(bese rank)，则新秩(new rank)由于环路loop而变得无穷大。</p><p>新计算的秩(the new caculate_rank) = 基秩(base_rank) + 增量(increment)。</p><p><strong>best_dag(rpl_dag_t * d1, rpl_dag_t * d2)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static rpl_dag_t *</span><br><span class="line">best_dag(rpl_dag_t *d1, rpl_dag_t *d2)</span><br><span class="line">&#123;</span><br><span class="line">  if(d1-&gt;grounded) &#123;</span><br><span class="line">    if (!d2-&gt;grounded) &#123;</span><br><span class="line">      return d1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if(d2-&gt;grounded) &#123;</span><br><span class="line">    return d2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(d1-&gt;preference &lt; d2-&gt;preference) &#123;</span><br><span class="line">    return d2;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if(d1-&gt;preference &gt; d2-&gt;preference) &#123;</span><br><span class="line">      return d1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(d2-&gt;rank &lt; d1-&gt;rank) &#123;</span><br><span class="line">    return d2;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return d1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数比较两个dag，并根据目标函数返回两个dag中最好的一个(作为输入d1和d2传递)。<br>这里有3个标准来找到最佳的DAG。</p><ul><li>第一个是检查DAG是否接地(if the DAG is grounded)。</li><li>其次是每个DAG的偏好度量(the preference metric of each DAG)。</li><li>第三个是每个DAG的秩(the rank of each DAG)。</li></ul><p><strong>best_parent(rpl_parent_t * p1, rpl_parent_t * p2)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static rpl_parent_t *</span><br><span class="line">best_parent(rpl_parent_t *p1, rpl_parent_t *p2)</span><br><span class="line">&#123;</span><br><span class="line">  rpl_rank_t r1, r2;</span><br><span class="line">  rpl_dag_t *dag;  </span><br><span class="line">  uip_ds6_nbr_t *nbr1, *nbr2;</span><br><span class="line">  nbr1 &#x3D; rpl_get_nbr(p1);</span><br><span class="line">  nbr2 &#x3D; rpl_get_nbr(p2);</span><br><span class="line"></span><br><span class="line">  dag &#x3D; (rpl_dag_t *)p1-&gt;dag; &#x2F;* Both parents must be in the same DAG. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if(nbr1 &#x3D;&#x3D; NULL || nbr2 &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    return dag-&gt;preferred_parent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PRINTF(&quot;RPL: Comparing parent &quot;);</span><br><span class="line">  PRINT6ADDR(rpl_get_parent_ipaddr(p1));</span><br><span class="line">  PRINTF(&quot; (confidence %d, rank %d) with parent &quot;,</span><br><span class="line">        nbr1-&gt;link_metric, p1-&gt;rank);</span><br><span class="line">  PRINT6ADDR(rpl_get_parent_ipaddr(p2));</span><br><span class="line">  PRINTF(&quot; (confidence %d, rank %d)\n&quot;,</span><br><span class="line">        nbr2-&gt;link_metric, p2-&gt;rank);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  r1 &#x3D; DAG_RANK(p1-&gt;rank, p1-&gt;dag-&gt;instance) * RPL_MIN_HOPRANKINC  +</span><br><span class="line">    nbr1-&gt;link_metric;</span><br><span class="line">  r2 &#x3D; DAG_RANK(p2-&gt;rank, p1-&gt;dag-&gt;instance) * RPL_MIN_HOPRANKINC  +</span><br><span class="line">    nbr2-&gt;link_metric;</span><br><span class="line">  &#x2F;* Compare two parents by looking both and their rank and at the ETX</span><br><span class="line">     for that parent. We choose the parent that has the most</span><br><span class="line">     favourable combination. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if(r1 &lt; r2 + MIN_DIFFERENCE &amp;&amp;</span><br><span class="line">     r1 &gt; r2 - MIN_DIFFERENCE) &#123;</span><br><span class="line">    return dag-&gt;preferred_parent;</span><br><span class="line">  &#125; else if(r1 &lt; r2) &#123;</span><br><span class="line">    return p1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return p2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数比较父节点并根据目标函数返回最佳父节点。<br>这里根据候选父节点的rank值和ETX值对候选父节点进行比较。<br>这是一个重要的功能，因为路线的形成是在此基础上选择最佳的DAG。</p><h3 id="rpl-mhrof-c"><a href="#rpl-mhrof-c" class="headerlink" title="rpl-mhrof.c"></a>rpl-mhrof.c</h3><p>该文件实现了带有滞后目标函数(MRHOF)的最小秩。目标函数使用ETX作为路由度量，它还有能量度量的存根。</p><p><strong>calculate_path_metric(rpl_parent_t * p)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static rpl_path_metric_t</span><br><span class="line">calculate_path_metric(rpl_parent_t *p)</span><br><span class="line">&#123;</span><br><span class="line">  uip_ds6_nbr_t *nbr;</span><br><span class="line">  if(p &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    return MAX_PATH_COST * RPL_DAG_MC_ETX_DIVISOR;</span><br><span class="line">  &#125;</span><br><span class="line">  nbr &#x3D; rpl_get_nbr(p);</span><br><span class="line">  if(nbr &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    return MAX_PATH_COST * RPL_DAG_MC_ETX_DIVISOR;</span><br><span class="line">  &#125;</span><br><span class="line">#if RPL_DAG_MC &#x3D;&#x3D; RPL_DAG_MC_NONE</span><br><span class="line">  &#123;</span><br><span class="line">    return p-&gt;rank + (uint16_t)nbr-&gt;link_metric;</span><br><span class="line">  &#125;</span><br><span class="line">#elif RPL_DAG_MC &#x3D;&#x3D; RPL_DAG_MC_ETX</span><br><span class="line">  return p-&gt;mc.obj.etx + (uint16_t)nbr-&gt;link_metric;</span><br><span class="line">#elif RPL_DAG_MC &#x3D;&#x3D; RPL_DAG_MC_ENERGY</span><br><span class="line">  return p-&gt;mc.obj.energy.energy_est + (uint16_t)nbr-&gt;link_metric;</span><br><span class="line">#else</span><br><span class="line">#error &quot;Unsupported RPL_DAG_MC configured. See rpl.h.&quot;</span><br><span class="line">#endif &#x2F;* RPL_DAG_MC *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里路径度量的计算根据的是OF。<br>如果没有父节点，则使用基于最大路径成本(maximum path cost)计算的默认度量。<br>如果没有提到OF，那么路径度量就是秩的和。<br>（因为OF基于ETX，它是被测量的ETX (p-&gt;mc.obj.etx)和链接度量的总和。）<br>类似地，如果OF基于能量，则将能量值(p-&gt;mc.obj.energy.energy_est)添加到链接度量(link metric)中。<br>此函数由best_parent()调用，用于比较两个父节点的路径度量。</p><p><strong>neighbor_link_callback(rpl_parent_t * p, int status, int numtx)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">neighbor_link_callback(rpl_parent_t *p, int status, int numtx)</span><br><span class="line">&#123;</span><br><span class="line">  uint16_t recorded_etx &#x3D; 0;</span><br><span class="line">  uint16_t packet_etx &#x3D; numtx * RPL_DAG_MC_ETX_DIVISOR;</span><br><span class="line">  uint16_t new_etx;</span><br><span class="line">  uip_ds6_nbr_t *nbr &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">  nbr &#x3D; rpl_get_nbr(p);</span><br><span class="line">  if(nbr &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    &#x2F;* No neighbor for this parent - something bad has occurred *&#x2F;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  recorded_etx &#x3D; nbr-&gt;link_metric;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Do not penalize the ETX when collisions or transmission errors occur. *&#x2F;</span><br><span class="line">  if(status &#x3D;&#x3D; MAC_TX_OK || status &#x3D;&#x3D; MAC_TX_NOACK) &#123;</span><br><span class="line">    if(status &#x3D;&#x3D; MAC_TX_NOACK) &#123;</span><br><span class="line">      packet_etx &#x3D; MAX_LINK_METRIC * RPL_DAG_MC_ETX_DIVISOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(p-&gt;flags &amp; RPL_PARENT_FLAG_LINK_METRIC_VALID) &#123;</span><br><span class="line">      &#x2F;* We already have a valid link metric, use weighted moving average to update it *&#x2F;</span><br><span class="line">      new_etx &#x3D; ((uint32_t)recorded_etx * ETX_ALPHA +</span><br><span class="line">                 (uint32_t)packet_etx * (ETX_SCALE - ETX_ALPHA)) &#x2F; ETX_SCALE;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;* We don&#39;t have a valid link metric, set it to the current packet&#39;s ETX *&#x2F;</span><br><span class="line">      new_etx &#x3D; packet_etx;</span><br><span class="line">      &#x2F;* Set link metric as valid *&#x2F;</span><br><span class="line">      p-&gt;flags |&#x3D; RPL_PARENT_FLAG_LINK_METRIC_VALID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PRINTF(&quot;RPL: ETX changed from %u to %u (packet ETX &#x3D; %u)\n&quot;,</span><br><span class="line">        (unsigned)(recorded_etx &#x2F; RPL_DAG_MC_ETX_DIVISOR),</span><br><span class="line">        (unsigned)(new_etx  &#x2F; RPL_DAG_MC_ETX_DIVISOR),</span><br><span class="line">        (unsigned)(packet_etx &#x2F; RPL_DAG_MC_ETX_DIVISOR));</span><br><span class="line">    &#x2F;* update the link metric for this nbr *&#x2F;</span><br><span class="line">    nbr-&gt;link_metric &#x3D; new_etx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数接收链路层邻居信息。<br>参数状态设置为0或1。<br>numetx参数表示当前邻居节点的ETX(estimated transmission)。<br>recorded_etx 是 link_metric，packet_etx是传递给函数的numetx参数。<br>new_etx是根据公式使用recorded and packet ETX计算的。<br>link_metric用新的ETX值更新。</p><p><strong>calculate_rank(rpl_parent_t * p, rpl_rank_t base_rank)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static rpl_rank_t</span><br><span class="line">calculate_rank(rpl_parent_t *p, rpl_rank_t base_rank)</span><br><span class="line">&#123;</span><br><span class="line">  rpl_rank_t new_rank;</span><br><span class="line">  rpl_rank_t rank_increase;</span><br><span class="line">  uip_ds6_nbr_t *nbr;</span><br><span class="line"></span><br><span class="line">  if(p &#x3D;&#x3D; NULL || (nbr &#x3D; rpl_get_nbr(p)) &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    if(base_rank &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return INFINITE_RANK;</span><br><span class="line">    &#125;</span><br><span class="line">    rank_increase &#x3D; RPL_INIT_LINK_METRIC * RPL_DAG_MC_ETX_DIVISOR;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    rank_increase &#x3D; nbr-&gt;link_metric;</span><br><span class="line">    if(base_rank &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      base_rank &#x3D; p-&gt;rank;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(INFINITE_RANK - base_rank &lt; rank_increase) &#123;</span><br><span class="line">    &#x2F;* Reached the maximum rank. *&#x2F;</span><br><span class="line">    new_rank &#x3D; INFINITE_RANK;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">   &#x2F;* Calculate the rank based on the new rank information from DIO or</span><br><span class="line">      stored otherwise. *&#x2F;</span><br><span class="line">    new_rank &#x3D; base_rank + rank_increase;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new_rank;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类似于前面介绍的calculate_rank()函数，但有一点不同。<br>在这个函数中，如果parent = NULL，rank_increase是一个等于RPL_INIT_LINK_METRIC的增量。否则它等于link_metric。<br>new_rank = the increment + base rank</p><p><strong>est_parent(rpl_parent_t * p1, rpl_parent_t * p2)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static rpl_parent_t *</span><br><span class="line">best_parent(rpl_parent_t *p1, rpl_parent_t *p2)</span><br><span class="line">&#123;</span><br><span class="line">  rpl_dag_t *dag;</span><br><span class="line">  rpl_path_metric_t min_diff;</span><br><span class="line">  rpl_path_metric_t p1_metric;</span><br><span class="line">  rpl_path_metric_t p2_metric;</span><br><span class="line"></span><br><span class="line">  dag &#x3D; p1-&gt;dag; &#x2F;* Both parents are in the same DAG. *&#x2F;</span><br><span class="line"></span><br><span class="line">  min_diff &#x3D; RPL_DAG_MC_ETX_DIVISOR &#x2F;</span><br><span class="line">             PARENT_SWITCH_THRESHOLD_DIV;</span><br><span class="line"></span><br><span class="line">  p1_metric &#x3D; calculate_path_metric(p1);</span><br><span class="line">  p2_metric &#x3D; calculate_path_metric(p2);</span><br><span class="line"></span><br><span class="line">  &#x2F;* Maintain stability of the preferred parent in case of similar ranks. *&#x2F;</span><br><span class="line">  if(p1 &#x3D;&#x3D; dag-&gt;preferred_parent || p2 &#x3D;&#x3D; dag-&gt;preferred_parent) &#123;</span><br><span class="line">    if(p1_metric &lt; p2_metric + min_diff &amp;&amp;</span><br><span class="line">       p1_metric &gt; p2_metric - min_diff) &#123;</span><br><span class="line">      PRINTF(&quot;RPL: MRHOF hysteresis: %u &lt;&#x3D; %u &lt;&#x3D; %u\n&quot;,</span><br><span class="line">             p2_metric - min_diff,</span><br><span class="line">             p1_metric,</span><br><span class="line">             p2_metric + min_diff);</span><br><span class="line">      return dag-&gt;preferred_parent;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return p1_metric &lt; p2_metric ? p1 : p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类似于前面的best_parent()函数，该函数比较两个父类并返回最佳的一个。<br>这里，为每个父节点计算的路径度量(path metric)是比较的基础。<br>首先检查在DAG中是否有一个父节点被设置为首选父对象，如果是，则选择它作为最佳父对象(基于MRHOF滞后现象 RFC 6719)。<br>否则，将比较计算的两个度量，选择具有较低度量的节点为最好的父节点。<br>在这个函数下，只有当它比当前路径少于一个给定阈值时，才切换到最小秩路径。<br>第二种机制称为“滞后现象”(RFC 6719)。这里，PARENT_SWITCH_THRESHOLD_DIV被定义为2。</p><p>这种父选择发生在以下情况中：</p><ul><li>在网络的初始形成过程中</li><li>当邻近节点的路径代价发生变化时</li><li>一个新节点出现在该节点的邻域中</li></ul><h2 id="5-目标函数的修改"><a href="#5-目标函数的修改" class="headerlink" title="5.目标函数的修改"></a>5.目标函数的修改</h2><p><img src="https://s2.ax1x.com/2020/01/08/l2jDWd.png" alt="l2jDWd.png"><br>上图显示了一个可以使用的拓扑示例。<br>一个目标函数基本上使用一个链路度量(link metric)，并有一个约束的函数试图为路由选择最佳路径。<br>要定义一个全新的目标函数文件(不修改现有文件)，必须在其中定义以下函数。<br>还应该相应地修改makefile，并注意新文件不应出现编译和链接错误。<br>一些RPL OF 的API如下所示：</p><ul><li>reset(dag):重置特定DAG的目标函数状态。在对DAG执行全局修复时调用此函数。</li><li>neighbor_link_callback(parent, status, etx): 接收链路层邻居信息。</li><li>best_parent(parent1, parent2):根据OF，比较两个父节点并返回最好的一个。</li><li>best_dag(dag1, dag2):根据OF，比较两个dag并返回最好的一个。</li><li>calculate_rank(parent, base_rank): 使用父秩和基秩计算秩值。</li><li>update_metric_container(dag): 在某个DAG中更新传出DIOs的度量容器。如果DAG的目标函数不使用度量容器，则该函数应该将对象类型设置为RPL_DAG_MC_NONE。</li></ul><p>修改目标函数的一个例子可以是<strong>Load Balancing application</strong>。<br>新的目标函数应该选择一条最小化ETX的路由，如果有多条路由具有相同的ETX，或者ETX在预定义的范围内，那么它应该减小这些路由中任意一条转发包的最大数量。<br>这意味着任何一个节点都不承担转发包的负载，而其他节点则处于未被利用的状态。</p><p>解决这个问题的一种方法是定义一个如前所述的全新的目标函数。<br>另一种方法是修改现有的rpl-mhrof.c文件。因为它已经使用了问题的最小ETX部分，我们只需要实现负载平衡部分。<br>当一个子节点有多条路由时，负载平衡就出现了，比如父节点们。因此，the best parent function应该做相应的修改。</p><p>另一个例子是选择<strong>shortest path with nodes using minimum energy</strong>。<br>这里的目标函数应该是这样的:<br>    它首先使用最小能量或在一个范围内识别节点；<br>    然后使用最小跳数通过这些节点到达目的地。<br>这可以应用于这样一种情况:一个节点必须快速发送数据，而不会给一个能量不足的节点带来负担。<br>在这个场景中，使用能量度量的目标函数在当前的rpl-mhrof.c中的当前实现中已经存在，并且目标函数可以与附加逻辑一起用于在选择父节点时选择最小跳数。<br>其他需要新的或修改的目标函数的场景可以基于不同的链接度量，如吞吐量(throughput)、链接质量级别(link quelity level)、延迟(latency)等。</p><h2 id="6-Cooja仿真（在DGRM模式下）"><a href="#6-Cooja仿真（在DGRM模式下）" class="headerlink" title="6.Cooja仿真（在DGRM模式下）"></a>6.Cooja仿真（在DGRM模式下）</h2><p>使用DGRM模型是因为它更容易改变链路接收速率。<br>此外，在两个需要的节点之间形成链接也更容易，其他节点除外。以下是形成一个新的模拟的步骤:</p><p>注意:您可以参考<a href="http://anrg.usc.edu/contiki/index.php/Cooja_Simulator" target="_blank" rel="noopener">Cooja Simulater</a>来了解Cooja.</p><ul><li>运行cooja</li></ul><p>打开你的contiki文件夹，在路径“contiki-3.0/tools/cooja”下，进入终端，敲下面命令，打开GUI界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ant run</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/01/08/l2zBYF.png" alt="l2zBYF.png"></p><ul><li>开始一个新的仿真</li></ul><p>从<code>file</code>下拉菜单中选择<code>New Simulation</code><br><img src="https://s2.ax1x.com/2020/01/08/l2zjk8.png" alt="l2zjk8.png"></p><p>会弹出下面的界面：<br><img src="https://s2.ax1x.com/2020/01/08/lRSQn1.png" alt="lRSQn1.png"></p><p>在<code>simulation name</code>栏中，填写你的仿真名称；<br>在<code>radio medium</code>下拉选项中，选择<code>directed graph radio medium(DGRM)</code><br>点击<code>creat</code>按钮，创建仿真工程。<br><img src="https://s2.ax1x.com/2020/01/08/lRpP8e.png" alt="lRpP8e.png"></p><p>创建的new simulation将打开多个窗口，如下所示。<br><img src="https://s2.ax1x.com/2020/01/08/lRpn58.png" alt="lRpn58.png"></p><ul><li>添加sink mote</li></ul><p>添加类型为Sink的mote。<br><img src="https://s2.ax1x.com/2020/01/08/lRp0xJ.png" alt="lRp0xJ.png"></p><p>这里使用了来自rpl-collect示例(/examples/ipv6/rpl-collect/)的udp-sink.c代码。<br>但是，您可以根据应用程序上传任何想要实现的代码。<br>单击<code>Compile</code>按钮。<br><img src="https://s2.ax1x.com/2020/01/08/lRpHdP.png" alt="lRpHdP.png"></p><p>在成功编译时，将出现一个创建按钮，该按钮可根据需要在网络中添加更多的mote。这里只添加1个sink节点。<br><img src="https://s2.ax1x.com/2020/01/08/lR9PoV.png" alt="lR9PoV.png"></p><ul><li>添加其他sender motes<br>添加其他类型的mote。<br>这里使用的是来自rpl-collect示例(/examples/ipv6/rpl-collect/)的udp-sender.c代码。<br>但是，您可以根据应用程序上传任何想要实现的代码。<br><img src="https://s2.ax1x.com/2020/01/08/lR9vtK.png" alt="lR9vtK.png"><br>编译代码并根据拓扑结构创建许多这种类型的motes。<br><img src="https://s2.ax1x.com/2020/01/08/lRiKwn.png" alt="lRiKwn.png"><br><img src="https://s2.ax1x.com/2020/01/08/lRi3WT.png" alt="lRi3WT.png"></li></ul><p><strong>注意</strong>:mote的位置在这里并不重要。你可以把你的motes放在图表的任何地方。由于这与距离模型不同，我们在motes之间建立了明确的通信联系，因此它们之间的距离没有区别。</p><ul><li>添加communication links</li></ul><p>在每组节点之间添加两个通信链路，使通信可以是双向的。</p><p>选择<code>tools-&gt;DGRM Links...</code>这将打开一个DGRM配置器对话框。<br><img src="https://s2.ax1x.com/2020/01/08/lRFm9K.png" alt="lRFm9K.png"></p><p>单击<code>Add</code>.选择<code>source</code>和<code>destination</code>，然后再次单击<code>Add</code>。这将添加一个从源节点到目标节点的单向链接。对于双向链接，您需要添加一个带有交换的源节点和目标节点的链接。您可以通过这种方式添加多个链接。添加链接后关闭对话框。<br><img src="https://s2.ax1x.com/2020/01/08/lRFcCV.png" alt="lRFcCV.png"><br>您可以根据您的应用程序更改链接的其他参数，如RX radio、RSSI、LQI和delay。这些参数会影响单个链接的质量。RX radio影响ETX值。<br>因此，要在各种链接质量条件下测试应用程序时，可以更改这些参数。</p><p>您还可以使用remove选项删除一个现有的。<br>Import选项有助于导入已经在其中指定了这些链接连接和参数的任何数据文件。</p><ul><li>运行仿真</li></ul><p>使用simulation control窗口中的Start选项运行仿真。<br>这将启动mote，并且分配给所有的mote一个新的rime地址和其他初始化过程。<br><img src="https://s2.ax1x.com/2020/01/08/lRkzyF.png" alt="lRkzyF.png"></p><ul><li>Watch Output</li></ul><ol><li>motes输出和调试消息可以在Motes Output窗口中看到。</li><li>可以根据节点ID:node_id对输出进行筛选，以监视特定的节点。</li><li>还可以通过过滤来查看特定的调试消息。</li><li>Motes output中其他有用功能是file,edit和view。<br> File选项有助于将输出保存到文件中。<br> Edit具有复制输出的选项 — 完整的或特定选定的消息。</li><li>您还可以使用Clear all messages选项来清除消息。</li><li>使用这些保存在文件中的信息，根据您的实验目标进行观察并绘制图形。</li></ol><h2 id="7-温馨提醒"><a href="#7-温馨提醒" class="headerlink" title="7.温馨提醒"></a>7.温馨提醒</h2><p>在运行cooja时，一定要以sudo ant的方式运行，因为只运行ant可能会抛出一些错误，因为它可能无法访问某些文件。<br>如果网络很大或ETX值很大，则来自叶节点的数据包可能需要一段时间才能到达根节点。<br>因此，您可能需要长时间地运行模拟。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://tools.ietf.org/html/rfc6550" target="_blank" rel="noopener">RFC 6550</a> RPL: IPv6 Routing Protocol for Low-Power and Lossy Networks</li><li><a href="https://tools.ietf.org/html/rfc6552" target="_blank" rel="noopener">RFC 6552</a> Objective Function Zero for the Routing Protocol for Low-Power and Lossy Networks (RPL)</li><li><a href="https://tools.ietf.org/html/rfc6719" target="_blank" rel="noopener">RFC 6719</a> MRHOF: The Minimum Rank with Hysteresis Objective Function </li><li><a href="http://dunkels.com/adam/ko11contikirpl.pdf" target="_blank" rel="noopener">ContikiRPL and TinyRPL: Happy Together</a></li><li><a href="https://github.com/contiki-ng/contiki-ng/wiki/Documentation:-RPL" target="_blank" rel="noopener">Documentation: RPL</a></li><li><a href="https://github.com/contiki-ng/contiki-ng/wiki/Tutorial:-RPL" target="_blank" rel="noopener">Tutorial: RPL</a></li></ol><hr><p>此文翻译的是链接 <a href="https://blog.csdn.net/frank_jb/article/details/50912306" target="_blank" rel="noopener">https://blog.csdn.net/frank_jb/article/details/50912306</a> 的内容</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;&gt;&lt;/a&gt;1.介绍&lt;/h2&gt;&lt;p&gt;低功耗和有损耗网络的路由协议利用目标函数(OF)建立一个面向目标的有向无环图(DODAG)。目标函数根据某种算法或计算公式使</summary>
      
    
    
    
    <category term="contiki" scheme="https://adamyandan.github.io/categories/contiki/"/>
    
    
    <category term="contiki" scheme="https://adamyandan.github.io/tags/contiki/"/>
    
    <category term="cooja" scheme="https://adamyandan.github.io/tags/cooja/"/>
    
    <category term="RPL" scheme="https://adamyandan.github.io/tags/RPL/"/>
    
  </entry>
  
</feed>
